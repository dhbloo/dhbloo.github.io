<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="函数式编程在C++中的应用"><meta name="keywords" content="C++,函数式编程"><meta name="author" content="dhbloo,duanhb1084@qq.com"><meta name="copyright" content="dhbloo"><title>函数式编程在C++中的应用 | dhb's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.8.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.8.2"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.7.2/css/all.min.css?version=1.8.2"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://www.google-analytics.com"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-143073882-2', 'auto');
ga('send', 'pageview');</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.0.2'
} </script><meta name="generator" content="Hexo 5.0.2"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text"> 函数式编程简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8Ec"><span class="toc-number">2.</span> <span class="toc-text"> 函数式编程与C++</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number"></span> <span class="toc-text"> 实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-%E6%B3%9B%E5%9E%8B-%E9%97%AD%E5%8C%85"><span class="toc-number">1.</span> <span class="toc-text"> 1. 高阶函数、泛型、闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-stl%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text"> 2. STL中的函数式编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A8%A1%E7%89%88%E5%85%83%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text"> 3. 模版元编程与函数式编程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number"></span> <span class="toc-text"> 总结</span></a></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/icons/avatar.jpg"></div><div class="author-info__name text-center">dhbloo</div><div class="author-info__description text-center">A CS student, currently studying at HUST</div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/dhbloo">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">15</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">18</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://gomocalc.github.io/">Gomocalc</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://blog.nirvanasc.com/">ChenYixin</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">dhb's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/log">Site Log</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">函数式编程在C++中的应用</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-04-30</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/C/">C++</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">6k</span><span class="post-meta__separator">|</span><span>阅读时长: 20 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>函数式作为一种独特的编程范式，本着一切皆为函数的思想使它与传统的命令式编程、声明式编程形成了鲜明的差异。说到函数式编程，大部分人首先想到的是像Lisp、ML、Haskell、Scala这样的主打函数式编程的“纯”函数式语言，不过，这些语言从使用人数上来说算是小众语言，对于绝大部分的程序，命令式编程仍然占到主流。随着近些年来一些热门语言，如Python、JavaScript对函数式编程的越来越强的支持，函数式的思想可以说是逐渐成为了编程人员不可不知的一种主流编程范式。在这篇文章中我会讨论函数式编程在一门“古老”的语言——C++中的应用。可以看到，即使是C++这种偏向底层的系统级开发语言，近几年来也逐步加入了对函数式编程越来越多的支持。</p>
<a id="more"></a>
<h3 id="函数式编程简介"><a class="markdownIt-Anchor" href="#函数式编程简介"></a> 函数式编程简介</h3>
<p>函数式编程相比传统的编程范式有许多特点，我们可以在这里简单列举一些主要的特点：</p>
<ol>
<li>
<p>函数被认为是“一等公民”：函数可以像其他数据类型一样，被很容易地定义，被赋值传递等。</p>
</li>
<li>
<p>强调“无副作用”的函数/引用透明：函数内部不会修改任何的外部状态，且函数的返回值仅取决于传入的参数。</p>
</li>
<li>
<p>变量是**不可变（immutable）**的：变量不同于命令式编程的储存单元，不能被赋值，只能说是计算得到了一个新变量。</p>
</li>
<li>
<p>强调基于表达式而不是语句：表达式只是一个单独的计算过程，而语句一般表示“执行某个（产生副作用）的操作”，这与上面一点也是对应的。</p>
</li>
</ol>
<p>正是有了这些特点的“约束”，函数式编程与之而来的也有许多命令式编程望而止步的优点，比如善于以一些短小精悍的小函数，逐步组建为一个功能强大的程序，在减少了代码重复的同时，也加快了程序开发速度；由于有了引用透明，函数在什么时候求值均可以，所以可以<strong>惰性求值</strong>；由于函数不会修改外部状态产生副作用，代码可以完美转换到并行执行而不用担心数据竞争的问题…</p>
<p>C++这门语言从基于命令式的C语言发展而来，从源头上就和函数式编程“背道而驰”。比如函数不能随处定义传递；绝大部分函数都是有副作用的，还有专门为了副作用而生的函数（如<code>printf</code>）；基于语句而非表达式等。这就造成了很大的割裂，背后的原因也很明显，在C语言出现的那个年代，由于计算器的性能极低且极其昂贵，人们更偏向于“面向机器编程”，因此更接近机器底层的寄存器模型的C语言受到了广泛欢迎。不过到了今天，接近底层机器不再是优势，随着程序规模的膨胀，具有更好抽象能力、更接近数学的函数式编程方式更加受到人们的青睐。C++一直以来的设计目标是一种“多范式语言”，认为没有一种编程范式是适用于任何情况的，对各种编程范式的均支持才会有更强的表达能力。随着近几年的发展演变，C++引入了越来越多的函数式思想，让我们真正看到了函数式编程可以走入实际应用之中。</p>
<h3 id="函数式编程与c"><a class="markdownIt-Anchor" href="#函数式编程与c"></a> 函数式编程与C++</h3>
<p>有人将函数式与命令式的区别总结为：</p>
<blockquote>
<p>函数式编程关心数据的映射，命令式编程关心解决问题的步骤</p>
</blockquote>
<p>命令式编程就好像告诉计算机每一步要做什么，而函数式编程则告诉计算机问题的定义是什么，余下的让计算机自行求解。举个例子，要求一个列表<code>[1,2,3,...]</code>的和，在命令式编程中我们会用一个for循环，定义累加变量，告诉计算机每一步要加上一个数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; L.<span class="built_in">size</span>(); i++)</span><br><span class="line">	s = s + L[i];</span><br></pre></td></tr></table></figure>
<p>而在函数式编程中，根本没有循环这种结构，我们只需要告诉计算机求和的定义是什么就可以了：比如求和可以看做是列表的头加上剩余列表的求和，且空列表的和为0。从这个简单的定义我们就可以得到如下的ML程序：</p>
<figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> sum <span class="literal">[]</span> = <span class="number">0</span></span><br><span class="line">  | sum (x::<span class="type">L</span>) = x + sum <span class="type">L</span></span><br></pre></td></tr></table></figure>
<p>显而易见，下面的程序比上面的程序更加简短，且不会出现循环条件错误，忘记初始化等等bug。</p>
<p>如果单对函数式编程泛泛而谈，我们可能很难摸清其具体的轮廓。更好的方式是寻找函数式编程中的具体<strong>特性</strong>，如果C++对这些特性有足够的支持，那么它就足够用于函数式编程（当然，纯函数式的语言表达这些特性一般会更简单）：</p>
<ol>
<li>
<p><strong>纯函数</strong>（Pure Function）：函数不产生可以观测的副作用。C++中并没有明确表示纯函数的方式，不过只要函数本身没有对外部状态的修改，我们就可以认为它是纯函数。不过，并不是所有函数都是纯函数，总会有一些操作，它们不能以纯函数的形式表示（如IO操作），这时候我们可以放宽要求，允许一定的非纯函数，不过我们仍然可以让非纯函数的数量减到最少。</p>
</li>
<li>
<p>对<strong>递归</strong>的支持：由于函数式编程中变量是不可变的，自然也就没有了循环结构，这时，如果算法需要迭代，唯一的途径只有递归，因此在函数式编程中需要大量用到递归，需要语言对递归有较好的支持，比如自动将尾递归转换为循环等。</p>
</li>
<li>
<p><strong>高阶函数</strong>（High-Order Function）：参数为函数或者返回值为函数的函数，也就是函数要能够作为一等公民。在C++中，高阶函数可以以函数指针或函数对象（Function Object）实现，比如一个函数对象就是重载了<code>operator()</code>运算符的类的实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Add</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C++11及以后引入了<strong>匿名函数</strong>（Lambda Function），其本质上与函数对象相同，不过进一步简化了函数定义的语法，让函数可以随处进行定义和传递：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Add = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>偏应用的函数</strong>（Partially Applied Functions）与<strong>柯里化</strong>（Currying）：对函数的部分参数提前进行绑定，得到需要剩下参数的函数。比如上面定义的<code>Add</code>函数，如果要改造为柯里化的形式，可以在C++中写作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> PartialAdd = [=](<span class="keyword">auto</span> a) &#123;</span><br><span class="line">	<span class="keyword">return</span> [=](<span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> Add(a, b); &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样，在应用时就可以提前绑定一个参数，在得到返回的函数后绑定剩下的一个参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = PartialAdd(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">auto</span> x = f(<span class="number">5</span>);			<span class="comment">// x = 7; </span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>闭包</strong>（Closure）：闭包是自动捕获了外部状态的函数，在C++中体现为有成员变量的函数对象。不过在C++11后的Lambda函数，我们可以很方便的捕获外部变量形成闭包。比如上面的<code>PartialAdd</code>函数就应用到了闭包，其外层函数捕获了<code>Add</code>函数，其内层函数捕获了传入<code>a</code>参数和<code>Add</code>函数。捕获的表示在两个方括号<code>[]</code>之间，<code>[=]</code>表示的是默认以值拷贝的方式捕获，与之对应的还有<code>[&amp;]</code>表示默认以引用的方式捕获。</p>
</li>
<li>
<p><strong>模式匹配</strong>（Pattern Match）：模式匹配也是函数式编程中的一大利器，在递归时作为分支选择必不可少的攻击。可惜C++中对模式匹配的支持尚且不强，运行时的函数只能通过<code>if</code>语句手动进行匹配，不过，C++对于编译时的模版元编程中还是支持了一定的模式匹配。</p>
</li>
<li>
<p><strong>惰性求值</strong>（Lazy evaluation）：惰性求值可以让表达式的计算推延到实际使用时再进行，可以避免不必要的计算。在C++中也有相应的方法实现惰性求值。</p>
</li>
</ol>
<p>从上面可以看出C++11以后对函数式编程有着足够的支持，在一些方面不亚于函数式语言。我们可以从不同的几个实例来感受一下C++中的函数式编程是什么样的。</p>
<h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2>
<h3 id="1-高阶函数-泛型-闭包"><a class="markdownIt-Anchor" href="#1-高阶函数-泛型-闭包"></a> 1. 高阶函数、泛型、闭包</h3>
<p>在C++中有多种对象都都可以被认为是函数。运用鸭子类型（Duck Typing）的说法：任何“可以像函数一样调用的东西就是函数”。前面说到，C++中主要有3种类型的函数：函数指针、函数对象（重载<code>operator()</code>的类对象）、匿名函数。要进一步地深入使用函数式，我们可以用数学化的方式表达类型。比如平时我们常见的函数声明方式一般是这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrThenAdd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x * x + y; &#125;</span><br></pre></td></tr></table></figure>
<p>这个函数的类型我们可以表示为<code>(int * int) -&gt; int</code>，因为它可以看做是一个变化：将一个<code>int</code>二元组变换为一个<code>int</code>。在函数式语言中也可以很自然地得到如下定义与其类型：</p>
<figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">fun</span> sqrThenAdd (x : <span class="built_in">int</span>, y : <span class="built_in">int</span>) : <span class="built_in">int</span> = x * x + y;</span><br><span class="line"><span class="keyword">val</span> sqrThenAdd = <span class="keyword">fn</span> : <span class="built_in">int</span> * <span class="built_in">int</span> -&gt; <span class="built_in">int</span></span><br></pre></td></tr></table></figure>
<p>C++11后也可以写成这种更自然的表示法：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto sqrThenAdd(int x, int y) -&gt; int &#123; return x * x + y; &#125;</span><br></pre></td></tr></table></figure>
<p>不过，一般在函数式语言中我们不会明确标注类型，取而代之的是使用<strong>泛型</strong>，并让编译器推导相关类型。这样既减少了对类型思考的负担，也增强了程序的适用范围。在C++中也可以实现这个目标，比如使用模版函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arithmetic1, <span class="keyword">typename</span> Arithmetic2&gt;</span><br><span class="line">auto sqrThenAdd(Arithmetic1 x, Arithmetic2 y) -&gt; decltype(auto) &#123; return x * x + y; &#125;</span><br></pre></td></tr></table></figure>
<p>在这里，<code>Arithmetic</code>代指一个泛型类型，返回值的<code>decltype(auto)</code>表示让编译器自动推导返回表达式的类型作为返回类型。当我们以<code>sqrThenAdd(1, 2)</code>调用时，编译器会将其推导为<code>(int * int) -&gt; int</code>；而当我们以<code>sqrThenAdd(1.0, 2.0)</code>调用时，编译器会推导为<code>(double * double) -&gt; double</code>，这里就体现了一个重要的特性——<strong>静态多态</strong>，极大地增强了函数的适用范围。不过，过大的范围也不是好事，比如这里的<code>Arithmetic</code>仅指代算术类型，即有<code>*</code>、<code>+</code>运算符的数据类型，对于其他类型这段程序是没有意义的。目前阶段的C++要实现这个限制较为麻烦，而在C++20后即将引入了Concept较好地解决了这个问题。</p>
<p>另一种更为符合函数式的函数定义语法是匿名函数。在C++14之后加入的Generic Lambda让匿名函数也很好地支持了泛型，比如下面这个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mapThenAdd = [](<span class="keyword">auto</span> f, <span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> f(x) + y; &#125;;</span><br></pre></td></tr></table></figure>
<p>其中除了<code>auto</code>标识符并没有任何类型声明，其类型会像模版一样自动推导。可以看到<code>f</code>在函数体内被调用，是一类函数参数。<code>mapThenAdd</code>自身就是一个高阶函数，其作用是对参数<code>x</code>应用<code>f</code>函数并加上<code>y</code>。按照函数式语言中的数据类型定义，<code>mapThenAdd</code>接受的是一个有3个元素的元组，如果我们想要柯里化的函数形式，需要对其的部分做绑定。在函数式编程中我们可能会写出以下的程序：</p>
<figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> mapThenAdd (f, x, y) = f(x) + y;</span><br><span class="line"><span class="keyword">fun</span> bind (f, arg) = <span class="keyword">fn</span> (x, y) =&gt; f(arg, x, y);</span><br><span class="line"><span class="keyword">val</span> sqrThenAdd = bind(mapThenAdd, <span class="keyword">fn</span> x =&gt; x * x);</span><br><span class="line"><span class="keyword">val</span> r = sqrThenAdd(<span class="number">2</span>, <span class="number">3</span>);	<span class="comment">(* r = 7 *)</span></span><br></pre></td></tr></table></figure>
<p>上面这段程序将<code>mapThenAdd</code>函数的<code>f</code>参数提前进行绑定，<code>bind</code>函数就是完成这个工作的高阶函数，传入其中的<code>f</code>和<code>arg</code>都被<strong>闭包</strong>绑定了下来，在绑定了一个平方函数后就返回了完成<code>sqrThenAdd</code>功能的函数。通过这个方法，我们也可以很容易地对这个函数进行柯里化。在C++中实现相同功能也一样很简单：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> bind = [](<span class="keyword">auto</span> f, <span class="keyword">auto</span> arg) &#123;<span class="keyword">return</span> [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;<span class="keyword">return</span> f(arg, x, y);&#125;;&#125;;</span><br><span class="line"><span class="keyword">auto</span> sqrThenAdd = bind(mapThenAdd, [](<span class="keyword">auto</span> x) &#123;<span class="keyword">return</span> x * x;&#125;);</span><br><span class="line"><span class="keyword">auto</span> r = sqrThenAdd(<span class="number">2</span>, <span class="number">3</span>);	<span class="comment">// r = 7</span></span><br></pre></td></tr></table></figure>
<p>从上面的这些例子中，我们一窥了C++中的函数式编程，有了这些语言上的基础，我们才得以将其逐步应用在更加实用且复杂的场合。</p>
<h3 id="2-stl中的函数式编程"><a class="markdownIt-Anchor" href="#2-stl中的函数式编程"></a> 2. STL中的函数式编程</h3>
<p>STL（Standard Template Library）标准模版库是C++的自带库，虽然C++一直以来被认为是“面向对象语言”，也常常被用作“C with class”，但是STL的作者却很少地用到了面向对象的编程范式，而是大量用到了以模版为支撑的泛型编程与函数式编程的范式，在使用STL时就能明显的感到这一点。比如排序函数<code>std::sort</code>的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ns &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::sort(ns.<span class="built_in">begin</span>(), ns.<span class="built_in">end</span>(), [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;<span class="keyword">return</span> x &lt; y;&#125;);</span><br></pre></td></tr></table></figure>
<p>这里<code>std::sort</code>的第三个参数是用于比较大小的谓词，也就是一个匿名函数。常见的比较谓词在标准库中已经写好了，比如上面程序中的小于谓词可以写作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(ns.<span class="built_in">begin</span>(), ns.<span class="built_in">end</span>(), <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure>
<p>在函数式编程中被大量使用的“三件套”：Map、Filter、Fold在STL中也都有对应物。通过这3个函数的任意组合，我们可以创建处理变换数据的<strong>流水线</strong>（Pipeline），实现强大的功能。</p>
<p>让我们用一段小程序体会一下：假设现在我想实现一个统计代码行数的功能，输入是一个代码文本文件名组成的序列，输出是所有代码的总行数，但是要避免计入一些琐碎的小文件，也就是说对于行数少于10行的文件不计入总行数中。如果习惯了传统编程思维，很容易写出下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_lines_in_files</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;files)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  total_lines = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c           = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;f : files) &#123;</span><br><span class="line">        <span class="keyword">int</span>           lines = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::ifstream <span class="title">in</span><span class="params">(f)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (in.<span class="built_in">get</span>(c)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                lines++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lines &gt;= <span class="number">10</span>)</span><br><span class="line">            total_lines += lines;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_lines;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使是一段简单的逻辑也用到了二重循环和几个维护局部状态的变量。这样写出来的程序确实能用，但是我们很快可以发现它的缺点：容易不小心出现bug，比如局部变量忘记初始化、循环条件错误、状态设置错误等；此外程序显得啰嗦，修改起来也并不方便。</p>
<p>如果换成函数式的思想，需要将程序的“可变状态”减少，因为一旦状态一多，出错的可能性就大幅增加。稍加思索我们就可以发现这段程序所做的操作都在“三件套”描述的范围内：</p>
<ol>
<li>Map：将文本文件名转换为文件的行数，转换函数的类型为<code>std::string -&gt; int</code></li>
<li>Filter：筛选出不少于10的行数，谓词函数的类型为<code>int -&gt; bool</code></li>
<li>Fold：计算出满足条件的行数之和，折叠函数为求和运算</li>
</ol>
<p>通过使用STL中“三件套”的对应物，我们可以写出以下程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_lines_in_files</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;files)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lines</span><span class="params">(files.<span class="built_in">size</span>())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> count_lines = [](<span class="built_in">std</span>::<span class="built_in">string</span> file) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::ifstream in(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::count(<span class="built_in">std</span>::istreambuf_iterator&lt;<span class="keyword">char</span>&gt;(in),</span><br><span class="line">                          <span class="built_in">std</span>::istreambuf_iterator&lt;<span class="keyword">char</span>&gt;(),</span><br><span class="line">                          <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> pred = [](<span class="keyword">int</span> i) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> i &lt; <span class="number">10</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::transform(files.<span class="built_in">begin</span>(), files.<span class="built_in">end</span>(), lines.<span class="built_in">begin</span>(), count_lines); <span class="comment">// Map</span></span><br><span class="line">    <span class="keyword">auto</span> lines_end = <span class="built_in">std</span>::remove_if(lines.<span class="built_in">begin</span>(), lines.<span class="built_in">end</span>(), pred);		<span class="comment">// Filter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::accumulate(lines.<span class="built_in">begin</span>(), lines_end, <span class="number">0</span>, <span class="built_in">std</span>::plus&lt;<span class="keyword">int</span>&gt;());	<span class="comment">// Foldl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，高阶函数<code>std::transform</code>、<code>std::remove_if</code>、<code>std::accumulate</code>定义好了Map、Filter、Fold的操作，而我们只需要传入符合我们要求的函数，就可以描述出我们需要的功能，相比于命令式编程要清晰明了许多。另外，使用函数式的好处就是可以很轻易的复用已有的代码，比如在<code>count_lines</code>就用到了标准中的<code>std::count</code>函数来统计文件中的换行符的个数，其另外一个版本<code>std::count_if</code>就可以自己传入判断谓词，这样不管是什么我们外部的条件怎么变化，这个算法都可以适用。</p>
<p>在命令式的程序啰嗦且繁杂易出错的情况下，函数式程序仍然可以清晰地表述，并且更加符合人类的思维，这也是函数式的重大优点之一。此外还有一个函数式的闪光点：易于并行化。因为算法的高度复用性和引用透明性，函数式程序可以很轻易地变为并行程序，且不用当心各种竞争问题。实际上，函数式的并行算法只要在描述各种操作的高阶函数中完成一次就行，任何其他地方的调用都可以享受到并行的好处。比如只要将上面的代码加一个<code>std::execution::par</code>的标签就可以变为并行的版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::transform(<span class="built_in">std</span>::execution::par, files.<span class="built_in">begin</span>(), files.<span class="built_in">end</span>(), </span><br><span class="line">			   lines.<span class="built_in">begin</span>(), count_lines);</span><br></pre></td></tr></table></figure>
<p>此外，函数式编程中还经常会用到一些常见的**“算术数据类型”**（Algebraic data type），它们在STL也有对应产物。比如在Sumed Type对应<code>std::variant</code>与<code>std::optional</code>、Product Type对应<code>std::pair</code>与<code>std::tuple</code>等。这些原本在函数式语言中普遍使用的类型的引入也让平时的命令式编程得到了改进。</p>
<h3 id="3-模版元编程与函数式编程"><a class="markdownIt-Anchor" href="#3-模版元编程与函数式编程"></a> 3. 模版元编程与函数式编程</h3>
<p>C++的另一大亮点就是对编译期编程的支持。编译期编程是一个庞大的话题，甚至可以写一本上千页厚的书。不过我们还是可以简单地了解一下编译期编程与模版元编程，因为它们其实与函数式编程非常接近。</p>
<p>模版元编程，顾名思义，是基于C++的模版而来的编程方式。C++的模版被创造的初衷是对泛型编程的支持，也就是创造出于类型无关的算法。不过人们很快发现它能做的事远远不止如此。由于模版中有着对<strong>模式匹配</strong>（Pattern Matching）的支持，它完全可以看做是一类纯函数式编程语言。举个经典的例子——计算斐波那契数列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> i&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fib</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = Fib&lt;i<span class="number">-1</span>&gt;::value + Fib&lt;i<span class="number">-2</span>&gt;::value; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fib</span>&lt;1&gt; &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = <span class="number">1</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fib</span>&lt;0&gt; &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = Fib&lt;<span class="number">20</span>&gt;::value;	<span class="comment">// x = 6765</span></span><br></pre></td></tr></table></figure>
<p>这个程序和函数式的程序如出一辙：</p>
<figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> <span class="type">Fib</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line">  | <span class="type">Fib</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">  | <span class="type">Fib</span> i = <span class="type">Fib</span>(i-<span class="number">1</span>) + <span class="type">Fib</span>(i-<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>模版编程所做的事情很简单，C++编译器对于每次出现的模版类型，会将其模版参数代入，<strong>实例化</strong>出特定参数的类型，如果这个类型本身内部引用别的模版类型，实例化的过程就会递归进行…是不是很像函数式编程中的递归过程？这里模版参数就对应着函数参数，类型名对应着函数名，类型内部定义对应着函数体。此外C++在对类型实例化时还会应用模式匹配，也就是说，匹配“最合适”的类型。在上面的例子中，<code>Fib&lt;1&gt;</code>和<code>Fib&lt;0&gt;</code>被称作是<strong>偏特化</strong>的类型，就如同在函数式语言中匹配的特例一样，当实例化到它们的时候，编译器会选择最具体、最合适的偏特化类型，从而形成递归的终止条件。</p>
<p>让我们试试用元编程实现经典的找零问题：给定整数n、一批硬币L，是否能找出总值为n的硬币子集。实现的大致思路是，每次取出列表中的第一枚硬币，如果该硬币的数额比当前总值小，则有两种选择：一是使用该硬币，二是不使用该硬币；如过该硬币的数额比当前总值大，那么一定不能使用该硬币。该算法在C++中可以用如下的模版元编程实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> Select, <span class="keyword">int</span> N, <span class="keyword">int</span> X, <span class="keyword">int</span>...Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change_Impl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span>... Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> solution_count = Change_Impl&lt;<span class="number">2</span>, N, Ls...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span> X, <span class="keyword">int</span>...Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change_Impl</span>&lt;2, N, X, Ls...&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = Change_Impl&lt;<span class="keyword">int</span>(X &lt;= N), N, X, Ls...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span> X, <span class="keyword">int</span>...Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change_Impl</span>&lt;1, N, X, Ls...&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = Change&lt;N - X, Ls...&gt;::solution_count </span><br><span class="line">        					   + Change&lt;N, Ls...&gt;::solution_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span> X, <span class="keyword">int</span>...Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change_Impl</span>&lt;0, N, X, Ls...&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = Change&lt;N, Ls...&gt;::solution_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span>&lt;0&gt; &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> solution_count = <span class="number">1</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span>&lt;N&gt; &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> solution_count = <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Change&lt;<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&gt;::solution_count;	<span class="comment">// 3种(1+3+6,6+4,1+4+5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来十分复杂，但是仔细看的话，这个程序只是在简单地使用模式匹配。传入<code>Change</code>的第一个模版参数为目标总额，其余的模版参数为硬币数额列表，以一个变长模版参数包表示<code>int... Ls</code>。底下两行匹配的是硬币列表为空时的情况，当此时的目标金额为0时则有一种解决方法；否则没有解决方案。为了方便模式匹配，还定义了<code>Change_Impl</code>结构体，它仅接收非空列表，并会对目标金额与首枚硬币的金额进行判断，依次作为匹配依据。<code>Change</code>最后会得到找零方案的个数，比如硬币列表为<code>[1, 3, 6, 4, 5]</code>，目标金额为<code>10</code>时得到的找零方案有3种。</p>
<p>可以看出，模式匹配让我们可以很方便的实现判断逻辑，配合递归可以实现复杂的逻辑。借助函数式编程的思想，模版元编程也可以有很强的表达能力。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>本文简单的概述了一些函数式思想在C++中的应用，这种简洁高效的编程范式让C++这门被广泛运用的语言有了更强的表达能力。我们也看到了，函数式编程让我们的思维从“告诉计算机每一步的步骤”转变为“告诉计算机问题是什么”，从而得到更接近数学的抽象能力，也让程序免于Bug的灾难。不过，函数式编程也不是万能的，有许多问题不能用“纯函数式”的思想实现。而C++这门多范式语言让我们有了更加丰富的选择：不管是命令式、面向对象、函数式，还是泛型编程，都可以作为工具，只要我们将它们用在合适的地方。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:duanhb1084@qq.com">dhbloo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dhbloo.github.io/2020/04/30/Functional-prog-in-cpp/">https://dhbloo.github.io/2020/04/30/Functional-prog-in-cpp/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dhbloo.github.io">dhb's Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">函数式编程</a></div><div class="addthis_inline_share_toolbox pull-right"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5d74ab045bf52ffe" async></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/09/06/Cppcon-Notes/"><i class="fa fa-chevron-left">  </i><span>Cppcon 笔记</span></a></div><div class="next-post pull-right"><a href="/2020/03/12/Sphere/"><span>基本模型——球的N种画法</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://dhbloo.github.io/2020/04/30/Functional-prog-in-cpp/';
  this.page.identifier = '2020/04/30/Functional-prog-in-cpp/';
  this.page.title = '函数式编程在C++中的应用';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'myblog-mdqheoz6z0' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2020 By dhbloo</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Welcome to my blog :)</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.8.2"></script><script src="/js/fancybox.js?version=1.8.2"></script><script src="/js/sidebar.js?version=1.8.2"></script><script src="/js/copy.js?version=1.8.2"></script><script src="/js/fireworks.js?version=1.8.2"></script><script src="/js/transition.js?version=1.8.2"></script><script src="/js/scroll.js?version=1.8.2"></script><script src="/js/head.js?version=1.8.2"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script src="/js/katex.js"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>