<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>函数式编程在C++中的应用</title>
      <link href="/code/Functional-prog-in-cpp/"/>
      <url>/code/Functional-prog-in-cpp/</url>
      
        <content type="html"><![CDATA[<p>函数式作为一种独特的编程范式，本着一切皆为函数的思想使它与传统的命令式编程、声明式编程形成了鲜明的差异。说到函数式编程，大部分人首先想到的是像Lisp、ML、Haskell、Scala这样的主打函数式编程的“纯”函数式语言，不过，这些语言从使用人数上来说算是小众语言，对于绝大部分的程序，命令式编程仍然占到主流。随着近些年来一些热门语言，如Python、JavaScript对函数式编程的越来越强的支持，函数式的思想可以说是逐渐成为了编程人员不可不知的一种主流编程范式。在这篇文章中我会讨论函数式编程在一门“古老”的语言——C<ins>中的应用。可以看到，即使是C</ins>这种偏向底层的系统级开发语言，近几年来也逐步加入了对函数式编程越来越多的支持。</p><a id="more"></a><h3 id="函数式编程简介"><a class="markdownIt-Anchor" href="#函数式编程简介"></a> 函数式编程简介</h3><p>函数式编程相比传统的编程范式有许多特点，我们可以在这里简单列举一些主要的特点：</p><ol><li><p>函数被认为是“一等公民”：函数可以像其他数据类型一样，被很容易地定义，被赋值传递等。</p></li><li><p>强调“无副作用”的函数/引用透明：函数内部不会修改任何的外部状态，且函数的返回值仅取决于传入的参数。</p></li><li><p>变量是**不可变（immutable）**的：变量不同于命令式编程的储存单元，不能被赋值，只能说是计算得到了一个新变量。</p></li><li><p>强调基于表达式而不是语句：表达式只是一个单独的计算过程，而语句一般表示“执行某个（产生副作用）的操作”，这与上面一点也是对应的。</p></li></ol><p>正是有了这些特点的“约束”，函数式编程与之而来的也有许多命令式编程望而止步的优点，比如善于以一些短小精悍的小函数，逐步组建为一个功能强大的程序，在减少了代码重复的同时，也加快了程序开发速度；由于有了引用透明，函数在什么时候求值均可以，所以可以<strong>惰性求值</strong>；由于函数不会修改外部状态产生副作用，代码可以完美转换到并行执行而不用担心数据竞争的问题…</p><p>C<ins>这门语言从基于命令式的C语言发展而来，从源头上就和函数式编程“背道而驰”。比如函数不能随处定义传递；绝大部分函数都是有副作用的，还有专门为了副作用而生的函数（如<code>printf</code>）；基于语句而非表达式等。这就造成了很大的割裂，背后的原因也很明显，在C语言出现的那个年代，由于计算器的性能极低且极其昂贵，人们更偏向于“面向机器编程”，因此更接近机器底层的寄存器模型的C语言受到了广泛欢迎。不过到了今天，接近底层机器不再是优势，随着程序规模的膨胀，具有更好抽象能力、更接近数学的函数式编程方式更加受到人们的青睐。C</ins>一直以来的设计目标是一种“多范式语言”，认为没有一种编程范式是适用于任何情况的，对各种编程范式的均支持才会有更强的表达能力。随着近几年的发展演变，C++引入了越来越多的函数式思想，让我们真正看到了函数式编程可以走入实际应用之中。</p><h3 id="函数式编程与c"><a class="markdownIt-Anchor" href="#函数式编程与c"></a> 函数式编程与C++</h3><p>有人将函数式与命令式的区别总结为：</p><blockquote><p>函数式编程关心数据的映射，命令式编程关心解决问题的步骤</p></blockquote><p>命令式编程就好像告诉计算机每一步要做什么，而函数式编程则告诉计算机问题的定义是什么，余下的让计算机自行求解。举个例子，要求一个列表<code>[1,2,3,...]</code>的和，在命令式编程中我们会用一个for循环，定义累加变量，告诉计算机每一步要加上一个数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; L.<span class="built_in">size</span>(); i++)</span><br><span class="line">s = s + L[i];</span><br></pre></td></tr></table></figure><p>而在函数式编程中，根本没有循环这种结构，我们只需要告诉计算机求和的定义是什么就可以了：比如求和可以看做是列表的头加上剩余列表的求和，且空列表的和为0。从这个简单的定义我们就可以得到如下的ML程序：</p><figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> sum <span class="literal">[]</span> = <span class="number">0</span></span><br><span class="line">  | sum (x::<span class="type">L</span>) = x + sum <span class="type">L</span></span><br></pre></td></tr></table></figure><p>显而易见，下面的程序比上面的程序更加简短，且不会出现循环条件错误，忘记初始化等等bug。</p><p>如果单对函数式编程泛泛而谈，我们可能很难摸清其具体的轮廓。更好的方式是寻找函数式编程中的具体<strong>特性</strong>，如果C++对这些特性有足够的支持，那么它就足够用于函数式编程（当然，纯函数式的语言表达这些特性一般会更简单）：</p><ol><li><p><strong>纯函数</strong>（Pure Function）：函数不产生可以观测的副作用。C++中并没有明确表示纯函数的方式，不过只要函数本身没有对外部状态的修改，我们就可以认为它是纯函数。不过，并不是所有函数都是纯函数，总会有一些操作，它们不能以纯函数的形式表示（如IO操作），这时候我们可以放宽要求，允许一定的非纯函数，不过我们仍然可以让非纯函数的数量减到最少。</p></li><li><p>对<strong>递归</strong>的支持：由于函数式编程中变量是不可变的，自然也就没有了循环结构，这时，如果算法需要迭代，唯一的途径只有递归，因此在函数式编程中需要大量用到递归，需要语言对递归有较好的支持，比如自动将尾递归转换为循环等。</p></li><li><p><strong>高阶函数</strong>（High-Order Function）：参数为函数或者返回值为函数的函数，也就是函数要能够作为一等公民。在C++中，高阶函数可以以函数指针或函数对象（Function Object）实现，比如一个函数对象就是重载了<code>operator()</code>运算符的类的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Add</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C++11及以后引入了<strong>匿名函数</strong>（Lambda Function），其本质上与函数对象相同，不过进一步简化了函数定义的语法，让函数可以随处进行定义和传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Add = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>偏应用的函数</strong>（Partially Applied Functions）与<strong>柯里化</strong>（Currying）：对函数的部分参数提前进行绑定，得到需要剩下参数的函数。比如上面定义的<code>Add</code>函数，如果要改造为柯里化的形式，可以在C++中写作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> PartialAdd = [=](<span class="keyword">auto</span> a) &#123;</span><br><span class="line"><span class="keyword">return</span> [=](<span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> Add(a, b); &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，在应用时就可以提前绑定一个参数，在得到返回的函数后绑定剩下的一个参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = PartialAdd(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">auto</span> x = f(<span class="number">5</span>);<span class="comment">// x = 7; </span></span><br></pre></td></tr></table></figure></li><li><p><strong>闭包</strong>（Closure）：闭包是自动捕获了外部状态的函数，在C<ins>中体现为有成员变量的函数对象。不过在C</ins>11后的Lambda函数，我们可以很方便的捕获外部变量形成闭包。比如上面的<code>PartialAdd</code>函数就应用到了闭包，其外层函数捕获了<code>Add</code>函数，其内层函数捕获了传入<code>a</code>参数和<code>Add</code>函数。捕获的表示在两个方括号<code>[]</code>之间，<code>[=]</code>表示的是默认以值拷贝的方式捕获，与之对应的还有<code>[&amp;]</code>表示默认以引用的方式捕获。</p></li><li><p><strong>模式匹配</strong>（Pattern Match）：模式匹配也是函数式编程中的一大利器，在递归时作为分支选择必不可少的攻击。可惜C<ins>中对模式匹配的支持尚且不强，运行时的函数只能通过<code>if</code>语句手动进行匹配，不过，C</ins>对于编译时的模版元编程中还是支持了一定的模式匹配。</p></li><li><p><strong>惰性求值</strong>（Lazy evaluation）：惰性求值可以让表达式的计算推延到实际使用时再进行，可以避免不必要的计算。在C++中也有相应的方法实现惰性求值。</p></li></ol><p>从上面可以看出C<ins>11以后对函数式编程有着足够的支持，在一些方面不亚于函数式语言。我们可以从不同的几个实例来感受一下C</ins>中的函数式编程是什么样的。</p><h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2><h3 id="1-高阶函数-泛型-闭包"><a class="markdownIt-Anchor" href="#1-高阶函数-泛型-闭包"></a> 1. 高阶函数、泛型、闭包</h3><p>在C<ins>中有多种对象都都可以被认为是函数。运用鸭子类型（Duck Typing）的说法：任何“可以像函数一样调用的东西就是函数”。前面说到，C</ins>中主要有3种类型的函数：函数指针、函数对象（重载<code>operator()</code>的类对象）、匿名函数。要进一步地深入使用函数式，我们可以用数学化的方式表达类型。比如平时我们常见的函数声明方式一般是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrThenAdd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x * x + y; &#125;</span><br></pre></td></tr></table></figure><p>这个函数的类型我们可以表示为<code>(int * int) -&gt; int</code>，因为它可以看做是一个变化：将一个<code>int</code>二元组变换为一个<code>int</code>。在函数式语言中也可以很自然地得到如下定义与其类型：</p><figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">fun</span> sqrThenAdd (x : <span class="built_in">int</span>, y : <span class="built_in">int</span>) : <span class="built_in">int</span> = x * x + y;</span><br><span class="line"><span class="keyword">val</span> sqrThenAdd = <span class="keyword">fn</span> : <span class="built_in">int</span> * <span class="built_in">int</span> -&gt; <span class="built_in">int</span></span><br></pre></td></tr></table></figure><p>C++11后也可以写成这种更自然的表示法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto sqrThenAdd(int x, int y) -&gt; int &#123; return x * x + y; &#125;</span><br></pre></td></tr></table></figure><p>不过，一般在函数式语言中我们不会明确标注类型，取而代之的是使用<strong>泛型</strong>，并让编译器推导相关类型。这样既减少了对类型思考的负担，也增强了程序的适用范围。在C++中也可以实现这个目标，比如使用模版函数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arithmetic1, <span class="keyword">typename</span> Arithmetic2&gt;</span><br><span class="line">auto sqrThenAdd(Arithmetic1 x, Arithmetic2 y) -&gt; decltype(auto) &#123; return x * x + y; &#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>Arithmetic</code>代指一个泛型类型，返回值的<code>decltype(auto)</code>表示让编译器自动推导返回表达式的类型作为返回类型。当我们以<code>sqrThenAdd(1, 2)</code>调用时，编译器会将其推导为<code>(int * int) -&gt; int</code>；而当我们以<code>sqrThenAdd(1.0, 2.0)</code>调用时，编译器会推导为<code>(double * double) -&gt; double</code>，这里就体现了一个重要的特性——<strong>静态多态</strong>，极大地增强了函数的适用范围。不过，过大的范围也不是好事，比如这里的<code>Arithmetic</code>仅指代算术类型，即有<code>*</code>、<code>+</code>运算符的数据类型，对于其他类型这段程序是没有意义的。目前阶段的C<ins>要实现这个限制较为麻烦，而在C</ins>20后即将引入了Concept较好地解决了这个问题。</p><p>另一种更为符合函数式的函数定义语法是匿名函数。在C++14之后加入的Generic Lambda让匿名函数也很好地支持了泛型，比如下面这个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mapThenAdd = [](<span class="keyword">auto</span> f, <span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> f(x) + y; &#125;;</span><br></pre></td></tr></table></figure><p>其中除了<code>auto</code>标识符并没有任何类型声明，其类型会像模版一样自动推导。可以看到<code>f</code>在函数体内被调用，是一类函数参数。<code>mapThenAdd</code>自身就是一个高阶函数，其作用是对参数<code>x</code>应用<code>f</code>函数并加上<code>y</code>。按照函数式语言中的数据类型定义，<code>mapThenAdd</code>接受的是一个有3个元素的元组，如果我们想要柯里化的函数形式，需要对其的部分做绑定。在函数式编程中我们可能会写出以下的程序：</p><figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> mapThenAdd (f, x, y) = f(x) + y;</span><br><span class="line"><span class="keyword">fun</span> bind (f, arg) = <span class="keyword">fn</span> (x, y) =&gt; f(arg, x, y);</span><br><span class="line"><span class="keyword">val</span> sqrThenAdd = bind(mapThenAdd, <span class="keyword">fn</span> x =&gt; x * x);</span><br><span class="line"><span class="keyword">val</span> r = sqrThenAdd(<span class="number">2</span>, <span class="number">3</span>);<span class="comment">(* r = 7 *)</span></span><br></pre></td></tr></table></figure><p>上面这段程序将<code>mapThenAdd</code>函数的<code>f</code>参数提前进行绑定，<code>bind</code>函数就是完成这个工作的高阶函数，传入其中的<code>f</code>和<code>arg</code>都被<strong>闭包</strong>绑定了下来，在绑定了一个平方函数后就返回了完成<code>sqrThenAdd</code>功能的函数。通过这个方法，我们也可以很容易地对这个函数进行柯里化。在C++中实现相同功能也一样很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> bind = [](<span class="keyword">auto</span> f, <span class="keyword">auto</span> arg) &#123;<span class="keyword">return</span> [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;<span class="keyword">return</span> f(arg, x, y);&#125;;&#125;;</span><br><span class="line"><span class="keyword">auto</span> sqrThenAdd = bind(mapThenAdd, [](<span class="keyword">auto</span> x) &#123;<span class="keyword">return</span> x * x;&#125;);</span><br><span class="line"><span class="keyword">auto</span> r = sqrThenAdd(<span class="number">2</span>, <span class="number">3</span>);<span class="comment">// r = 7</span></span><br></pre></td></tr></table></figure><p>从上面的这些例子中，我们一窥了C++中的函数式编程，有了这些语言上的基础，我们才得以将其逐步应用在更加实用且复杂的场合。</p><h3 id="2-stl中的函数式编程"><a class="markdownIt-Anchor" href="#2-stl中的函数式编程"></a> 2. STL中的函数式编程</h3><p>STL（Standard Template Library）标准模版库是C<ins>的自带库，虽然C</ins>一直以来被认为是“面向对象语言”，也常常被用作“C with class”，但是STL的作者却很少地用到了面向对象的编程范式，而是大量用到了以模版为支撑的泛型编程与函数式编程的范式，在使用STL时就能明显的感到这一点。比如排序函数<code>std::sort</code>的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ns &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::sort(ns.<span class="built_in">begin</span>(), ns.<span class="built_in">end</span>(), [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;<span class="keyword">return</span> x &lt; y;&#125;);</span><br></pre></td></tr></table></figure><p>这里<code>std::sort</code>的第三个参数是用于比较大小的谓词，也就是一个匿名函数。常见的比较谓词在标准库中已经写好了，比如上面程序中的小于谓词可以写作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(ns.<span class="built_in">begin</span>(), ns.<span class="built_in">end</span>(), <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure><p>在函数式编程中被大量使用的“三件套”：Map、Filter、Fold在STL中也都有对应物。通过这3个函数的任意组合，我们可以创建处理变换数据的<strong>流水线</strong>（Pipeline），实现强大的功能。</p><p>让我们用一段小程序体会一下：假设现在我想实现一个统计代码行数的功能，输入是一个代码文本文件名组成的序列，输出是所有代码的总行数，但是要避免计入一些琐碎的小文件，也就是说对于行数少于10行的文件不计入总行数中。如果习惯了传统编程思维，很容易写出下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_lines_in_files</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;files)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  total_lines = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c           = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;f : files) &#123;</span><br><span class="line">        <span class="keyword">int</span>           lines = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::ifstream <span class="title">in</span><span class="params">(f)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (in.<span class="built_in">get</span>(c)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                lines++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lines &gt;= <span class="number">10</span>)</span><br><span class="line">            total_lines += lines;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_lines;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使是一段简单的逻辑也用到了二重循环和几个维护局部状态的变量。这样写出来的程序确实能用，但是我们很快可以发现它的缺点：容易不小心出现bug，比如局部变量忘记初始化、循环条件错误、状态设置错误等；此外程序显得啰嗦，修改起来也并不方便。</p><p>如果换成函数式的思想，需要将程序的“可变状态”减少，因为一旦状态一多，出错的可能性就大幅增加。稍加思索我们就可以发现这段程序所做的操作都在“三件套”描述的范围内：</p><ol><li>Map：将文本文件名转换为文件的行数，转换函数的类型为<code>std::string -&gt; int</code></li><li>Filter：筛选出不少于10的行数，谓词函数的类型为<code>int -&gt; bool</code></li><li>Fold：计算出满足条件的行数之和，折叠函数为求和运算</li></ol><p>通过使用STL中“三件套”的对应物，我们可以写出以下程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_lines_in_files</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;files)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lines</span><span class="params">(files.<span class="built_in">size</span>())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> count_lines = [](<span class="built_in">std</span>::<span class="built_in">string</span> file) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::ifstream in(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::count(<span class="built_in">std</span>::istreambuf_iterator&lt;<span class="keyword">char</span>&gt;(in),</span><br><span class="line">                          <span class="built_in">std</span>::istreambuf_iterator&lt;<span class="keyword">char</span>&gt;(),</span><br><span class="line">                          <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> pred = [](<span class="keyword">int</span> i) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> i &lt; <span class="number">10</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::transform(files.<span class="built_in">begin</span>(), files.<span class="built_in">end</span>(), lines.<span class="built_in">begin</span>(), count_lines); <span class="comment">// Map</span></span><br><span class="line">    <span class="keyword">auto</span> lines_end = <span class="built_in">std</span>::remove_if(lines.<span class="built_in">begin</span>(), lines.<span class="built_in">end</span>(), pred);<span class="comment">// Filter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::accumulate(lines.<span class="built_in">begin</span>(), lines_end, <span class="number">0</span>, <span class="built_in">std</span>::plus&lt;<span class="keyword">int</span>&gt;());<span class="comment">// Foldl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，高阶函数<code>std::transform</code>、<code>std::remove_if</code>、<code>std::accumulate</code>定义好了Map、Filter、Fold的操作，而我们只需要传入符合我们要求的函数，就可以描述出我们需要的功能，相比于命令式编程要清晰明了许多。另外，使用函数式的好处就是可以很轻易的复用已有的代码，比如在<code>count_lines</code>就用到了标准中的<code>std::count</code>函数来统计文件中的换行符的个数，其另外一个版本<code>std::count_if</code>就可以自己传入判断谓词，这样不管是什么我们外部的条件怎么变化，这个算法都可以适用。</p><p>在命令式的程序啰嗦且繁杂易出错的情况下，函数式程序仍然可以清晰地表述，并且更加符合人类的思维，这也是函数式的重大优点之一。此外还有一个函数式的闪光点：易于并行化。因为算法的高度复用性和引用透明性，函数式程序可以很轻易地变为并行程序，且不用当心各种竞争问题。实际上，函数式的并行算法只要在描述各种操作的高阶函数中完成一次就行，任何其他地方的调用都可以享受到并行的好处。比如只要将上面的代码加一个<code>std::execution::par</code>的标签就可以变为并行的版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::transform(<span class="built_in">std</span>::execution::par, files.<span class="built_in">begin</span>(), files.<span class="built_in">end</span>(), </span><br><span class="line">   lines.<span class="built_in">begin</span>(), count_lines);</span><br></pre></td></tr></table></figure><p>此外，函数式编程中还经常会用到一些常见的**“算术数据类型”**（Algebraic data type），它们在STL也有对应产物。比如在Sumed Type对应<code>std::variant</code>与<code>std::optional</code>、Product Type对应<code>std::pair</code>与<code>std::tuple</code>等。这些原本在函数式语言中普遍使用的类型的引入也让平时的命令式编程得到了改进。</p><h3 id="3-模版元编程与函数式编程"><a class="markdownIt-Anchor" href="#3-模版元编程与函数式编程"></a> 3. 模版元编程与函数式编程</h3><p>C++的另一大亮点就是对编译期编程的支持。编译期编程是一个庞大的话题，甚至可以写一本上千页厚的书。不过我们还是可以简单地了解一下编译期编程与模版元编程，因为它们其实与函数式编程非常接近。</p><p>模版元编程，顾名思义，是基于C<ins>的模版而来的编程方式。C</ins>的模版被创造的初衷是对泛型编程的支持，也就是创造出于类型无关的算法。不过人们很快发现它能做的事远远不止如此。由于模版中有着对<strong>模式匹配</strong>（Pattern Matching）的支持，它完全可以看做是一类纯函数式编程语言。举个经典的例子——计算斐波那契数列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> i&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fib</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = Fib&lt;i<span class="number">-1</span>&gt;::value + Fib&lt;i<span class="number">-2</span>&gt;::value; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fib</span>&lt;1&gt; &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = <span class="number">1</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fib</span>&lt;0&gt; &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = Fib&lt;<span class="number">20</span>&gt;::value;<span class="comment">// x = 6765</span></span><br></pre></td></tr></table></figure><p>这个程序和函数式的程序如出一辙：</p><figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> <span class="type">Fib</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line">  | <span class="type">Fib</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">  | <span class="type">Fib</span> i = <span class="type">Fib</span>(i-<span class="number">1</span>) + <span class="type">Fib</span>(i-<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>模版编程所做的事情很简单，C<ins>编译器对于每次出现的模版类型，会将其模版参数代入，<strong>实例化</strong>出特定参数的类型，如果这个类型本身内部引用别的模版类型，实例化的过程就会递归进行…是不是很像函数式编程中的递归过程？这里模版参数就对应着函数参数，类型名对应着函数名，类型内部定义对应着函数体。此外C</ins>在对类型实例化时还会应用模式匹配，也就是说，匹配“最合适”的类型。在上面的例子中，<code>Fib&lt;1&gt;</code>和<code>Fib&lt;0&gt;</code>被称作是<strong>偏特化</strong>的类型，就如同在函数式语言中匹配的特例一样，当实例化到它们的时候，编译器会选择最具体、最合适的偏特化类型，从而形成递归的终止条件。</p><p>让我们试试用元编程实现经典的找零问题：给定整数n、一批硬币L，是否能找出总值为n的硬币子集。实现的大致思路是，每次取出列表中的第一枚硬币，如果该硬币的数额比当前总值小，则有两种选择：一是使用该硬币，二是不使用该硬币；如过该硬币的数额比当前总值大，那么一定不能使用该硬币。该算法在C++中可以用如下的模版元编程实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> Select, <span class="keyword">int</span> N, <span class="keyword">int</span> X, <span class="keyword">int</span>...Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change_Impl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span>... Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> solution_count = Change_Impl&lt;<span class="number">2</span>, N, Ls...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span> X, <span class="keyword">int</span>...Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change_Impl</span>&lt;2, N, X, Ls...&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = Change_Impl&lt;<span class="keyword">int</span>(X &lt;= N), N, X, Ls...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span> X, <span class="keyword">int</span>...Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change_Impl</span>&lt;1, N, X, Ls...&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = Change&lt;N - X, Ls...&gt;::solution_count </span><br><span class="line">           + Change&lt;N, Ls...&gt;::solution_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span> X, <span class="keyword">int</span>...Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change_Impl</span>&lt;0, N, X, Ls...&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = Change&lt;N, Ls...&gt;::solution_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span>&lt;0&gt; &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> solution_count = <span class="number">1</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span>&lt;N&gt; &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> solution_count = <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Change&lt;<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&gt;::solution_count;<span class="comment">// 3种(1+3+6,6+4,1+4+5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来十分复杂，但是仔细看的话，这个程序只是在简单地使用模式匹配。传入<code>Change</code>的第一个模版参数为目标总额，其余的模版参数为硬币数额列表，以一个变长模版参数包表示<code>int... Ls</code>。底下两行匹配的是硬币列表为空时的情况，当此时的目标金额为0时则有一种解决方法；否则没有解决方案。为了方便模式匹配，还定义了<code>Change_Impl</code>结构体，它仅接收非空列表，并会对目标金额与首枚硬币的金额进行判断，依次作为匹配依据。<code>Change</code>最后会得到找零方案的个数，比如硬币列表为<code>[1, 3, 6, 4, 5]</code>，目标金额为<code>10</code>时得到的找零方案有3种。</p><p>可以看出，模式匹配让我们可以很方便的实现判断逻辑，配合递归可以实现复杂的逻辑。借助函数式编程的思想，模版元编程也可以有很强的表达能力。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>本文简单的概述了一些函数式思想在C<ins>中的应用，这种简洁高效的编程范式让C</ins>这门被广泛运用的语言有了更强的表达能力。我们也看到了，函数式编程让我们的思维从“告诉计算机每一步的步骤”转变为“告诉计算机问题是什么”，从而得到更接近数学的抽象能力，也让程序免于Bug的灾难。不过，函数式编程也不是万能的，有许多问题不能用“纯函数式”的思想实现。而C++这门多范式语言让我们有了更加丰富的选择：不管是命令式、面向对象、函数式，还是泛型编程，都可以作为工具，只要我们将它们用在合适的地方。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本模型——球的N种画法</title>
      <link href="/code/Sphere/"/>
      <url>/code/Sphere/</url>
      
        <content type="html"><![CDATA[<p>最近在做个小渲染Demo，展示效果需要一些基本图元。基本图元的三角网格均可以程序化生成，这篇文章主要收集了这些生成方法。</p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>图形学中，模型表示的方法很多，它们大致可以分为两类：<strong>显式表示（Explicit）<strong>与</strong>隐式表示（Implicit）</strong>。</p><p>显式表示的常见方法有：点/线/多边形表示和曲线/曲面表示等。而隐式表示，就可以直接给出几何体表面的定义方程，却不用管其如何求解：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(x,y,z)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>比如对于三维球体，我们知道它的隐式表示为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo>−</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">F(x,y,z)=x^2+y^2+z^2-r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0585479999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span></span></p><p>实时渲染中我们主要使用的是多边形表示，就需要将几何体的隐式表示转换为显式表示。常用的方法是将隐式表示的方程先转化为<strong>参数方程</strong>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">f(s,t)=(x(s,t),y(s,t),z(s,t))^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><p>参数方程本身作为一种显式表示，其给出了几何体表面的点坐标，再将这些点坐标连接起来形成为多边形网格（一般是三角形）后，就得到了几何体最终的显式表示。</p><p>本文主要介绍几种球体的转换方法。</p><a id="more"></a><h2 id="球坐标转换"><a class="markdownIt-Anchor" href="#球坐标转换"></a> 球坐标转换</h2><p>对于球面来说，最常见的参数化方式是采用球坐标公式。</p><img src="/images/gl_sphere01.png" alt="球坐标系，图来自[2]" style="zoom: 50%;" /><p>图中球坐标系有三个参数：半径<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>， 方位角<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>和倾斜角<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>。如果将球体看做是地球的话，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>角就是经度，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>角就是维度。为了方便起见，我们在本文中采用的球坐标系与上图有一些不同（因为实在找不到图了= =）：我们将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>角定义为与z轴的夹角（注意这里z朝上）而不是与xy平面的夹角，这时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>角表示的是余纬（colatitude），也就是$90^{\circ} - $ 纬度。这样定义的好处是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>角的取值不会涉及到负数，方便我们进一步处理。</p><p>上述定义下的球坐标公式为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>s</mi><mi>i</mi><mi>n</mi><mi>ϕ</mi><mo>⋅</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>s</mi><mi>i</mi><mi>n</mi><mi>ϕ</mi><mo>⋅</mo><mi>s</mi><mi>i</mi><mi>n</mi><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>z</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>ϕ</mi></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{aligned}x &amp;= r \cdot sin\phi \cdot cos\theta \\y &amp;= r \cdot sin\phi \cdot sin\theta \\z &amp;= r \cdot cos\phi\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">ϕ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">ϕ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">ϕ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中两个角的在弧度制下取值范围是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mi>π</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\theta \in [0,2\pi]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>π</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\phi \in [0,\pi]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mclose">]</span></span></span></span>。</p><p>接下来的问题是如何给<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>取值。我们首先想到的自然是均匀取值，也就是用以下的公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>θ</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>2</mn><mi>π</mi><mo>⋅</mo><mfrac><mi>i</mi><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>ϕ</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>π</mi><mo>⋅</mo><mfrac><mi>j</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>s</mi></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\theta &amp;= 2\pi \cdot \frac{i}{sectors} \\\phi &amp;= \pi \cdot \frac{j}{stacks}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.645040000000001em;vertical-align:-2.0725200000000004em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5725200000000004em;"><span style="top:-4.57252em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0725200000000004em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5725200000000004em;"><span style="top:-4.57252em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0725200000000004em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>此处我们把横向（经度）上的划分称为sectors，纵向（维度）上的划分称为stacks。通过控制不同的横向与纵向的分段数，我们就可以控制球体的精度。由于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>角的范围是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>角的两倍，为了让生成的球在横向与纵向上有相同密度的点，一般设定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi><mo>=</mo><mn>2</mn><mo>×</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">sectors = 2 \times stacks</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span></span></span></span>，这样控制精度的参数就仅需一个。</p><p>球坐标本身经过三角函数的变换，角度上的均匀分布在球面上并不均匀。从下图我们可以看出在南北极的点分布要比赤道上的密一些（如果看成是地球的话）。</p><img src="/images/gl_sphere02.png" alt="球坐标下分区是不均匀的，图来自[2]" style="zoom: 67%;" /><p>点的分布不均导致了每个小区的面积并不相等，不过与生成球面上的随机点不同，这并不妨碍渲染的结果，因为从模型本身的轮廓来说，正视图与俯视图看到的圆都分别有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">2 \times stacks</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span></span></span></span>条边和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">sectors</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span></span></span></span>条边，而我们已经设定了它们相等。</p><p>有了顶点坐标的计算公式后，下一步就是将顶点连接形成多边形网格。一般我们采用的是三角形网格（Triangle Mesh），需要把上图的四边形切分为2个三角形。由于渲染API一般要利用“背面剔除”特性加速渲染，我们需要保证三角面的顶点顺序一致。如果正面的顶点顺序为逆时针，则一个四边形的两个三角形的顶点就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mi>k</mi><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mn>2</mn><mo separator="true">,</mo><mi>k</mi><mn>1</mn><mo>+</mo><mn>1</mn><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>k</mi><mn>1</mn><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mn>2</mn><mo separator="true">,</mo><mi>k</mi><mn>2</mn><mo>+</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{k1,k2,k1+1\},\{k1+1,k2,k2+1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>。储存顶点时，一般可以共享相邻三角形的顶点，以减少储存空间的开销；不过，如果共享顶点的法线、贴图坐标不同的话，就不能采用共享顶点了。</p><img src="/images/gl_sphere03.png" alt="三角网格，图来自[2]" style="zoom: 67%;" /><p>基础模型的一个好处就是具有良好定义的贴图映射、法线信息。对于球来说，其每个顶点的法线就是单位化后的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>坐标，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">/</mi><mi>r</mi><mo separator="true">,</mo><mi>y</mi><mi mathvariant="normal">/</mi><mi>r</mi><mo separator="true">,</mo><mi>z</mi><mi mathvariant="normal">/</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x/r,y/r,z/r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>。对于球的贴图映射有多种方案，在本方案中可以直接用归一化的方位角和倾斜角来获取，即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>u</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mi>θ</mi><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><mo>=</mo><mfrac><mi>i</mi><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>v</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mi>ϕ</mi><mi>π</mi></mfrac><mo>=</mo><mfrac><mi>j</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>s</mi></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{aligned}u &amp;= \frac{\theta}{2\pi} = \frac{i}{sectors} \\v &amp;= \frac{\phi}{\pi} = \frac{j}{stacks} \\\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80004em;vertical-align:-2.15002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65002em;"><span style="top:-1.8999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.8999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1999899999999997em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.90002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.60744em;"><span style="top:-4.6074399999999995em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mord mathdefault">u</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.10744em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.60744em;"><span style="top:-4.6074399999999995em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.10744em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>由于球坐标的方案与球体UV坐标有很强的关系，这种生成的球体有时也被称作UV球体（UV Sphere）。</p><p>以上，球坐标方案的生成代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> r = <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> stacks = <span class="number">10</span>, sectors = <span class="number">2</span> * stacks;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; verts, norms, texCoords;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= stacks; j++) &#123;</span><br><span class="line">    <span class="keyword">float</span> v   = (<span class="keyword">float</span>)j / stacks;</span><br><span class="line">    <span class="keyword">float</span> phi = PI * v;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sectors; i++) &#123;</span><br><span class="line">        <span class="keyword">float</span> u     = (<span class="keyword">float</span>)i / sectors;</span><br><span class="line">        <span class="keyword">float</span> theta = <span class="number">2</span> * PI * u;</span><br><span class="line">        </span><br><span class="line">        verts.push_back(r * <span class="built_in">sin</span>(phi) * <span class="built_in">cos</span>(theta));</span><br><span class="line">        verts.push_back(r * <span class="built_in">cos</span>(phi));</span><br><span class="line">        verts.push_back(r * <span class="built_in">cos</span>(phi) * <span class="built_in">sin</span>(theta));</span><br><span class="line">        norms.push_back(<span class="built_in">sin</span>(phi) * <span class="built_in">cos</span>(theta));</span><br><span class="line">        norms.push_back(<span class="built_in">cos</span>(phi));</span><br><span class="line">        norms.push_back(<span class="built_in">cos</span>(phi) * <span class="built_in">sin</span>(theta));</span><br><span class="line">        texCoords.push_back(u); texCoords.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; stacks; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> k1 = j * (sectors + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> k2 = k1 + sectors + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sectors; i++, k1++, k2++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">            indices.push_back(k1);</span><br><span class="line">            indices.push_back(k1 + <span class="number">1</span>);</span><br><span class="line">            indices.push_back(k2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j != stacks - <span class="number">1</span>) &#123;</span><br><span class="line">            indices.push_back(k2);</span><br><span class="line">            indices.push_back(k1 + <span class="number">1</span>);</span><br><span class="line">            indices.push_back(k2 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码需要注意的是，在顶部与底部的小区块，由于有一个顶点重合，只用绘制一个三角形即可。</p><h2 id="细分多面体"><a class="markdownIt-Anchor" href="#细分多面体"></a> 细分多面体</h2><p>细分多面体也是一种常见的创建球体Mesh的方法。其相对UV球体，点的分布更加均匀（UV球体的很多顶点浪费在了靠近南北极的地方），因此用较少的顶点就可以实现不错的精度。</p><p>细分的方法也比较简单，对于每个三角形来说，每经过一步，就分裂为4个新的三角形，递归地进行这个过程，就可以得到面数更多更精细的模型。</p><p><img src="/images/icosphere-tessellation.png" alt="" /></p><p>当然，需要将这些多出来的顶点移到球壳上，不然怎么细分都还是球面。。因为我们已经假定了球心的位置在坐标原点，而球壳上的点到球心的距离为一常数，我们只需要让点沿着过原点的线移动并设定其到原点长度为半径即可。形象的说，这个过程类似把把多边形表面“膨胀”出去的过程，如下图所示：</p><p><img src="/images/icosphere-bulge.gif" alt="" /></p><p>有个这个过程，我们就可以把任意多面体细分为球体了。</p><p>下面以正二十面体为例，详细说一下这个过程。</p><h3 id="细分正二十面体icosphere"><a class="markdownIt-Anchor" href="#细分正二十面体icosphere"></a> 细分正二十面体（Icosphere）</h3><p>正二十面体本身顶点比较均匀，适合作为基础几何体，这样细分为球体后分布依然会比较均匀。正二十面体有12个顶点，将两个顶点放在顶部<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>与底部<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0,-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，剩下的10个顶点分别在高度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>±</mo><mi>t</mi><mi>a</mi><mi>n</mi><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\pm tan\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord">±</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的平面上，且每个平面上的点正好是正五边形。</p><table><thead><tr><th>侧视图</th><th>俯视图</th></tr></thead><tbody><tr><td><img src="/images/gl_sphere09.png" style="zoom: 50%;" /></td><td><img src="/images/gl_sphere10.png" style="zoom:50%;" /></td></tr></tbody></table><p>用球坐标可以简单地算出这些点来：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><msup><mi>n</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⋅</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mn>72</mn><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><msup><mi>n</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⋅</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>72</mn><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>z</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><msup><mi>n</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}x &amp;= r \cdot cos(tan^{-1}(\frac 1 2)) \cdot cos(72 \cdot n) \\y &amp;= r \cdot cos(tan^{-1}(\frac 1 2)) \cdot sin(72 \cdot n) \\z &amp;= r \cdot sin(tan^{-1}(\frac 1 2))\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.922320000000001em;vertical-align:-3.2111600000000005em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.71116em;"><span style="top:-5.71116em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.40372em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.0962799999999997em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.2111600000000005em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.71116em;"><span style="top:-5.71116em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord">2</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord">7</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.40372em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord">2</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">7</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-1.0962799999999997em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord">2</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.2111600000000005em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>有了基础的正多面体，细分的过程就很容易了，分别区三角形三条边上的中点，并将中点投影到球壳上即可。可以用以下的伪代码来表述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Subdivide(triangles, radius)</span><br><span class="line">newTriangles &#x3D; &#123;&#125;</span><br><span class="line">    for (each triangle &#123;A,B,C&#125; in triangles)</span><br><span class="line">        D &#x3D; Normalize(A + B) * radius</span><br><span class="line">        E &#x3D; Normalize(A + C) * radius</span><br><span class="line">        F &#x3D; Normalize(B + C) * radius</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Compute 3 new vertices by spliting half on each edge</span><br><span class="line">        &#x2F;&#x2F;         A</span><br><span class="line">        &#x2F;&#x2F;        &#x2F; \</span><br><span class="line">        &#x2F;&#x2F;       D---E</span><br><span class="line">        &#x2F;&#x2F;      &#x2F; \ &#x2F; \</span><br><span class="line">        &#x2F;&#x2F;     B---F---C</span><br><span class="line">        newTriangles +&#x3D; &#123;A, D, E&#125;</span><br><span class="line">        newTriangles +&#x3D; &#123;D, B, D&#125;</span><br><span class="line">        newTriangles +&#x3D; &#123;D, F, E&#125;</span><br><span class="line">        newTriangles +&#x3D; &#123;E, F, C&#125;</span><br><span class="line">        </span><br><span class="line">    return newTriangles</span><br></pre></td></tr></table></figure><p>细分的效果大致如下所示，可以看到点的分布相比之前的UV球体要均匀了许多。</p><table><thead><tr><th>2次细分</th><th>4次细分</th></tr></thead><tbody><tr><td>512个顶点，320个三角形</td><td>7820个顶点，5120个三角形</td></tr><tr><td><img src="/images/icosphere-2.png" alt="" /></td><td><img src="/images/icosphere-4.png" alt="" /></td></tr></tbody></table><p>然而，这样细分出来的球体也不是十全十美的，它有一个致命的问题——就是贴图UV。由于细分的球体本身并不能直接得到贴图坐标，我们需要借助之前球坐标系的方法，应用其逆过程，将顶点坐标转换为球坐标再以两个角度作为UV。公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>u</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>0.5</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><mi>a</mi><mi>r</mi><mi>c</mi><mi>t</mi><mi>a</mi><mi>n</mi><mn>2</mn><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>v</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>0.5</mn><mo>−</mo><mfrac><mn>1</mn><mi>π</mi></mfrac><mi>a</mi><mi>r</mi><mi>c</mi><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{aligned}u &amp;= 0.5 + \frac{1}{2\pi} arctan2(x, y) \\v &amp;= 0.5 - \frac{1}{\pi} arcsin(z) \\\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.61488em;vertical-align:-2.05744em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.55744em;"><span style="top:-4.55744em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord mathdefault">u</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.05744em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.55744em;"><span style="top:-4.55744em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.05744em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>然而，当我们将贴图应用在球体上后，却会发现如下的效果：</p><p><img src="/images/icosphere-warping.png" alt="" /></p><p>可以看到有一条明显Z型扭曲带，带上的三角形纹理好像被压缩了一样。很容易发现问题的原因：当贴图UV的值超过1.0时，由于转过了一圈，根据上面的式子算出的UV会回到0。这样就导致了在靠近这个UV边界的三角形内，UV的值一下子从接近1的地方跳跃到了接近0的地方，导致了贴图被压缩的现象。</p><img src="/images/sphere_zipper_explained.jpg" style="zoom:67%;" /><p>正如上图所示，本该是蓝色的三角形被映射到了黄色的三角形，导致了贴图的严重拉伸。要修复这个问题，只需把错误的三角形纠正过来就行。注意到这些错误的三角形，其顶点环绕顺序与正确三角形是相反的。原本的蓝色三角形是瞬时针环绕，被错误映射后变为了逆时针环绕。通过这个特征我们就可以发现错误的三角形了：只需要判断一下三角形的环绕顺序，即三角形两边的叉积的z坐标符号即可（虽然UV只是二维的点，但我们可以将其看做是z坐标为0的三维点，这样就可以进行叉乘运算了）。要为每个修正坐标的顶点生成一个新的顶点以解决共享顶点的问题。</p><p>这样处理完后，之前的Z字接缝就没有了。不过，在靠近两极的地方，UV仍有明显的扭曲。</p><img src="/images/icosphere-top.png" style="zoom: 67%;" /><p>问题显然还是因为共享顶点导致的UV坐标拉伸的缘故，从下图中可以明显看出来中间的三角形被严重拉伸。</p><p><img src="/images/pole_triangles_mapped.jpg" alt="" /></p><p>显然，两极的顶点对于每个三角形均需要不同的贴图坐标。然而问题是，该怎样得到UV呢？肯定不能用之前的式子算了，因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>c</mi><mi>t</mi><mi>a</mi><mi>n</mi><mn>2</mn><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">arctan2(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>本身在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x=y=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>处的值是没有良定义的。遗憾的是，这个问题没有一个完美的解决方案，因为在球顶的这块位置顶点重合，一整条边都对应到了一个点上，显然我们没法让其在贴图完美地对应到一个矩形区域里去。一种不太完美的解决方案是，将每个三角形贴图坐标的U取为下面两个顶点U的平均值。这样虽然球顶的顶点没有统一对应到一个UV上，但总的拉伸降到了最低。修改后的效果如下。</p><img src="/images/icosphere-topfix.png" style="zoom:67%;" /><p>可以看到扭曲没有了，两个相连三角形的贴图有比较明显的接缝。这个接缝如果要解决的话，只能对贴图本身做处理了：将UV展开后让贴图上几何位置相邻的地方变化连续。事实上，将一个平面（贴图）包裹在一个球体上本身而没有扭曲的办法是不存在的，如果你对比过世界地图和实际的地球仪就会发现，靠近南北极的国家在地图上的大小要比实际的大小差很多。实际上，之前在UV球体上用的方法叫做Cylindrical Projection，其本质上是先把贴图卷成了一个圆柱体，然后再将其贴到球体上去，这就导致了约是靠近南北极的位置，贴图的扭曲就越大。</p><h3 id="细分立方体cubesphere"><a class="markdownIt-Anchor" href="#细分立方体cubesphere"></a> 细分立方体（CubeSphere）</h3><p>当然，细分还可以用其他的基础几何体来进行，这里再介绍一种使用立方体来进行细分的方式，这也是Unity中采用的球体。立方体的基础图元在这里是四边形，四边形的细分与三角形有细微不同但总体上类似：在四边形的四条边上取中点，还要在四边形的中间取一个点，再将中心的点与4个中点连起来，这样一个四边形就分割为4个小四边形。在有了细分后的立方体后，我们再按照上面讲过的方法，将点“投影”到球体上就可以了。当然，我们也可以直接一步到位地得到细分后的立方体，之后进行投影，效果是一样的。</p><table><thead><tr><th>无细分</th><th>1次细分</th><th>2次细分</th><th>3次细分</th></tr></thead><tbody><tr><td><img src="/images/gl_sphere13a.png" alt="" /></td><td><img src="/images/gl_sphere13b.png" alt="" /></td><td><img src="/images/gl_sphere13c.png" alt="" /></td><td><img src="/images/gl_sphere13d.png" alt="" /></td></tr></tbody></table><p>如果按照之前的Cylindrical Projection的方式投影贴图，仍然需要像之前一样处理顶部与底部的错误UV。不过，细分立方球体还有更直接的贴图方式：由于其是由一个立方体变换来的，可以借用立方体的UV来进行处理。也就是说像Cubemap这样的贴图可以很方便地拿来使用。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li><a href="https://en.wikipedia.org/wiki/Implicit_surface">Wikipedia - Implicit surface</a></li><li><a href="http://www.songho.ca/opengl/gl_sphere.html">OpenGL Sphere</a></li><li><a href="https://stackoverflow.com/questions/7687148/drawing-sphere-in-opengl-without-using-glusphere">Drawing Sphere in OpenGL without using gluSphere()?</a></li><li><a href="https://www.alexisgiard.com/icosahedron-sphere/">Generating and UV mapping an icosahedron sphere</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码阅读笔记</title>
      <link href="/code/Proj-Reading-Notes/"/>
      <url>/code/Proj-Reading-Notes/</url>
      
        <content type="html"><![CDATA[<p>记录一些遇到过的大大小小的C<ins>坑，或者是C</ins>比较优秀的惯用技巧、设计模式~</p><p>我将平时阅读的一些项目代码的笔记总结于此。</p><p>俗话说，读代码比写代码要难数倍，尤其是读别人的代码。的确如此，不过，不管从什么角度统计，我们花在读代码上的时间都远多于写代码的时间，而如何将代码写的清晰易懂、便于维护，又是一个不简单的问题。在代码的“品味”上，怎样做出优雅的设计，是一件需要积累的工作，没有十足的经验恐怕是难以达成。虽说经验可以通过自己写代码来增加，但我一直认为，阅读好其他人的代码，品味其中的设计思路，吸收其中的设计优点，才会如虎添翼，迅速增加自己的“代码感”。</p><p>此外，阅读代码本身也是一门学问。如何高效地阅读数量众多，成千上万行起步的代码，并将其中的设计架构提取出来，也不是一件容易的事。</p><a id="more"></a><h3 id="glm"><a class="markdownIt-Anchor" href="#glm"></a> GLM</h3><p>GLM是一个Header-only的3D数学库，实现了C++上的GLSL类型与函数，里面的类型定义大量用到了模版。下面描述一下项目从上（用户接口）到下（底层实现）的结构。</p><ol><li><p>上层的用户可见API均放在了<code>GLM/</code>根目录下，头文件以<code>*.hpp</code>作为扩展名。用户可见的头文件可分为3种：</p><ul><li>一种是综合性导入的头文件，里面仅有其他头文件的导入，这种文件主要是为了方便用户导入相关API。比如GLM将项目分为了4个模块（核心功能、稳定扩展、推荐扩展、实验性扩展），对应的就有两个综合性导入头文件：一个用于导入核心API的<code>glm.hpp</code>，一个用于导入其余的扩展API的<code>ext.hpp</code>，方便用户导入。</li><li>另一些比较具体的类型导入头文件，这种头文件主要是解决同种类型的头文件较多的情况，比如<code>vec3.hpp</code>里面就导入了各种类型的vector3头文件，这些头文件里面主要定义了类型模版的别名，这样使用时就可以不需要填写很长的模版参数了（同时也定义了与GLSL规范相同的类型名称）。</li><li>还有一种是包含了声明的头文件（主要是函数声明），这些函数均为模版函数（由于参数类型本身带模版）。声明的头文件中并没有实现，在声明头文件的底部引入了<code>detail/</code>里面实际的实现。</li></ul><p>以上所有的用户可见API均在命名空间<code>glm</code>下。</p></li><li><p>核心功能的实现在<code>detail/</code>文件夹下。这个文件下的文件扩展名主要就2种：<code>*.hpp</code>为声明，<code>*.inl</code>为具体实现。一个例外是<code>glm.cpp</code>，该文件中显示实例化了各个类的模版，主要是为了能使该库以静态库或动态库的方式使用。以<code>_*.hpp</code>开头的这些文件是库内部使用一次或多次的头文件，主要实现了一些通用的功能或宏相关的检测处理等：</p><ul><li><code>_features.hpp</code>里主要放了有很多编译器功能检测宏，如果发现了编译器支持某些额外特性，就定义一个<code>GLM_CXX??_???</code>的宏，表示可以使用该特性。（不过我没有看到有哪个文件使用了这个文件？）</li><li><code>_fixes.hpp</code>里清除了某些编译环境可能预先定义的宏，防止其产生干扰，如<code>max</code>、<code>min</code>等。</li><li><code>_swizzle.hpp</code>、<code>_swizzle_func.hpp</code>定义了与swizzle相关的类与宏。</li><li><code>_vertorize.hpp</code>实现向量化，就是将同一个函数作用到一个向量上，可以是一元函数或二元函数。</li></ul><p>上面的前两个文件就是为了增加可移植性。</p><p>接下来一个比较重要的文件是<code>setup.hpp</code>，基本上每个文件都会直接或间接地引用到该文件。这个文件中定义了GLM的项目信息宏（版本号、名称字符串），会根据CMake中定义的一些编译选项宏进一步地定义一些宏/类型等，如是否开启编译信息输出、是否开启static_assert、是否使用constexpr、是否使用forceinline等等。此外，该文件内还含有编译器支持的C<ins>特性的检测，如果编译时支持某较新C</ins>的特性，就会定义一个<code>GLM_HAS_???</code>，后序就可以以此使用不同的代码，以增强可移植性。这些根据编译选项定义下来的宏要么在后序作为条件编译用在了<code>#ifdef</code>这样的地方，要么作为关键字展开以实现不同的效果（如<code>GLM_INLINE</code>可以展开为普通的<code>inline</code>或<code>__forceinline</code>或<code>__attribute__((__always_inline__))</code>），也可以根据平台定义统一的类型（如表示长度的<code>length_t</code>是<code>size_t</code>还是<code>int</code>）。</p></li><li><p>之前说了函数的声明在根目录下，而函数的定义在<code>detail/</code>文件夹下，且均以<code>func_*.inl</code>作为文件名。在每个<code>*.inl</code>文件中，可以之前的用户可见函数声明相对应的函数实现。这些实现如果涉及到的只是简单的模版参数，那么在此就直接实现了相关代码；如果涉及到较复杂的实现（例如实现与向量长度有关），那么这段实现中并不会做实际工作，只是首先进行模版参数检测static_assert，然后转发到一个struct的特定静态方法<code>call</code>去。相应的struct定义在命名空间<code>glm::detail</code>中，用户一般不可见。通过对向量长度的偏特化，就可以针对不同长度的向量实现特定的方法，而不支持的长度最终会落到一个空的struct中，导致编译错误。struct中的特定实现可能会用到API本身，这个时候就会从上级根目录中导入其头文件。有一些用到了STL库中已有的函数（比如<code>max</code>），其就在实现中直接通过<code>using std::max</code>进行导入。对于STL函数作用在向量的每个元素上时，用的就是之前说的<code>_vertorize.hpp</code>中的向量化，向量化本身的实现与向量长度有关，也是放在偏特化的struct中。</p></li><li><p>向量/矩阵相关的类声明在<code>detail/type_*.hpp</code>中，类定义在<code>detail/type_*.inl</code>中，类定义也有与函数定义类似的转发机制（主要为了处理SIMD相关），转发的目标均在<code>glm::detail</code>命名空间下，用户不可见。</p></li><li><p>SIMD的转发方式：由于SIMD要求对象是对齐的，如果检测到是对齐的类型，就可以采用SIMD。因此GLM在之前转发到静态方法<code>call</code>时还额外多提供了一个模版参数，表示是否对齐，如果为<code>true</code>就会转发到SIMD的实现。这个是否对齐的判断是用type traits实现的，利用<code>glm::detail::is_aligned</code>完成。在<code>qualifier.hpp</code>中定义了描述精度、对齐的qualifier，根据这些qualifier表示的含义就可以写出对应的判断对齐的type traits。为了实现对齐的要求，这里也定义了一个叫<code>storage</code>的struct，这个struct中会根据align的要求定义不同大小的结构体，之后在具体的类中，将这些结构体与数据成员定义在一个union中即可实现对齐。此外对齐了的<code>storage</code>结构体中可能直接利用SIMD类型进行表示，这样长度就肯定符号SIMD的要求。SIMD的实现函数部分在<code>detail/func_???_simd.inl</code>文件中，类部分就在<code>detail/type_???_simd.inl</code>中，如果检测到支持SIMD且开启的编译选项，SIMD实现文件就会被加入到普通实现文件的底部。这些实现里面可能会用到一些共用的作用于SIMD类型的函数，其定义在<code>simd/*.h</code>中。这里面的函数同时也面向想要使用SIMD编写算法的高级用户。<code>simd/platform.h</code>文件中进行了编译器与平台检测，得知是否开启SSE/AVX/NEON等，再以此导入对应的intrinsic头文件，并对原生的SIMD类型做了typedef，保证不同平台的SIMD类型一致。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++知识点笔记与踩坑记录</title>
      <link href="/code/Cpp-Notes/"/>
      <url>/code/Cpp-Notes/</url>
      
        <content type="html"><![CDATA[<p>记录一些遇到过的大大小小的C<ins>坑，或者是C</ins>比较优秀的惯用技巧、设计模式。这些知识点十分分散却很有用，但他们单独拿出来难以构成一篇完整的文章，这里我以杂记的方式将它们记录下来，以便后续翻阅。</p><a id="more"></a><h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>C++很久以来被称作是“博大精深”的一门语言，不仅是因为其语言特性较为复杂且多到令人叹为观止的地步；也是因为细节很多，稍不留神就有可能踏入隐藏的深坑。</p><p>说到语言特性复杂，C<ins>确实有很多不同方面的语言特性，在cppreference上一眼望去都会眼花缭乱。众所周知，C</ins>被称作一门“多范式”的语言，相比于其他一些“纯粹”的编程语言，它不纯粹，因为它的设计者们认为没有一种设计思想适用于所有的情况：C<ins>不仅支持从C直接继承而来的命令式编程，也支持层次性的面向对象编程、泛型编程、函数式编程、编译期编程等编程范式。这种“不纯粹”的设计观念被一些人反感，但也正是这种多样性，使得C</ins>得以很好的应用在各个行业领域。</p><p>除此之外，C++还有许多很好的设计理念与思想：</p><ul><li>“Zero-overhead Principle”：对于不使用的部分，不需要为其付出代价；对于使用到的抽象，自己手写的代码不会更好。</li><li>既能向上增加抽象层次，丰富语义减轻思维负担；也能向下足够接近硬件，充分利用硬件资源。</li><li>用户可扩充的静态类型系统：最大发挥编译器的作用，在编译期解决绝大多数的错误。</li><li>对值类型与引用类型的同等支持。</li><li>系统性的资源管理思想与机制：RAII。</li><li>库与语言一样重要：对于用户来说，语言设计与库设计没有区别，是紧密结合的。</li><li>…</li></ul><p>C<ins>已经历经的多个版本，并在C</ins>11之后以3年为周期持续演进新的版本；每次演进都旨在解决之前出现的痛点，或是引入新的特性或组件。当然，这样也使得C<ins>的学习成本在不断增加（如果真的要了解所有细节的话）。不过C</ins>的设计初衷并不是让我们用上所有的语言特性，而是选择最适合自己项目的语言特性，毕竟没有什么单一的思想是万能。</p><p>对我而言，C<ins>最大想吸引力就是“能上能下”，足够的抽象能力让简单的事情与复杂的事情都能较好地表达；而需要极致性能的时候又可以深入到机器底层开展细致的优化。当然坑的问题仍然存在，它不想其他一些对程序编写有严格要求的语言（如Rust），旨在给以最大的自由，这时就需要我们自己保持良好的程序风格与规范。不过好在既有C</ins>11以来的“现代C++”给我们带来越来越多的安全的抽象能力，也有如<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">CppCoreGuideline</a>这样的从经验中总结的编程规范，让我们离这个目标越来越近。</p><h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2><ol><li><p>对于<code>std::make_shared()</code>，要求相应对象的构造函数必须为public的。然而，即使调用<code>std::make_shared()</code>的一方有对于非public构造函数的访问权限（类内部的static public的<code>create()</code>构造方法、友元类里的构造），<code>std::make_shared()</code>此时还是不能work，因为其访问权限永远被认为是外部的。</p><p><strong>解决</strong>：a. 简单来说，可以改用<code>std::shared_ptr&lt;A&gt;(new A)</code>这样的分离形式。但这样会造成其内存空间不连续。</p><p>​b. 从原本的类派送一个类，这样获得了其public的构造函数的访问权。</p><p>​c. 增加新构造函数，区分有访问权的构造。</p><p><a href="https://stackoverflow.com/questions/8147027/how-do-i-call-stdmake-shared-on-a-class-with-only-protected-or-private-const/8147213#8147213">参考1</a> <a href="https://github.com/isocpp/CppCoreGuidelines/issues/1205">参考2</a> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#discussion-use-a-factory-function-if-you-need-virtual-behavior-during-initialization">参考3</a></p></li><li><p><strong>默认实参</strong>的问题：</p><ol><li>多个声明时，（同一作用域下）后面的声明可以获得前面声明的实参；也就是说可以在后面添加默认实参。</li><li>虚函数调用的默认实参，根据调用时的静态类型来定。</li><li>运算符重载不能有默认实参。</li></ol></li><li><p>关于取成员函数指针时的重载问题：用<code>static_cast</code>进行强制类型装换后再取地址即可。注意在函数指针作为模版参数时，重载函数会导致模版参数推导失败，这个时候可以手动指定模版参数。</p></li><li><p><strong>Inline namespace</strong>可用于管理library versioning，将库的不同版本放置于一个特定的namespace中，再对目前使用的namespace前加上inline即可。其好处是在ABI的符号中保留了inline namespace的名称。</p><p><a href="https://stackoverflow.com/questions/11016220/what-are-inline-namespaces-for">参考</a></p></li><li><p><strong>Anonymous namespace</strong>用于定于翻译单元范围内的符号，其作用与<code>static</code>类似，不过相比<code>static</code>来说可以作用在类型定义上。Anonymous namespace只用于<code>.cpp</code>文件而不用于头文件，因为在头文件中的匿名空间里定义的符号可能会被多个翻译单元编译，导致在链接时发生意想不到的结果（违背了ODR原则）。对于头文件中的“私有”符号，需要采用私有的名字空间（如目前流行的<code>detail</code>）。</p><p><a href="https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions">参考1</a> <a href="https://stackoverflow.com/questions/4726570/deprecation-of-the-static-keyword-no-more">参考2</a> <a href="https://stackoverflow.com/questions/4422507/superiority-of-unnamed-namespace-over-static">参考3</a> <a href="https://stackoverflow.com/questions/357564/uses-for-anonymous-namespaces-in-header-files">参考4</a> <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL59-CPP.+Do+not+define+an+unnamed+namespace+in+a+header+file">参考5</a></p></li><li><p>当重载函数/模版函数作为参数传递给一个模版函数时，该模版函数的deduction会失败。这是因为C++目前不允许传递<strong>重载集（Overload Sets）</strong>。比如以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v1 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">3</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v2 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> v3 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::transform(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), <span class="built_in">std</span>::back_inserter(v3), <span class="built_in">std</span>::<span class="built_in">max</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>std::max</code>为重载模版函数，其作为参数传递给<code>std::transform</code>时决议失败。然而此时是可以推导出<code>std::max</code>应有的重载版本的，解决方案是用lambda将<code>std::max</code>包起来，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::transform(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), <span class="built_in">std</span>::back_inserter(v3),</span><br><span class="line">               [](<span class="keyword">auto</span> l, <span class="keyword">auto</span> r)&#123;<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">max</span>(l, r);&#125;);</span><br></pre></td></tr></table></figure><p>不过这里的参数类型可能发送变化，为了得到与之前完全一样的类型，需要用到完美转发，再让lambda自动推导返回类型。假设函数为<code>fun</code>，传入的函数应该写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">auto</span>&amp;&amp;...args)-&gt;<span class="keyword">decltype</span>(<span class="keyword">auto</span>)&#123;<span class="keyword">return</span> fun(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...);&#125;</span><br></pre></td></tr></table></figure><p>用一个宏简化一下，这里的函数用<code>__VA_ARGS__</code>表示，以支持更复杂的情况，如静态成员函数模版等；并加上了异常的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIFT(...) \</span></span><br><span class="line">    [](<span class="keyword">auto</span> &amp;&amp;... args) <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>( \</span><br><span class="line">__VA_ARGS__(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...))) -&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) \</span><br><span class="line">&#123; <span class="keyword">return</span> __VA_ARGS__(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...); &#125;</span><br></pre></td></tr></table></figure><p><a href="https://akrzemi1.wordpress.com/2018/07/07/functions-in-std/">参考2</a>指出该宏在多个地方均有出现，意味着语言特性的缺失；此外也有一些关于解决此问题的提案。</p><p><a href="https://florianjw.de/en/passing_overloaded_functions.html">参考1</a> <a href="https://akrzemi1.wordpress.com/2018/07/07/functions-in-std/">参考2</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0834r0.html">参考3</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1170r0.html">参考4</a> <a href="https://stackoverflow.com/questions/30855193/passing-template-function-as-argument-for-normal-function">参考5</a></p></li><li><p><code>noexcept()</code>有在不同地方两种含义：</p><ul><li>在函数声明时的<code>noexcept(x)</code>表示如果<code>x</code>为<code>true</code>，则该函数为no-throw。<ul><li><code>noexcept(x)</code>也可以作为操作符，返回表达式<code>x</code>是否会抛出异常。</li></ul></li></ul><p>所以<code>void foo() noexcept(noexcept(y));</code>表示函数<code>foo()</code>是否抛出异常与<code>y</code>相同。</p><p><a href="https://stackoverflow.com/questions/48703988/c-iso-noexcept-of-noexcept">参考</a></p></li><li><p>在作为参数传递Functor时，为了保证其传递的值类型不变，需要使用<code>std::forward</code>；此外，在最后调用Functor时，也需要先用<code>std::forward</code>得到原本的值类型，否则会导致Functor的值类型变化，调用到不正确的重载函数版本（如<code>const &amp;&amp;</code>被调用为<code>const &amp;</code>的版本）。</p><p><a href="https://stackoverflow.com/questions/31253334/when-should-i-stdforward-a-function-call">参考</a></p></li><li><p>C++ 11之后支持了<strong>构造函数委托（Delegating constructor）</strong>：支持一个构造函数调用另一个构造函数，可以节省很多冗余构造的代码。这种委托可以形成一个链式调用，如“A-&gt;B-&gt;C”；当然，循环调用的结果是未定义的。</p><p><a href="https://en.cppreference.com/w/cpp/language/constructor">参考1</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf">参考2</a></p></li><li><p>…</p></li></ol><h2 id="模版"><a class="markdownIt-Anchor" href="#模版"></a> 模版</h2><ol><li><p>Fold expression: 目前只支持32种C++内置的二元运算符，共4种展开形式（左折叠or右折叠 x 不带初值or带初值）</p><p>其中比较特殊的<code>,</code>二元运算用法较独特：可以用作依次的无返回值函数调用，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back_vec</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; v, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>((<span class="built_in">std</span>::is_constructible_v&lt;T, Args&amp;&amp;&gt; &amp;&amp; ...));</span><br><span class="line">    (v.push_back(<span class="built_in">std</span>::forward&lt;Args&gt;(args)), ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见有返回值的函数可以将返回值Reduce收集，而无返回值的可以采用<code>,</code>运算符展开。</p><p><a href="https://en.cppreference.com/w/cpp/language/fold">参考1</a> <a href="https://stackoverflow.com/questions/27582862/fold-expressions-with-arbitrary-callable">参考2</a> <a href="http://picanumber.github.io/reduce/">参考3</a></p></li><li><p>…</p></li></ol><h2 id="stl"><a class="markdownIt-Anchor" href="#stl"></a> STL</h2><h3 id="容器"><a class="markdownIt-Anchor" href="#容器"></a> 容器</h3><ol><li><p><code>emplace_back(Args&amp;&amp;... args)</code>通过<code>std::allocator_traits&lt;A&gt;::construct(allocator, p, args)</code>构造元素，<code>args</code>是传递给元素<code>T</code>构造函数的参数。<code>::construct()</code>函数内调用<code>::new ((void*)_Ptr) T(std::forward&lt;Args&gt;(args)...)</code>进行构造，因此这里没有使用<strong>统一初始化（Uniform Initialization）</strong>。</p><p>如果有一个POD <code>struct X&#123;int a; int b;&#125;;</code>没有定义任何构造函数，对其容器<code>std::vector&lt;X&gt;</code>进行<code>emplace_back(1, 2)</code>就会编译错误，因为找不到对应的构造函数。尽管聚合体<code>struct X</code>能被initializer_list初始化，此时也不能用<code>emplace_back(&#123;1, 2&#125;)</code>，因为**大括号initializer list（brace-enclosed initializer list）**不能被<code>std::forward</code>传递。</p><p><strong>解决</strong>：这时要么给<code>struct X</code>定义构造函数，要么改用显式初始化的<code>emplace_back(X&#123;1, 2&#125;)</code>/<code>emplace_back&lt;X&gt;(&#123;1, 2&#125;)</code>，或隐式初始化的<code>push_back(&#123;1, 2&#125;)</code>。</p><p><a href="https://stackoverflow.com/questions/13962063/emplacing-a-pod">来源</a></p></li><li><p>…</p></li></ol><h2 id="底层实现优化"><a class="markdownIt-Anchor" href="#底层实现优化"></a> 底层实现|优化</h2><h3 id="polymorphism-rtti"><a class="markdownIt-Anchor" href="#polymorphism-rtti"></a> Polymorphism &amp; RTTI</h3><ol><li>多态对象（有虚函数或继承了虚类）的首元素为一个虚表指针，之后是自己的成员变量。对于多继承的多态对象来说，布局为多个对象（首先为派生类，后面依次为各个基类）的叠加，比如对于继承关系C-&gt;{A,B}来说，其布局为 <code>[A虚表指针|A元素] [B虚表指针|B元素]</code>，注意到C本身不需要虚表指针，因为C的虚表其实就等价于A的虚表，因为它们的偏移量（<code>vptr[-16]</code>）均为0。也就是说，在单继承链中，对象均只有一个虚表指针，而多继承对象则有多个虚表指针。这样，在做<code>static_cast</code>的向下转型时只需将指针加上一个偏移量；而做<code>dynamic_cast</code>的向上转型时只需减去一个偏移量（从虚表中获得）。</li><li>RTTI的信息放在虚表的负偏移处。如<code>vptr[-8]</code>存放多态类型的<code>typeinfo</code>，<code>vptr[-16]</code>存放多态类型到其最派生的类（Most Derived Class）的<strong>负</strong>偏移量<code>offset_to_top</code>。在<code>dynamic_cast</code>中。正是用基类对象指针加上<code>vptr[-16]</code>这个偏移量，得到上层派生对象的实例。</li><li>对于偏移量不为0的基类虚表，其虚函数有所不同，前面会带一个<code>non-virtual thunk</code>。这是因为调用上层类的虚函数时，需要先调整<code>this</code>指针为上层对象的<code>this</code>，而带<code>thunk</code>的函数就会先进行转换再去调用原虚函数。</li><li>对于虚继承，虚基类的派生类无法确定虚基类关于本对象<code>this</code>的偏移，因此需要在虚表中加入一项<code>vbase_offset</code>，表示基类关于<code>this</code>的偏移，一般在负偏移<code>vptr[-24]</code>处。反过来，当虚基类要调用其虚函数时，需要的偏移量也不同，对于派生类没有覆盖的虚函数，偏移为0；而派生类覆盖了的虚函数则偏移不为0。该偏移记录在<code>vcall_offset</code>中，在<code>offset_to_top</code>上方。</li><li>（具体实现与具体编译器相关，上述内容在Clang中验证过）</li><li><a href="https://zhuanlan.zhihu.com/p/41309205">参考1</a></li></ol><h3 id="性能优化"><a class="markdownIt-Anchor" href="#性能优化"></a> 性能优化</h3><ol><li><p>对于确定不会被继承的类，采用<code>final</code>修饰可能带来一定的性能提升，比如以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">final</span> :</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call_f</span><span class="params">(B <span class="keyword">const</span>&amp; x)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x.f(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>struct B</code>有<code>final</code>修饰，编译器知道在<code>call_f</code>函数中调用虚函数<code>x.f()</code>一定是调用的<code>B::f</code>，在此就可以采用inline优化。</p><p><a href="https://devblogs.microsoft.com/cppblog/the-performance-benefits-of-final-classes/">参考</a></p></li><li><p>…</p></li></ol><h2 id="惯用技巧"><a class="markdownIt-Anchor" href="#惯用技巧"></a> 惯用技巧</h2><h3 id="模版-2"><a class="markdownIt-Anchor" href="#模版-2"></a> 模版</h3><ol><li><p><strong>奇异递归模板模式</strong>（Curiously Recurring Template Pattern, CRTP）：把派生类作为基类的模板参数。</p><p>应用：</p><ul><li>将派生类个共同代码以模版的形式提取处理，以减少派生类中的冗余代码。如多态<code>clone()</code>函数，<code>std::enable_shared_from_this</code>。</li><li>根据派生类的类型做区分处理，如对象计数。</li><li>产生不可被继承的类（final）：将CRTP基类的构造函数声明为私有，同时将对应类设为其友元。</li><li>实现<strong>多态链调用（Polymorphic chaining）</strong>：链式调用时，涉及到基类的方法返回的是基类的引用，这样就导致了链式调用的对象被“向下转换”了。解决方法就是采用CRTP，基类的方法返回派生类的引用。</li><li>提供静态的接口，可以充当类似Concept的用法（不过C++20后有Concept就不需要这个了）。</li></ul><p>为了同时兼顾静态多态与动态多态，可以设计用于动态多态的基类<code>Base</code>，用于静态多态的中间类<code>Base_CRTP&lt;T&gt;</code>，派生类为<code>class Derived : Base_CRTP&lt;Derived&gt;</code>。</p><p>此外，为了防止派生CRTP类时在模版参数中填错派生类，可以在<code>CRTP&lt;T&gt;</code>基类中将构造函数定义为<code>private</code>的，同时设置<code>T</code>为友元。</p><p>注意派生类与基类的方法同名导致的名字遮蔽问题。</p><p>CRTP中经常要用到<code>static_cast&lt;T&amp;&gt;(this)</code>，显得代码和冗余。可以写一个模版类自动完成<code>static_cast</code>，详见参考5。</p><p><a href="%5Bhttps://zh.wikipedia.org/wiki/%E5%A5%87%E5%BC%82%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%5D(https://zh.wikipedia.org/wiki/%E5%A5%87%E5%BC%82%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F)">参考1</a> <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">参考2</a> <a href="https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/">参考3</a> <a href="https://stackoverflow.com/questions/262254/crtp-to-avoid-dynamic-polymorphism/262984#262984">参考4</a> <a href="https://www.fluentcpp.com/2017/05/19/crtp-helper/">参考5</a></p></li><li><p><strong>类型擦除（Type Erasure）</strong>：使用单点多态实现包含不同实际类型的统一类型容器。</p><p>仅仅看上面这句话其实很绕…但其实拆开来说很容易理解：提供一个统一的接口，实际上为一个可能包含不同实际类型的容器，并且这是通过多态实现的。类型擦除实际上将多态的细节隐藏在了统一接口的后面，使其可以像值类型一样使用。此外，由于类型擦除基于多态，其难以解决涉及超过二元参数的多分派行为。</p><p>目前类型擦除广泛用于<code>std::function</code>、<code>std::any</code>、<code>std::variant</code>等类的实现中。还在提案中的<code>std::polymorphic_value</code>（让多态类型像值类型一样使用）也是采用类型擦除实现的。</p><blockquote><p>另一个小话题：<code>shared_ptr&lt;void&gt;</code>可以存放任何类型的对象指针，并且能调用到正确的析构函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span>&gt; <span class="title">sp</span><span class="params">( <span class="keyword">new</span> A )</span></span>;</span><br><span class="line">&#125; <span class="comment">// calls A::~A() here</span></span><br></pre></td></tr></table></figure><p>因为其默认的deleter使用的是构造函数传入的类型，也是通过类型擦除实现的。</p></blockquote><p>由于涉及到多态，自然就需要对派生对象分配空间。考虑到储存的对象大多较小，**小对象优化（Small Object Optimization）**基本也是类型擦除容器必备的。C++ 11中考虑到了让这些类型支持自定义分配器（如<code>std::function</code>），然而在C++ 17中完全去除了这个设定。这是因为在类型擦除语境中难以恢复迭代器以支持在拷贝赋值期间的分配操作。</p><p><a href="https://quuxplusone.github.io/blog/2019/03/18/what-is-type-erasure/">参考1</a> <a href="https://akrzemi1.wordpress.com/2013/11/18/type-erasure-part-i/">参考2</a> <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Erasure">参考3</a> <a href="https://stackoverflow.com/questions/5450159/type-erasure-techniques">参考4</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html">参考5</a></p></li><li><p>…</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Realtime GI Introduction</title>
      <link href="/slide/Realtime-GI/"/>
      <url>/slide/Realtime-GI/</url>
      
        <content type="html"><![CDATA[<h1 id="realtime-gi-in-games"><a class="markdownIt-Anchor" href="#realtime-gi-in-games"></a> Realtime GI In Games</h1><p>Notes:</p><p>内容主要来自EA Seed团队在17年Siggraph上关于GI的综述性talk</p><p>====</p><!-- .slide: data-background="#2874A6" --><h3 id="提纲"><a class="markdownIt-Anchor" href="#提纲"></a> 提纲</h3><ul><li>GI在游戏中的发展<ul><li>Precomputation</li><li>Volume based methods</li><li>Local Approximation</li></ul></li><li>当前方法的问题</li><li>未来游戏的GI</li></ul><!--~~附加：体素游戏的GI，Minecraft~~--><p>====</p><h3 id="whats-gi"><a class="markdownIt-Anchor" href="#whats-gi"></a> What’s GI</h3><p>==</p><p><img src="/images/x2-direct-villa.jpg" alt="Picture from NVIDIA" /></p><p>Direct illumination only</p><p>==</p><p><img src="/images/x2-global-villa.jpg" alt="Picture from NVIDIA" /></p><p>Direct + global illumination</p><p>Notes:</p><p>学术上认为global包括了direct，但游戏业界global一般仅只indirect</p><p>==</p><p>GI is more</p><p><img src="/images/gi_pic.png" alt="" /></p><p>==</p><p>GI描述了物体之间的光交互，但游戏领域主要关注的还是BRDF层面的GI。</p><p>GI如此吸引游戏开发者的原因是，它很大程度上解放了美术…</p><p>毕竟，手工调整是比不上模拟的</p><p>==</p><p><strong>近似化</strong>与<strong>简化</strong>是游戏开发最强力的工具</p><p>====</p><h3 id="gis-evolution-in-game"><a class="markdownIt-Anchor" href="#gis-evolution-in-game"></a> GI’s evolution in Game</h3><p>====</p><h3 id="precomputation"><a class="markdownIt-Anchor" href="#precomputation"></a> Precomputation</h3><p>==</p><p><strong>Surface Caching</strong></p><p><img src="/images/surface-caching.png" alt="" /></p><p>起源——Quake</p><p>模型的每个顶点存一个8-bit预先烘培好的光照值</p><p>Notes:</p><p>可以看做是最早期的Lightmap，最初只有单色亮度，后来加入了RGB亮度</p><p>这种Lightmap一般用辐射度方法预先计算，使用的时候与材质的albedo color相乘</p><p>AO可以bake进材质的diffuse color里面，但由于diffuse贴图一般是共享的，只能分开存放</p><p>每个物体的表面都需要编码进Lightmap UV里面，一般是自动完成加手动调整（防止重叠）</p><p>Lightmap很少做Mipmap，一个原因是本来就小，另一个原因是不能重叠要求有较大间隙</p><p>展开UV时要注意几何上连续的部分在UV上也要连续，不然会导致缝隙的artifact</p><p>==</p><p><strong>Radiosity Normal Mapping</strong></p><p><img src="/images/radiosity-normal-mapping.png" alt="" /></p><p>储存三个基方向的亮度值，以法线插值</p><p>能近似出Rough Specular的效果</p><p>缺点：插值的结果并不是物理正确的</p><p>Notes:</p><p>Lightmap最初只记录一个方向（法线）的光照信息，这让使用了法线贴图的模型难以使用</p><p>Valve在半条命2中提出了RNM，后来被很多游戏使用（便宜！只使用9个浮点数）</p><p>Far Cry里用里一个变种方法，只存了切线空间的主光照方向(2)，主光照颜色(3)，和一个系数表示directional的比例(1)，共6个浮点数</p><p>==</p><p><strong>Spherical Harmonics Lightmaps</strong></p><p><img src="/images/spherical-harmonics-lightmaps.png" alt="" /></p><p>Lightmap的纹素变为了SH形式储存的有方向性的光照信息</p><p>SH为球面上的一个连续函数（半球面的基要改为H-basis）</p><p>适合频率低的Diffuse，但Specular就不行了</p><p>Notes:</p><p>SH形式的Lightmap里面存的是Radiance，原Lightmap存的是Irradiance。</p><p>SH一般由离线光子映射计算出</p><p>三阶SH一共9个SH系数，可以实现很好的效果；开销略大（27个浮点数）</p><p>这是因为SH随着阶数变高，需要的系数个数会变得很多，多到内存里存不下</p><p>动态物体也可以通过Light Probe的方法访问到SH的信息，进而实现GI效果</p><p>==</p><p><strong>Spherical Gaussians Lightmaps</strong></p><p><img src="/images/spherical-gaussians-lightmaps.png" alt="" /></p><p>用不同的基函数替换SH，获得更多细节的Radiance</p><p>适合Diffuse和Specular，数据表示直观紧凑，可以随意<em>叠加</em></p><p>比如Last of Us里面就采取了Ambient+Dominant direction</p><p>Notes:</p><p>一个SG系数就可以储存一个lobe的光照</p><p>The Order:1886里面用5~9个SG系数实现了高质量的Specular GI</p><p>==</p><p><strong>Precomputed Radiance Transport</strong></p><p><img src="/images/precomputed-form-factors.png" alt="" /></p><p>预计算光源对某位置的贡献，以一个Transport函数表示</p><p>可以支持多动态光源的GI计算，如Time of day</p><p>缺点：场景变化就要重新计算可见性</p><p>Notes:</p><p>由于光的线性叠加性，不同光源的贡献可以分离计算再叠加</p><p>实际上不一定是光源，可以是任意发光表面，因为受光平面不需要知道原光源的信息</p><p>Transport函数可以接受不同形式的输入与输出</p><p>比如3阶SH到3阶SH，其开销较大，此时Transport函数相当于9x9矩阵</p><p>Far Cry3-4中就用了2阶SH作为输入，自定义的4方向basis作为输出</p><p>Assassin’s Creed 4中用一个basis表示阳光，但是提前计算出一天中不同时间的Transport</p><p>Enlighten的实时GI用到了该方法</p><p>==</p><p><strong>Light Probes</strong></p><p><img src="/images/probe-gi.png" alt="" /></p><p>将光照信息（一般是SH）储存在空间中（一般用3D texture储存，<strong>irradiance volumes</strong>）</p><p>动态物体获取临近几个光照信息，插值得到任意位置的光照</p><p>Notes:</p><p>光照信息可以来着静态的SH、SG、Ambient dice，或是动态的PRT</p><p>Unity中的Light Probe储存的是点云（手动放置），并在四面体内插值</p><p>适合动态物体，但也可用于静态物体</p><p>好处是动态物体与静态物体使用同一套光照信息，适合Deferred Shading</p><p>坏处是内存开销大，indirect specular的质量减弱（改用IBL或SSR）</p><p>====</p><h3 id="volume-based-methods"><a class="markdownIt-Anchor" href="#volume-based-methods"></a> Volume based Methods</h3><p>==</p><p><strong>Reflective Shadow Map</strong></p><p><img src="/images/rsm_maps.png" alt="" /></p><p>从光源角度渲染，记录光源可见表面的属性：</p><ol><li>表面颜色</li><li>法线</li><li>光通量（Flux）</li></ol><p>Notes:</p><p>类似Shadow Map</p><p>Flux是光源到达表面的光通量，比如点光源的光通量就与距离平方成反比；Spot light可以额外考虑falloff</p><p>==</p><p><img src="/images/indirect_lighting1.png" alt="" /></p><p>Shading时采样临近RSM纹素作为虚拟点光源</p><p>Notes:</p><p>Shadow Map一般较大，做indirect illumnation时一般只考虑临近的纹素，采用重要性采样</p><p>==</p><p><strong>Virtual Point Lights（Instant Radiosity）</strong></p><p><img src="/images/vpl-brief.png" alt="The Last of Us" /></p><p>一般用于狭隘室内的手电筒效果，调整的好可以看起来很真实</p><p>缺点是没有遮挡关系；不稳定，只能用于局部效果</p><p>Notes:</p><p>样本数量对性能影响较大</p><p>Uncharted 4里面每个像素只采样16个样本，但不同的帧轮流使用不同的样本集，最后在时间上过滤</p><p>==</p><p><strong>Heightfield GI</strong></p><p><img src="/images/heightfield-gi.png" alt="" /></p><p>渲染一个top-down的RSM，获得高度场的光照信息</p><p>适合高度场的室外开阔场景的环境光，不能用在室内</p><p>MotoGP、UE4 Kite Demo里使用过</p><p>==</p><p><strong>Light Propagation Volumes</strong></p><p><img src="/images/lpv-brief.png" alt="" /></p><p>将场景划分为3维网格，每个cell里面储存radiance的分布</p><p>优点：无需预处理，开销低，支持体积效果</p><!-- .element: style="font-size:80%;" --><p>缺点：网格未对齐会导致漏光，网格分辨率高时光线传播慢</p><!-- .element: style="font-size:80%;" --><p>Notes:</p><p>Radiance分布在最初的论文中以2阶SH储存</p><p>LPV的开销较低，主机硬件都能运行</p><p>总体来说适合Diffuse GI</p><p>==</p><p><img src="/images/lpv-progress.png" alt="" /></p><p>LPV分成3个步骤：</p><ol><li>渲染RSM</li><li>含有VPL的cell计算最初的SH</li><li>光照在网格内传播</li></ol><p>Notes:</p><p>最初只有与被光照射的表面直接接触的cell有光照信息</p><p>接下来，每个cell根据邻居cell的光照，计算出自己光照的更新</p><p>最后得到一个radiance field，这个radiance field包含了低频的光照信息，甚至可以做一些glossy BRDF</p><p>由于每次迭代光照只能传播一格，速度较慢；而低分辨率网格又容易导致漏光；后来提出了Cascaded LPV</p><p>最初传播没有考虑遮挡，后来使用了RSM与摄像机的深度信息，作为部分遮挡信息；完整的遮挡可以voxelize场景</p><p>==</p><p><strong>Sparse Voxel Octree GI</strong></p><p><img src="/images/vct-brief.png" alt="" /></p><p>场景储存为稀疏体素八叉树，且层次化（类似Mipmap）</p><p>优点：支持Diffuse和Specular，和较大尺度的AO</p><!-- .element: style="font-size:80%;" --><p>缺点：有部分漏光，高Specular有artifact</p><!-- .element: style="font-size:80%;" --><p>Notes:</p><p>当下最好的实时GI实现</p><p>后来有用更GPU friendly的Clipmap替代octree的实现，Clipmap类似Mipmap，只是低层信息只储存中心部分</p><p>其实，拿到场景Voxel数据后可以做很多，如AO，Soft Shadow</p><p>AO相比SSAO的好处是可以考虑到离屏遮挡，只是分辨率不高，只适合较大尺度</p><p>漏光是体积类方法的通病了；偏镜面的反射会展现出底层是voxel的本质，可以falloff到SSR之类的其他方法</p><p>==</p><p><img src="/images/svogi.png" alt="" /></p><p>SVOGI也可以分为3步：</p><ol><li>将RSM的直接光照信息注入到底层八叉树中</li><li>底层八叉树的光照向上层传播</li><li>Cone Tracing收集indirect radiance</li></ol><p>Notes:</p><p>第一步（Light pass）与LPV第一步类似</p><p>第二步（Filtering pass）：down-sampling</p><p>第三步（Camera pass）</p><p>==</p><p><strong>Voxel Cone Tracing</strong></p><p><img src="/images/voxel-cone-tracing.png" alt="" /></p><p>根据Cone当前部分大小，找到八叉树的合适层级做相交检测</p><!-- .element: style="font-size:75%;" --><p>Tracing Cone的方向与数量根据BRDF决定</p><!-- .element: style="font-size:75%;" --><p>Notes:</p><p>理想情况是发射很多ray做相交检测，但限于速度只能向平均方向做cone tracing</p><p>Cone的精确相交计算量也大，只能将cone分割成由小到大的球体（或立方体），每个球体（立方体）与八叉树做快速相交检测</p><p>距离cone的发射点越远，立方体的尺寸越大，采样偏顶层（较粗略）的体素八叉树</p><p>用类似三线性插值的方法获得选中的两层的一个中间值</p><p>Diffuse BRDF一般要Tracing多个Cone，以覆盖整个半球面；VCT尤其适合glossy reflection</p><p>====</p><h3 id="local-approximation"><a class="markdownIt-Anchor" href="#local-approximation"></a> Local Approximation</h3><p>==</p><p><strong>Ambient Occlusion</strong></p><p><img src="/images/ao-baking-gpu.png" alt="" /></p><p>AO作为GI的局部近似</p><p>根据光照信息频率的不同，有不同的方案</p><p>典型的如baked lightmap AO，SSAO，volumn，高度场、距离场AO等</p><p>Notes:</p><p>图片是Destiny采用的baked AO</p><p>近年来实时计算的AO被大量使用，如基于距离场的cone tracing，screen-spaced AO</p><p>起初Crytek提出的SSAO只是简单的在每个像素的一圈内采样点，根据多少像素深度小于采样点深度判断遮挡程度；HBAO对其做了较大改进，找出水平方向的未遮罩角度</p><p>==</p><p><strong>Screen Space GI</strong></p><p><img src="/images/ssgi.png" alt="" /></p><p>局部GI的另一种方案</p><p>目前比较成熟的是<strong>Horizon-Based Indirect Lighting</strong></p><p>Notes:</p><p>可以当做近距离局部GI的补充，与另一种全局GI结合使用</p><p>受到HBAO的启发，挖掘屏幕空间的位置信息</p><p>每渲染一个pass就相当于一次bounce，多帧后就可以达到近乎无限次数的bounce效果</p><p>Screen-space方法的缺点是作为光源的pixel被挡住或离开屏幕后，受间接光的部分会马上黑掉</p><p>有一些trick解决这个问题，如将被直接光照的部分同时渲染到另一个Render Target上，并且以更大的FOV渲染，first bounce从这个RT上采样，这样就减轻了视角切换带来的问题</p><p>==</p><p><strong>Specular GI?</strong></p><p><img src="/images/stochastic-ssr.png" alt="" /></p><p>Specular GI有一些独特的解决方案，如基于IBL的Parallax-Corrected Cubemaps，Screen-Space Reflections，Spherical Harmonics/Guassian近似</p><p>Notes:</p><p>SSR尤其适合FPS类游戏，但在其他视角（top-down view）就没什么效果</p><p>一些传统的方法，如平面反射也可以考虑进来</p><p>当前的RTX也是一直Specular GI的解决方案</p><p>大部分游戏不考虑specular到specular的GI</p><p>====</p><h3 id="challenge"><a class="markdownIt-Anchor" href="#challenge"></a> Challenge</h3><p>==</p><h4 id="视觉一致性失败"><a class="markdownIt-Anchor" href="#视觉一致性失败"></a> 视觉一致性失败</h4><ul><li>模型过于简化</li><li>PBR参数过于简化</li><li>低分辨率素材</li><li>错误处理了特殊光源（cookie）</li><li>手动参数调节过度</li><li>出现负值光</li></ul><p>Notes:</p><p>•Simplified albedo color</p><p>•Not handling metallic surfaces</p><p>•Not handling roughness properly</p><p>•Not storing enough post-computation info to reconstruct view-dependent results</p><p>•Vertex/surface/detail normal to texel/voxel/probe ratio</p><p>==</p><h4 id="开发流程失败"><a class="markdownIt-Anchor" href="#开发流程失败"></a> 开发流程失败</h4><ul><li>开发时的光照一直是“错”的</li><li>使迭代变得复杂</li><li>“全局”意味着移动一个物体，整个场景重新烘培</li><li>“预览”模式也很慢，灯光还不准确</li><li>导致关卡设计变得“静止”</li></ul><p>Notes:</p><p>•i.e.: Build made two revisions before lighting was “generated”, hard to judge art!</p><p>•i.e.: Lighting done late in the level authoring process, after sign-off</p><p>Example Scenario: Nightly build of GI for open world map (8+ hours)</p><p>1.Artist submits everything in time for automated process to start</p><p>2.Process runs all night</p><p>3.Artist arrives at work in the morning, syncs and opens editor, notices something is visually broken</p><p>4.Fixes it, submits, waits (next day, or several hours)</p><p>5.Rinse-and-repeat</p><p>==</p><h4 id="编辑流程失败"><a class="markdownIt-Anchor" href="#编辑流程失败"></a> 编辑流程失败</h4><ul><li>美术倾向“手工调整”GI失败的地方</li><li>修复“漏光”</li><li>用“负光”去除过度的GI</li><li>用简单几何体加速烘培</li><li>耗时耗力而且不稳定</li></ul><p>Notes:</p><p>Unity progressive lightmapper 就是加速编辑流程的工具</p><p>希望杜绝无意义的“GI调整”：Unwrapping lightmap UVs、Building simplified geometry for GI、Manually placing GI &amp; reflection volumes</p><p>==</p><h4 id="帧数帧数"><a class="markdownIt-Anchor" href="#帧数帧数"></a> 帧数，帧数</h4><ul><li>60Hz -&gt; 16.6ms</li><li>144Hz -&gt; 6.94ms</li><li>留足余量，实际可用比这还少（掉帧就不好玩了）</li><li>主机的GPU算力…（单位：TFLOPS）<ul><li>PS4: 1.8, PS4Pro: 4.2, XB1: 1.3, XB1X: 6</li><li>TitanX: 11, Vega: 13.1</li></ul></li></ul><p>==</p><h4 id="烘培过于耗电"><a class="markdownIt-Anchor" href="#烘培过于耗电"></a> 烘培过于耗电</h4><ul><li>Beefy Machines / Server Setups<ul><li>Halo 3: 256 servers, 456 Processors, 1GB memory [Chen08][Villegas08]</li><li>CoD: 48 GB RAM and 12 GB VRAM machines</li><li>Destiny: Farm with tens of servers to bake AO</li><li>SNDBS/Incredibuild: pool of GPUs running all night (650W+ PSUs)</li></ul></li></ul><p>==</p><h4 id="游戏特性使gi失效"><a class="markdownIt-Anchor" href="#游戏特性使gi失效"></a> 游戏特性使GI失效</h4><ul><li>磨损、破坏、变形效果</li><li>昼夜变换</li><li>天气</li><li>玩家生成物体</li><li>动态物体、动态光源、体积光</li></ul><p>Notes:</p><p>A hole in the wall can drastically break GI</p><p>Interpolation doesn’t always give best results</p><p>==</p><h4 id="开放世界"><a class="markdownIt-Anchor" href="#开放世界"></a> 开放世界</h4><p><img src="/images/open-world-scale.png" alt="" /></p><p>==</p><table><thead><tr><th><img src="/images/acu-gi-huge.png" alt="" /></th><th><img src="/images/acu-gi-result.png" alt="" /></th></tr></thead><tbody><tr><td>ACU 高达21GB的GI文件</td><td>效果的确很好</td></tr></tbody></table><p>==</p><p><img src="/images/open-world-gi.png" alt="" /></p><ul><li>昼夜变换、天气</li><li>室内、室外切换</li><li>需要Robust的制作流程</li></ul><p>Notes:</p><p>开放世界的GI很不简单</p><p>体量大、串流压力</p><p>====</p><p>GI for Games of The Future</p><p><img src="/images/future-game-gi.jpg" alt="" /></p><p>==</p><ul><li>GI可以渲染氛围，就像背景音乐</li><li>自然场景的GI，很难（森林，植被…）</li><li>体积效果（雾、烟、汽…）的GI</li><li>全粗糙度覆盖、全BSDF覆盖的GI</li><li>支持任意的光（面积光将成为主流）</li><li>AI降噪、重建，Deep Learning GI?</li><li>简单、直观、美术友好的用户界面</li><li>…</li></ul><p>Notes:</p><p>比如FPS中一个着火的场景，火光、烟雾的GI能极大提升沉浸感</p><p>体积效果GI不解决，爆炸就难以真实</p><p>窗户、广告牌…都是面积光（然而面积光的实时阴影现在都搞不定…）</p><p>以上这些问题需要学术界与游戏界共同解决…</p><p>最近随着硬件水平的提升，越来越多的厂商将Ray tracing体系内的思想和算法带进了实时渲染领域；未来一段时间可以看到越来越多的RT与光栅化算法在各种层面结合的例子</p><p>====</p><h4 id="comparison"><a class="markdownIt-Anchor" href="#comparison"></a> Comparison</h4><table><thead><tr><th><strong>实时方法</strong></th><th>静态物体（Diffuse）</th><th>动态物体（Diffuse）</th><th>静态物体（Specular）</th><th>动态物体（Specular）</th></tr></thead><tbody><tr><td>静态光照</td><td>Radiosity Normal Mapping</td><td>Light Probes</td><td>Spherical Gaussian Lightmap</td><td>Environment Map</td></tr><tr><td></td><td>Spherical Harmonic Lightmap</td><td>Ambient Occulsion</td><td>Directional Occulsion</td><td></td></tr><tr><td>动态光照</td><td>Precomputed Radiance Transport</td><td>Virtual Point Lights</td><td></td><td>SVOGI/Voxel Cone Tracing GI</td></tr><tr><td></td><td></td><td>Light Propogation Volumes</td><td></td><td>Planar/Screen-space Reflection</td></tr><tr><td></td><td></td><td>Screen-space GI（HBIL）</td><td></td><td></td></tr></tbody></table><!-- .element: style="font-size:50%;" --><p>====</p><h3 id="the-end"><a class="markdownIt-Anchor" href="#the-end"></a> The End</h3><p>Reference:</p><ul><li><a href="https://www.ea.com/seed/news/seed-siggraph2017-global-illumination">https://www.ea.com/seed/news/seed-siggraph2017-global-illumination</a></li><li><a href="https://ericpolman.com/2016/03/17/reflective-shadow-maps/">https://ericpolman.com/2016/03/17/reflective-shadow-maps/</a></li><li><a href="https://research.nvidia.com/sites/default/files/pubs/2011-09_Interactive-Indirect-Illumination/GIVoxels-pg2011-authors.pdf">https://research.nvidia.com/sites/default/files/pubs/2011-09_Interactive-Indirect-Illumination/GIVoxels-pg2011-authors.pdf</a></li><li><a href="https://github.com/Patapom/GodComplex/blob/master/Tests/TestHBIL/2018%20Mayaux%20-%20Horizon-Based%20Indirect%20Lighting%20(HBIL).pdf">https://github.com/Patapom/GodComplex/blob/master/Tests/TestHBIL/2018 Mayaux - Horizon-Based Indirect Lighting (HBIL).pdf</a></li><li>《Realtime rendering 4th》Chapter 11</li></ul><!-- .element: style="font-size:60%;" -->]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时渲染 </tag>
            
            <tag> GI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda函数与std::function</title>
      <link href="/code/Cpp-Function/"/>
      <url>/code/Cpp-Function/</url>
      
        <content type="html"><![CDATA[<p>Lambda函数可以说是C++ 11中加入的最重要的特性之一了。Lambda（也称作匿名函数），提供了一种在代码中很方便地定义函数的方法。这种写法能让我们写出非常简洁的语句，比如<code>[]&#123;&#125;()</code>也许就是C++中最简洁的表达式了。</p><a id="more"></a><h4 id="lambda语法回顾"><a class="markdownIt-Anchor" href="#lambda语法回顾"></a> Lambda语法回顾</h4><p>Lambda的语法也很简单，其形式大致为<code>[]()&#123;&#125;</code>，包含3个部分。</p><ul><li><code>[]</code>中的内容为捕获列表</li><li><code>()</code>中的内容为参数列表</li><li><code>&#123;&#125;</code>为函数体</li></ul><p>当参数列表为空时，<code>()</code>部分可以省略，也就是说，C++中最简单的Lambda函数是<code>[]&#123;&#125;</code>，这是一个无输入无返回值无语句的空函数。</p><p>一个纯粹的函数是不带有任何变化信息的，就仿佛数学意义上的函数——放回值仅由参数值决定，除此之外什么都不做。但很多时候我们需要函数能访问和修改一些外部的数据，或者说需要有相应的<strong>上下文</strong>。函数体与上下文的整体就称作<strong>闭包（closure）</strong>，它在Lambda中是通过捕获外部变量实现的。</p><p>捕获列表<code>[]</code>中放置所有在函数体中用到的外部变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [i, &amp;j](<span class="keyword">int</span> a, <span class="keyword">float</span> b)&#123; ++j; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2.0f</span>);</span><br></pre></td></tr></table></figure><p>比如上面这个例子，就捕获了<code>i</code>，<code>j</code>两个变量，其中<code>i</code>是值捕获，<code>j</code>是引用捕获。</p><p>当捕获的变量较多时，C++还提供了一种指定默认捕获的简便写法：</p><ul><li><code>[=]</code>指出默认为值捕获</li><li><code>[&amp;]</code>指出默认为引用捕获</li></ul><p>指定默认捕获之外，其他特定变量的捕获方式加在捕获列表之后即可。比如下面这个例子指定默认为值捕获，<code>j</code>为引用捕获：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [=, &amp;j](<span class="keyword">int</span> a, <span class="keyword">float</span> b)&#123; ++j; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br></pre></td></tr></table></figure><p>你可能会想，怎么只有两种捕获方式呢？C++的移动语义用到捕获里面呢？</p><p>C++ 11 中确实只有这两种方式，但是 C++ 14 的出现解决了这个问题：C++14 允许捕获对象由任意表达式初始化。这就说明可以用下面的方式实现移动捕获：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="keyword">auto</span> f = [value = <span class="built_in">std</span>::<span class="built_in">move</span>(ptr)] &#123; <span class="keyword">return</span> *value; &#125;;</span><br></pre></td></tr></table></figure><p>需要特别说明的一点是，值引用捕获的变量默认是<code>const</code>的，如果要在函数体内修改，需要给lambda加上<code>mutable</code>修饰符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [=](<span class="keyword">int</span> a) <span class="keyword">mutable</span> &#123; <span class="built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br></pre></td></tr></table></figure><p>值捕获对象的生命周期与lambda本体的生命周期相同，而引用捕获则需要注意调用lambda函数时捕获对象仍在生命周期内。通过捕获不同的对象，lambda函数实现了<strong>闭包</strong>的效果，比如下面的代码就构造了一个斐波那契数列<strong>生成器（generator）</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> make_fib = [] &#123;</span><br><span class="line">        <span class="keyword">auto</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> [=]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> ret = a; a = b; b += ret;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fib = make_fib();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fib() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面的写法中，我们均没有指明lambda的返回类型是什么，这时C++会将返回类型当作<code>auto</code>，自动帮我们推导。如果要明确指出返回类型，可以像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []() -&gt; <span class="keyword">double</span> &#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;;</span><br></pre></td></tr></table></figure><h4 id="在c中表示函数"><a class="markdownIt-Anchor" href="#在c中表示函数"></a> 在C++中表示函数</h4><p>函数动态调用，就是把函数存在“变量”里面，调用的时候根据变量值的不同调用相应的函数。要实现这个我们至少需要做两部分事：</p><ol><li>构造并储存函数到变量中</li><li>调用一个变量中存有的函数</li></ol><p>如果实现了这两点，我们便认为函数是<strong>一等公民</strong>：函数的地位与其他的基础类型一样，可以储存在变量中，可以作为参数传递，可以像其他变量一样随意构造。在函数式语言和许多的动态类型脚本语言（JS，Lua等）中，函数均是一等公民。C<ins>中，函数并不是原生的一等公民（直到Lambda的出现改善了这一点），但 C</ins>也提供了不少语言机制让我们实现函数作为一等公民的类似效果。</p><p>关于第一点，C++中要表示可以调用的函数（callable），主要有三种方式：</p><ol><li>函数指针</li><li>函数对象（functor，或function object）</li><li>Lambda</li></ol><p>函数指针是从C语言中基础而来的写法，它可以指向任意同签名的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="keyword">int</span>(*f)(<span class="keyword">int</span>,<span class="keyword">int</span>) = add;</span><br><span class="line"><span class="keyword">int</span> r = f(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>这里的<code>f</code>就是指向add函数的函数指针。由于<code>f</code>实际上是一个指针，而指针的值可以指向任何同类型签名的函数，指针也能很方便的作为参数传入任意函数。</p><p>函数对象是一个定义了operator()运算符重载的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Functor</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> f = Functor();</span><br><span class="line"><span class="keyword">int</span> r = f(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>函数对象只声明了一个<strong>可调用的函数</strong>，并不具备<strong>动态调用</strong>的能力——因为两个不同函数对象的类型不同，不能相互赋值。解决方案有两种，一种是通过模版在编译期决定调用对象；另一种是通过面向对象中的<strong>多态</strong>在运行期决定调用对象：在基类中声明函数签名，并在该基类的不同派生类中实现对应的方法。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FunctorBase</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Functor1</span> :</span> FunctorBase &#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Functor2</span> :</span> FunctorBase &#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a - b; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在C++中，多态一般是由**虚表(virtual table)**实现的，这样实现的动态调用，其实是借助了虚表。</p><p>Lambda在上面已经介绍过了，在C++中lambda相当于函数对象的语法糖：它能自动帮你捕获变量。也就是说，下面这个lambda函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [=, &amp;j](<span class="keyword">int</span> a, <span class="keyword">float</span> b)&#123; ++j; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br></pre></td></tr></table></figure><p>其实与这个函数对象的功能相同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F</span> &#123;</span></span><br><span class="line">    F(<span class="keyword">int</span> i, <span class="keyword">int</span> &amp;j) : i(i), j(j) &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">float</span> b)</span> </span>&#123; ++j; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> &amp;j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = F()</span><br></pre></td></tr></table></figure><p>Lambda其实相当于<code>const</code>类型的函数对象，所以修改捕获值时要加mutable修饰符。这个函数对象的类型是实现定义的，编译器会生成一个相应的类型。因此在将lambda赋值给一个变量时，变量类型只能为<code>auto</code>，因为没法确定lambda的类型。</p><p>Lambda对象也有相应的大小。由这种等价而来的函数对象，可以很轻易地发现lambda对象的占用空间来自其捕获的对象。比如在64位系统下就有如下的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">auto</span> f = []()&#123;&#125;;<span class="comment">// sizeof(f) == 1</span></span><br><span class="line"><span class="keyword">auto</span> g = [&amp;a]()&#123;&#125;;<span class="comment">// sizeof(g) == 8</span></span><br><span class="line"><span class="keyword">auto</span> h = [a]()&#123;&#125;;<span class="comment">// sizeof(h) == 10</span></span><br></pre></td></tr></table></figure><p>可以看到，空lambda的大小为1字节，与空对象的大小为1字节是对应的。如果有捕获的对象，捕获对象占多大空间，lambda就有多大。</p><p>由于lambda的类型是编译器定的，即使是两个函数签名相同的lambda变量也不能相互赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;f&quot;</span>; &#125;;</span><br><span class="line">f = []()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;g&quot;</span>; &#125;;<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>不过在捕获列表为空时，我们可以将lambda赋值给相同函数签名的函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(*f)(<span class="keyword">int</span>,<span class="keyword">int</span>) = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure><p>既然同函数签名也不能互相赋值，说明Lambda本身不具备动态调用的能力。而由于类型不确定的原因，它也不能利用到面向对象中多态的解决方案，要把lambda函数作为参数传如其他地方中，只能通过模版在编译器解决。在编译期解决调用的好处就是编译器可以很好得将较小的函数体<strong>内联</strong>进调用函数的地方。比如下面第一种搜索的写法就比用函数指针的第二种写法要快的多，原因正是因为编译器进行了函数内联，从而更好的优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种 - 模版内联</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">first_search</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> bigger = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> a &gt; b; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> rng = <span class="built_in">std</span>::equal_range (vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), val, bigger);</span><br><span class="line">  <span class="keyword">return</span> rng.first != rng.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种 - 函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bigger</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123; <span class="keyword">return</span> *(<span class="keyword">int</span>*)b - *(<span class="keyword">int</span>*)a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">second_search</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bsearch (&amp;val, vec.data(), vec.<span class="built_in">size</span>(), <span class="keyword">sizeof</span>(<span class="keyword">int</span>), bigger);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然编译期决定调用能产生高效的代码，但我们有时只能运行期才能决定调用哪个函数。那怎么样让lambda函数能够在运行期动态地决定调用对象是谁呢？这就需要说到C++11中与lambda同时引入的<strong>std::function</strong>了。</p><h4 id="函数容器stdfunction"><a class="markdownIt-Anchor" href="#函数容器stdfunction"></a> 函数容器——std::function</h4><p>上面，我们解决了储存函数的问题，现在要来看看动态调用的问题了。</p><p>首先，动态调用可以发生在两个阶段：<strong>编译期</strong>和<strong>运行期</strong>。</p><p>编译期的调用主要由<strong>模版</strong>实现，比如在<code>std::sort</code>中传入比较函数。</p><p>运行期的调用则会稍微麻烦一些，目前我们已知有两种方式：</p><ol><li>函数指针</li><li>面向对象的多态</li></ol><p>多态要求函数体实现在一个继承类中，这有时并不太好实现，比如就没有办法让<code>int</code>这样的基础类型继承（要搞也只能像Java中的Integer类做一个装包，但是没有必要）。函数指针虽然没有这个问题，但它本质是无状态的，不方便实现像闭包这样的东西。</p><p>有没有一种好的解决方案呢？有。C++11中加入的<code>std::function</code>正好解决了这个问题。它是一种通用的函数容器，不管是函数指针、函数对象、还是lambda函数，只要它们的函数签名对的上，都可以存在里面，而且可以很方便的复制、传递、调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Functor</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;functor&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f;</span><br><span class="line">f = func;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">f = Functor();</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">f = []()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;lambda&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::function</code>在被赋值到一个具体的函数前，是空的状态，如果这时调用<code>f()</code>，会得到<code>std::bad_function_call</code>异常。</p><p><code>std::function</code>的动态调用是用<strong>多态</strong>实现的（在后面会细说），说明<code>f</code>中至少含有一个虚表指针。此外，正如lambda函数要分配储存上下文的空间，<code>std::function</code>也需要给上下文分配空间。这个空间是随着捕获内容的大小而变化的，我们可能猜测该空间分配在堆上，正如<code>std::string</code>那样。如果我们去取上面这个<code>f</code>变量的大小，会发现<code>sizeof(std::function&lt;void()&gt;) == 32</code>，它实际的大小显然比只存一个虚表指针加上堆空间指针要多的多。事实上，在目前的三大主流编译器（gcc, clang, msvc）的实现中，均采用了一个如<code>std::string</code>中的<strong>小对象优化机制(SBO, Small Buffer Optimization)</strong>：较小的上下文储存在栈上。我们可以hook掉分配内存的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换掉全局的new与delete</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Allocating &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="built_in">free</span>(p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> a1[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">auto</span> lambda1 = [a1]()&#123;&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;lambda1 size: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(lambda1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f1 = lambda1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a2[<span class="number">17</span>];</span><br><span class="line"><span class="keyword">auto</span> lambda2 = [a2]()&#123;&#125;; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;lambda2 size: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(lambda2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f2 = lambda2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lambda1 size: 16</span><br><span class="line">lambda2 size: 17</span><br><span class="line">Allocating 17 bytes</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，16字节一下的上下文保存在栈中，超过16字节的话则会保存在堆中。</p><h4 id="实现一个简陋的stdfunction"><a class="markdownIt-Anchor" href="#实现一个简陋的stdfunction"></a> 实现一个简陋的<code>std::function</code></h4><p>之前我提到了<code>std::function</code>用了多态来实现运行期的动态调用，但具体是怎么实现的呢？直接做一个不就知道了:D（这一部分主要参考了<a href="https://shaharmike.com/cpp/naive-std-function/">这篇文章</a>）</p><p>在<a href="https://en.cppreference.com/w/cpp/utility/functional/function">cppreference</a>上找到<code>std::function</code>的定义大致如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">function</span>;</span> <span class="comment">/* undefined */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Result</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">function</span>&lt;Result(Args...)&gt; &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个类定义是第一个的<strong>偏特化（partial specialization）</strong>，模版匹配时会将第一个模版尝试匹配在第二个模版上，这样就能将函数类型中的返回值与参数分离出来。如果我们只将其声明成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Result</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">function</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那使用时就只能写成这一种形式：<code>std::function&lt;int, int, float&gt;</code>，而不是我们比较习惯的这种格式：<code>std::function&lt;int(int, float)&gt;</code>。</p><p>之前我们说过，<code>std::function</code>的动态函数调用是通过多态实现的。要实现多态调用，首先要定义一个基类<code>ICallable</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ICallable</span> &#123;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~ICallable()                = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Result <span class="title">Invoke</span><span class="params">(Args... args)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基类主要定义了一个<code>Invoke</code>虚方法来实现函数调用。接下来是派生类<code>CallableT</code>，这里将实际存放的函数类型定义为一个模版参数，从而实现对多种函数表示的支持：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">CallableT</span> :</span> ICallable &#123;</span><br><span class="line">    CallableT(<span class="keyword">const</span> T &amp;t) : t(t) &#123;&#125;</span><br><span class="line">    ~CallableT() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function">Result <span class="title">Invoke</span><span class="params">(Args... args)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> t(args...); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>CallableT</code>类实际上用到了一个C++中的惯用技巧——<strong>类型擦除(Type Erasure)</strong>。类型擦除让我们能够将一个不管是什么类型的对象“包”进我们的类中，并让我们之后能调用它。每当<code>CallableT</code>被实例化，都伴随着创建了一个新的虚表(vtable)，辅以多态，我们就能动态地调用到各种不同形式的函数。STL中的<code>std::function</code>、<code>std::any</code>都用到了这个技巧。</p><p>有了这两个类的帮助，<code>function</code>类就很好实现了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span> BufferSize = <span class="number">32</span>&gt; class function; <span class="comment">/* undefined */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span>... Args, <span class="built_in">std</span>::<span class="keyword">size_t</span> BufferSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>&lt;Result(Args...), BufferSize&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    function() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; function &amp;<span class="keyword">operator</span>=(T &amp;&amp;t) &#123;</span><br><span class="line">        <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(CallableT&lt;T&gt;) &lt;= <span class="keyword">sizeof</span>(storage), <span class="string">&quot;function is too large for buffer&quot;</span>);</span><br><span class="line">        callable.reset(<span class="keyword">new</span> (storage) CallableT&lt;T&gt;(t));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; function &amp;<span class="keyword">operator</span>=&lt;<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>&gt;(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span> &amp;&amp;t) &#123;</span><br><span class="line">        callable.reset(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Result <span class="title">operator</span><span class="params">()</span><span class="params">(Args... args)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        assert(callable);</span><br><span class="line">        <span class="keyword">return</span> callable-&gt;Invoke(args...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ICallable 代码 ...</span></span><br><span class="line">    <span class="comment">// CallableT 代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Deleter</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ICallable *callable)</span> </span>&#123; callable-&gt;~ICallable(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>                                storage[BufferSize];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ICallable, Deleter&gt; callable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我没有采用动态内存分配的方式，而是直接在栈上分配了<code>BufferSize</code>字节大小的<code>storage</code>（毕竟调用<code>new</code>的开销比直接在栈上分配要大的多），在此储存上下文。<code>BufferSize</code>的大小由模版值确定，默认为32。</p><p><code>operator=</code>函数的参数类型是一个模版参数，以支持赋值任意的函数形式。其中判断了赋值的函数上下文是否能够储存下，如果是，直接在<code>storage</code>中构造对象。这里还特化了赋值<code>nullptr</code>的情况。</p><p>而<code>operator()</code>函数则更加直接，里面调用了基类的虚函数<code>Invoke</code>，在这里调用在虚函数表中找到实际的函数。由于函数可能为空，需要用<code>assert</code>验证其为非空。</p><p>简单测试一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">functor</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;functor&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    function&lt;<span class="keyword">void</span>()&gt; f;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof function&lt;void()&gt;: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(f);</span><br><span class="line">    f = func;</span><br><span class="line">    f();</span><br><span class="line">    f = functor();</span><br><span class="line">    f();</span><br><span class="line">    f = [] &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;lambda&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof function&lt;void()&gt;: 40</span><br><span class="line">func</span><br><span class="line">functor</span><br><span class="line">lambda</span><br></pre></td></tr></table></figure><p>动态函数储存是没有问题了，但这个<code>function</code>对象占用了40个字节的大小…实际能存多大的上下文呢？简单测试一下，发现上下文最大能存24个字节的大小，而分配的<code>storage</code>大小是32字节，另外8字节显然被用作了虚表指针。也就是说，这个对象有16个字节是不能用于储存上下文的，能不能进一步优化一下呢？</p><p>稍微分析一下就能发现，上面的实现额外储存了一个基类指针，然而基类地址已知，这个指针并没有起到什么作用，唯一的作用就是表示对象是否为空。另一方面，可以用函数指针本身为空来表示对象为空。然而，虚表指针我们无法修改，也就不能将其置空。不过，可以用一种实例化的特殊<code>CallableT</code>来表示<code>function</code>为“空”的这种情况。</p><p>简单修改下<code>function</code>的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span>... Args, <span class="built_in">std</span>::<span class="keyword">size_t</span> BufferSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>&lt;Result(Args...), BufferSize&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    function() &#123; <span class="keyword">new</span> (storage) CallableT&lt;<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>&gt;(<span class="literal">nullptr</span>); &#125;</span><br><span class="line">    ~function() &#123; ((ICallable *)storage)-&gt;~ICallable(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; function(T &amp;&amp;t) &#123; <span class="keyword">operator</span>=(<span class="built_in">std</span>::forward&lt;T&gt;(t)); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; function &amp;<span class="keyword">operator</span>=(T &amp;&amp;t) &#123;</span><br><span class="line">        <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(CallableT&lt;T&gt;) &lt;= <span class="keyword">sizeof</span>(storage), <span class="string">&quot;function is too large for buffer&quot;</span>);</span><br><span class="line">        ((ICallable *)storage)-&gt;~ICallable();</span><br><span class="line">        <span class="keyword">new</span> (storage) CallableT&lt;T&gt;(t);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Result <span class="title">operator</span><span class="params">()</span><span class="params">(Args... args)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((ICallable *)storage)-&gt;Invoke(args...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ICallable 代码 ...</span></span><br><span class="line">    <span class="comment">// CallableT 代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">CallableT</span>&lt;std::nullptr_t&gt; :</span> <span class="keyword">public</span> ICallable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CallableT(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nullptr_t</span> &amp;t) &#123;&#125;</span><br><span class="line">        ~CallableT() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Result <span class="title">Invoke</span><span class="params">(Args... args)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">throw</span> <span class="built_in">std</span>::bad_function_call(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> storage[BufferSize];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>PS：上面的代码在Clang和MSVC测试通过，但GCC报错。原因是C++标准要求特化必须在命名空间里做，而Clang和MSVC放宽了这个限制。如果要在GCC上编译，需要做一些workaround（如dummy template argument），这里鉴于篇幅省略…</p></blockquote><p>基本思路是用以<code>std::nullptr_t</code>实例化一个<code>CallableT</code>，用来表示<code>function</code>为空的情况。这种实现也可以去除<code>Invoke</code>调用时判断为空的分支。细节这里就不再说了，代码已经比较清楚了。</p><p>修改之后，这个<code>function</code>类已经能做到只用8字节作为虚表指针，剩下的空间用作储存上下文了，比之前节省了8字节的空间呢 😄</p><p>不过，如果用它去存一个没有上下文的函数，我们发现<code>BufferSize</code>至少是16字节，而不是预计的8字节。这里被神秘地拿去的8字节来自于<code>CallableT</code>中储存的<code>t</code>，如果函数的上下文为0字节，这里的<code>t</code>应该也是0字节。但是，C++中是不允许存在大小0字节的对象的（不然怎么取地址啊）。于是<code>t</code>的大小就被当作了1字节，再加上内存对齐的影响，最小的<code>BufferSize</code>就应该是16字节啦。</p><p>目前<code>function</code>看起来已经能用了，但我们还忽略了一个“小”问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">void</span>()&gt; f2;</span><br><span class="line">f2 = f;</span><br><span class="line">f2();</span><br></pre></td></tr></table></figure><p>上面的语句能成功通过编译，我们可能认为编译器为<code>function</code>对象自动创建了自己的复制赋值函数。但真的是这样吗？如果我们在<code>function</code>的<code>Invoke</code>中加上一句输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">operator</span><span class="params">()</span><span class="params">(Args... args)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invoked&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ((ICallable *)storage)-&gt;Invoke(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并运行下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    static_function&lt;<span class="keyword">void</span>()&gt; f;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    f = [=]() <span class="keyword">mutable</span> &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;;</span><br><span class="line">    f();</span><br><span class="line"></span><br><span class="line">    static_function&lt;<span class="keyword">void</span>()&gt; f2;</span><br><span class="line">    f2 = f;</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Invoked</span><br><span class="line">1</span><br><span class="line">Invoked</span><br><span class="line">Invoked</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>可以看到调用<code>f2()</code>时触发了两次<code>Invoke</code>，显然不是我们想要的情况。可以看出，这是因为<code>f2</code>将<code>f</code>当成了一个普通的函数对象，并调用了我们编写的模版版本的赋值函数。每复制一次，都相当于将<code>f</code>的函数包了一层。</p><p>要解决这个问题，只要让编译器在这种情况下不要调用我们编写的模版赋值函数，或者说，让我们编写的模版版本的赋值函数只能用于赋值对象为函数类型的情况，这就需要给模版加上<strong>限制</strong>。C++中提供了一种实用的机制：<strong><a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a>(Substitution Failure Is Not An Error)</strong>，“替换失败不是错误”，它是意思就是，当一个模版匹配失败时并不直接报错，而是当它不存在。通过在模版参数列表中加入匹配条件，就可以对模版的适用范围加以限制，将一些重载函数的选项剔除。具体实现这里就不再细说了（要把SFINAE说清楚可能就要一整篇文章了），读者可以自己实现。</p><h4 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h4><ol><li><p><a href="https://shaharmike.com/cpp/naive-std-function/">https://shaharmike.com/cpp/naive-std-function/</a></p></li><li><p><a href="https://shaharmike.com/cpp/lambdas-and-functions/">https://shaharmike.com/cpp/lambdas-and-functions/</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的一些资源记录</title>
      <link href="/code/Graphics-Refs/"/>
      <url>/code/Graphics-Refs/</url>
      
        <content type="html"><![CDATA[<p><s>我还是觉得需要边学边记录点什么，之前看了许多却没有较好地留下记录，而时间久了记忆也是容易遗忘的。笔记的内容均放在了这篇文章里了，以便以后查阅。</s></p><p>由于我发现图形学的东西不太适合分为一个个的独立知识点，要讲清楚一般都到一篇文章的篇幅，因此本文不再作为笔记，而是主要记录一些资源：优秀的教程、博客来源等等，以减少寻找优质资料所耗费的时间；也可以作为一个实用的资料指南针。</p><a id="more"></a><h2 id="general"><a class="markdownIt-Anchor" href="#general"></a> General</h2><ul><li><a href="https://www.scratchapixel.com/">[强烈推荐]Learn Computer Graphics From Scratch!(3D数学、渲染的优质教程)</a></li><li><a href="https://github.com/FancyVin/fun-with-graphics">fun-with-graphics(图形学相关的高校课程、书籍、教程、文章、博客、资源、开源项目)</a></li><li><a href="https://zhuanlan.zhihu.com/p/27158983">[知乎]【书单】图形学科研之路（持续更新）</a></li><li><a href="https://zhuanlan.zhihu.com/p/33898131">[知乎]游戏资源传送门</a></li><li><a href="https://zhuanlan.zhihu.com/p/84550677">[知乎]总结一些TA（技术美术）学习的网站</a></li></ul><h2 id="rendering"><a class="markdownIt-Anchor" href="#rendering"></a> Rendering</h2><h3 id="general-2"><a class="markdownIt-Anchor" href="#general-2"></a> General</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/34207965">《Real-Time Rendering 3rd》提炼总结</a></li></ul><h3 id="rendering-equationpbribl"><a class="markdownIt-Anchor" href="#rendering-equationpbribl"></a> Rendering Equation/PBR/IBL</h3><ul><li>《Realtime rendering 4th》Chapter 9</li><li>[Learn OpenGL上的两篇PBR教程和两篇IBL教程]([<a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/">https://learnopengl-cn.github.io/07 PBR/01 Theory/</a>](<a href="https://learnopengl-cn.github.io/07">https://learnopengl-cn.github.io/07</a> PBR/01 Theory/))</li><li><a href="https://github.com/QianMo/PBR-White-Paper">毛星云整理的&quot;基于物理的渲染（PBR）白皮书&quot;</a></li><li><a href="https://zhuanlan.zhihu.com/p/20091064">[知乎系列]基于物理着色</a></li><li><a href="https://zhuanlan.zhihu.com/p/33630079">[知乎]深入浅出基于物理的渲染一</a>  <a href="https://zhuanlan.zhihu.com/p/35002541">[知乎]深入浅出基于物理的渲染二</a>  <a href="https://zhuanlan.zhihu.com/p/34741174">[知乎]基于物理的环境光渲染一</a>  <a href="https://zhuanlan.zhihu.com/p/41150563">[知乎]基于物理的环境光渲染二</a></li><li><a href="https://zhuanlan.zhihu.com/p/21376124">[知乎]基于物理着色：BRDF</a></li><li><a href="https://zhuanlan.zhihu.com/p/21489591">[知乎]如何看懂这些&quot;该死的&quot;图形学公式</a></li><li><a href="https://zhuanlan.zhihu.com/p/33464301">[知乎]猴子都能看懂的PBR（才怪）</a></li><li><a href="https://zhuanlan.zhihu.com/p/25421091">[知乎]微表面模型－PBR渲染管线的材质</a>  <a href="https://zhuanlan.zhihu.com/p/25539396">[知乎]基于物理的渲染—更精确的微表面分布函数GGX</a></li><li><a href="https://zhuanlan.zhihu.com/p/37639418">[知乎]半小时了解PBR</a></li><li><a href="https://zhuanlan.zhihu.com/p/32209554">[知乎]More DETAILS! PBR的下一个发展在哪里？</a></li><li><a href="https://blog.selfshadow.com/publications/">SIGGRAPH 20xx Course: Physically Based Shading in Theory and Practice(非常丰富的PBR资源)</a></li><li><a href="https://www.cnblogs.com/jerrycg/p/4924761.html">“PBR Step by Step” 还不错的PBR公式推导</a></li></ul><h3 id="ray-tracingpath-tracingxx-tracing"><a class="markdownIt-Anchor" href="#ray-tracingpath-tracingxx-tracing"></a> Ray tracing/Path tracing/XX tracing</h3><ul><li><a href="https://www.pbrt.org/">PBRT</a></li><li><a href="http://aras-p.info/blog/2018/03/28/Daily-Pathtracer-Part-0-Intro/">Daily Pathtracer Part</a></li><li><a href="https://zhuanlan.zhihu.com/p/72673165">[知乎]光线追踪</a></li><li><a href="https://zhuanlan.zhihu.com/p/33614512">[知乎]【PathTracing】实时光线追踪和BSSRDF的那些事</a></li></ul><h3 id="ray-marchingparticipating-media"><a class="markdownIt-Anchor" href="#ray-marchingparticipating-media"></a> Ray marching/Participating media</h3><ul><li>(TBC)</li></ul><h3 id="global-illumination"><a class="markdownIt-Anchor" href="#global-illumination"></a> Global Illumination</h3><ul><li>《Realtime rendering 4th》Chapter 11</li><li><a href="https://www.ea.com/seed/news/seed-siggraph2017-global-illumination">EA-Seed-Siggraph17 “Past, Present and Future Challenges of Global Illumination in Games”</a></li><li><a href="https://zhuanlan.zhihu.com/p/49436452">[知乎系列]球谐光照与PRT学习笔记</a></li><li>(TBC)</li></ul><h3 id="unrealistic-rendering"><a class="markdownIt-Anchor" href="#unrealistic-rendering"></a> Unrealistic Rendering</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/25595069">[知乎]卡通渲染（上）</a>  <a href="https://zhuanlan.zhihu.com/p/25939794">[知乎]卡通渲染（下）</a></li></ul><h3 id="shadows"><a class="markdownIt-Anchor" href="#shadows"></a> Shadows</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/27339998">[知乎]简述47种Shader Map的渲染原理与制作方法</a></li></ul><h3 id="specific-effects"><a class="markdownIt-Anchor" href="#specific-effects"></a> Specific Effects</h3><ul><li>(TBC)</li></ul><h2 id="3d-mathmodelmesh"><a class="markdownIt-Anchor" href="#3d-mathmodelmesh"></a> 3D Math/Model/Mesh</h2><h3 id="transform"><a class="markdownIt-Anchor" href="#transform"></a> Transform</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/26217154">[知乎]全面认识Depth - 这里有关于Depth的一切</a></li></ul><h3 id="implicit-representation"><a class="markdownIt-Anchor" href="#implicit-representation"></a> Implicit Representation</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/26217154">[知乎]Signed Distance Field</a></li></ul><h2 id="procedure-generation"><a class="markdownIt-Anchor" href="#procedure-generation"></a> Procedure Generation</h2><h3 id="pcg-algorithm"><a class="markdownIt-Anchor" href="#pcg-algorithm"></a> PCG Algorithm</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/66416593">[知乎]基于《波函数坍缩算法》的无限城市程序化随机生成</a></li><li><a href="https://zhuanlan.zhihu.com/p/30724817">[知乎]【游必有方】一种 RogueLike 地图生成算法</a></li></ul><h2 id="gpugraphics-api"><a class="markdownIt-Anchor" href="#gpugraphics-api"></a> GPU/Graphics API</h2><h3 id="gpu-hardware"><a class="markdownIt-Anchor" href="#gpu-hardware"></a> GPU Hardware</h3><ul><li><a href="https://www.cnblogs.com/timlly/p/11471507.html">深入GPU硬件架构及运行机制</a></li><li>(TBC)</li></ul><h3 id="opengl"><a class="markdownIt-Anchor" href="#opengl"></a> OpenGL</h3><ul><li><a href="https://learnopengl-cn.github.io/">LaernOpenGL(最良心的OpenGL教程之一)</a></li></ul><h3 id="glslhlslshaderlabxxsl"><a class="markdownIt-Anchor" href="#glslhlslshaderlabxxsl"></a> GLSL/HLSL/Shaderlab/xxSL</h3><ul><li><a href="https://www.shadertoy.com/">Shadertoy</a></li><li><a href="https://github.com/patriciogonzalezvivo/thebookofshaders">The Book of Shaders</a></li><li><a href="https://zhuanlan.zhihu.com/p/33260382">[知乎]Shader中if和for的效率问题以及使用策略</a></li></ul><h2 id="misc"><a class="markdownIt-Anchor" href="#misc"></a> Misc</h2><h3 id="膜dalao"><a class="markdownIt-Anchor" href="#膜dalao"></a> 膜dalao</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/97700605">胡渊鸣——99行代码的《冰雪奇缘》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PBR、IBL与其简单实现</title>
      <link href="/slide/PBR-IBL/"/>
      <url>/slide/PBR-IBL/</url>
      
        <content type="html"><![CDATA[<!-- .slide: data-background="#49B1F5" --><h1 id="pbr与简单ibl"><a class="markdownIt-Anchor" href="#pbr与简单ibl"></a> PBR与简单IBL</h1><p>====</p><!-- .slide: data-background="#2874A6" --><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mo stretchy="false">(</mo><msub><mi>k</mi><mi>d</mi></msub><mfrac><mi>c</mi><mi>π</mi></mfrac><mo>+</mo><msub><mi>k</mi><mi>s</mi></msub><mfrac><mrow><mi>D</mi><mi>F</mi><mi>G</mi></mrow><mrow><mn>4</mn><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega}          (k_d\frac{c}{\pi} + k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})         L_i(p,\omega_i) (n \cdot \omega_i)  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><h5 id="-element-classfragment-"><a class="markdownIt-Anchor" href="#-element-classfragment-"></a> ???<!-- .element: class="fragment" --></h5><p>====</p><p>可见光 = 波长介于400nm ~ 700nm的电磁波</p><p>研究光的理论有<strong>波动光学</strong>和<strong>几何光学</strong>两种。</p><p>渲染的尺度远大于光的波长，也不涉及衍射、干涉、偏振现象，故使用<strong>几何光学</strong>。</p><p>==</p><p>光线沿直线传播（至少在欧式空间中是这样）</p><p>对于真空环境（在CG中，一般就是没有雾的环境），光只在介质交接面上发生<strong>散射</strong>。</p><p>====</p><!-- .slide: data-background="#F0F0F0" --><h4 id="两种基本散射现象"><a class="markdownIt-Anchor" href="#两种基本散射现象"></a> 两种基本散射现象</h4><p><img src="/images/pbr-scattering.png" alt="" /></p><p>==</p><table><thead><tr><th>反射</th><th>折射</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>=</mo><mn>2</mn><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>l</mi><mo stretchy="false">)</mo><mi>n</mi><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">r_i=2(n \cdot l)n-l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>s</mi><mi>i</mi><mi>n</mi><msub><mi>θ</mi><mi>i</mi></msub></mrow><mrow><mi>s</mi><mi>i</mi><mi>n</mi><msub><mi>θ</mi><mi>t</mi></msub></mrow></mfrac><mo>=</mo><mfrac><msub><mi>n</mi><mi>t</mi></msub><msub><mi>n</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{sin\theta_i}{sin\theta_t}=\frac{n_t}{n_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3413079999999997em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.29634285714285713em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1565919999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7114919999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.29634285714285713em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为反射向量，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>是入射方向向量</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>表示入射，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>表示折射，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>为向量与法线的夹角，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>为介质折射率</td></tr></tbody></table><p>反射与折射的比例由**菲涅尔定律（Fresenel equation）**决定。</p><p>====</p><h4 id="反射微平面"><a class="markdownIt-Anchor" href="#反射微平面"></a> 反射微平面</h4><!-- .slide: data-background="#F0F0F0" --><p><img src="/images/pbr-microsurface.png" alt="" /></p><p>==</p><p>现实中的物体不是理想光学平面，可以看做由很多微小的理想平面（称为<strong>微平面</strong>）构成。</p><p>如果微表面的朝向差别较大，反射的像显得粗糙；较小则显得光滑。</p><p>====</p><h4 id="折射"><a class="markdownIt-Anchor" href="#折射"></a> 折射</h4><!-- .slide: data-background="#F0F0F0" --><p><img src="/images/pbr-material-diff.png" alt="" /></p><p>左：金属   |   右：非金属</p><p>折射部分的光线，不同的介质有相差较大的表现。</p><p>==</p><p>在不透明物体与半透明物体中：</p><ul><li><p>金属会直降将折射的光线吸收，转化为其他能量（看不见了）。</p></li><li><p>非金属则使折射光线在其表面之下继续发生多次散射，大部分光重新射出表面。</p></li></ul><p>Notes:</p><p>透明物质由**双向投射分布函数（BTDF）**描述。</p><p>==</p><!-- .slide: data-background="#F0F0F0" --><p><img src="/images/pbr-sss-scale.png" alt="" /></p><p>==</p><p>重新射出表面的光线，其位置分布不同决定了宏观的视觉表现。</p><ul><li>位置在一个渲染像素内，可以认为是同一个点射出，宏观上为<strong>漫反射</strong>。</li><li>位置在一个渲染像素外，宏观上体现为<strong>次表面散射</strong>（半透明）。</li></ul><p>Notes:</p><p>这告诉了我们一个很重要的事实：次表面散射在很远的距离上可以看做是漫反射，而漫反射在很近的距离上可以看做是次表面散射。</p><p>====</p><h4 id="怎么描述反射现象"><a class="markdownIt-Anchor" href="#怎么描述反射现象"></a> 怎么描述反射现象？</h4><ul><li>用仪器测量不同材料的光学性质：<a href="http://www.merl.com/brdf/">MERL</a></li><li>经验模型：Phong、Blinn-Phong</li><li>1981年Cook-Torrance在《A Reflectance Model for Computer Graphics》中引入辐射度学和微表面理论，建立了如今广泛使用的物理模型。</li></ul><p>====</p><!-- .slide: data-background="#CD6155" --><p>这个物理模型也就是以<s>臭名昭著</s>广为人知的渲染方程来表述的：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><msub><mi>f</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) (n \cdot \omega_i ) d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>要明白这个方程，需要先对<strong>辐射度学</strong>有个基本的了解。</p><p>Notes:</p><p>这里的方程准确来说是<strong>反射率方程</strong>，为渲染的一个特化版本。</p><p>==</p><h4 id="辐射通量-phi"><a class="markdownIt-Anchor" href="#辐射通量-phi"></a> 辐射通量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Φ</span></span></span></span></h4><p>Radiant Flux，也称<strong>辐射功率</strong>，单位为瓦特（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>），或焦耳/秒（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">J/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span>）</p><p>指单位时间内通过表面或空间区域的能量总量</p><p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>Q</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\Phi = \frac{dQ}{dt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Φ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">Q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>==</p><h4 id="辐照度-e"><a class="markdownIt-Anchor" href="#辐照度-e"></a> 辐照度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span></h4><p>Irradiance，单位为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mi mathvariant="normal">/</mi><msup><mi>m</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">W/m^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p><p>指单位时间内到达单位面积的辐射通量</p><p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi mathvariant="normal">Φ</mi></mrow><mrow><mi>d</mi><mi>A</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">E =\frac{d\Phi}{dA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">A</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">Φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，式中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">dA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">A</span></span></span></span>表示一个极小的面积</p><p><img src="/images/pbr-irradiance.png" alt="" /></p><p>==</p><h4 id="立体角-omega"><a class="markdownIt-Anchor" href="#立体角-omega"></a> 立体角 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span></h4><p>Solid Angle，单位为<strong>球面度</strong>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">sr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>），可以看做是三维的弧度。</p><p><img src="/images/pbr-solidangle.jpg" alt="" /></p><p>Notes:</p><p>整个球面的立体角为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mi>π</mi></mrow><annotation encoding="application/x-tex">4\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>。</p><p>==</p><h4 id="辐射强度-i"><a class="markdownIt-Anchor" href="#辐射强度-i"></a> 辐射强度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span></h4><p>Radiant Intensity，单位为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">W/sr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，为通过单位立体角的辐射通量</p><p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi mathvariant="normal">Φ</mi></mrow><mrow><mi>d</mi><mi>ω</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">E =\frac{d\Phi}{d\omega}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">Φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，式中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>ω</mi></mrow><annotation encoding="application/x-tex">d\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span>表示一个极小的立体角</p><p>Notes:</p><blockquote><p>之所以引入辐射强度，是因为有时候要度量通过一个点的通量的密度，但因为点的面积是0，无法使用辐照度，所以引入辐射强度。辐射强度不会随距离变化而变化，不像点光源的辐照度会随距离增大而衰减，这是因为立体角不会随距离变化而变化。</p></blockquote><p>==</p><h4 id="辐射率-l"><a class="markdownIt-Anchor" href="#辐射率-l"></a> 辐射率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span></h4><p>Radiance，单位为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msup><mi>m</mi><mn>2</mn></msup><mo>⋅</mo><mi>s</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W/(m^2 \cdot sr)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>，为每单位面积每单位立体角的辐射通量密度</p><p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi mathvariant="normal">Φ</mi></mrow><mrow><mi>d</mi><mi>ω</mi><mi>d</mi><msup><mi>A</mi><mo>⊥</mo></msup></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><mi mathvariant="normal">Φ</mi></mrow><mrow><mi>d</mi><mi>ω</mi><mi>d</mi><mi>A</mi><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">E =\frac{d\Phi}{d\omega dA^{\perp}}=\frac{d\Phi}{d\omega dA cos\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2375279999999997em;vertical-align:-0.3574199999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.64258em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span><span class="mord mathdefault mtight">d</span><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mrel mtight">⊥</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">Φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3574199999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">Φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，式中其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msup><mi>A</mi><mo>⊥</mo></msup></mrow><annotation encoding="application/x-tex">dA^{\perp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">⊥</span></span></span></span></span></span></span></span></span></span></span></span>是微分面积<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">dA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">A</span></span></span></span>在垂直于光线方向上的投影</p><p><img src="/images/pbr-radiance.png" alt="" /></p><p>==</p><p>倾斜时实际投射变小</p><p><img src="/images/pbr-radient.png" alt="" /></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi mathvariant="normal">Φ</mi></mrow><mrow><mi>d</mi><mi>ω</mi><mi>d</mi><msup><mi>A</mi><mo>⊥</mo></msup></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><mi mathvariant="normal">Φ</mi></mrow><mrow><mi>d</mi><mi>ω</mi><mi>d</mi><mi>A</mi><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">E =\frac{d\Phi}{d\omega dA^{\perp}}=\frac{d\Phi}{d\omega dA cos\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2375279999999997em;vertical-align:-0.3574199999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.64258em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span><span class="mord mathdefault mtight">d</span><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mrel mtight">⊥</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">Φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3574199999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">Φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">cos\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>就是光线向量与法线向量的点积。</p><p>====</p><!-- .slide: data-background="#F0F0F0" --><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><msub><mi>f</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) (n \cdot \omega_i ) d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><img src="/images/ibl_hemisphere_sample.png" alt="" /></p><p>Notes:</p><p>积分域<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span></span></span></span>指一个半球。</p><p>方程的结果是辐射率，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">dA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">A</span></span></span></span>趋于无限小后就是点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>，立体角趋于无穷小后就是方向向量。</p><p>这个方程可以理解为在半球法线指向的半球上对很小的立体角<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>做积分，积分的内容是入射光与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">f_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n \cdot \omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的乘积。</p><p>==</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为入射辐射率</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n \cdot \omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>项是因入射光线与平面夹角出现的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">cos\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></li><li>唯一未知的仅剩<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_r(p,\omega_i,\omega_o)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><p>====</p><!-- .slide: data-background="#F0F0F0" --><h3 id="brdf"><a class="markdownIt-Anchor" href="#brdf"></a> BRDF</h3><p>双向反射分布函数，表示出射光和入射光的比例关系，单位为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">sr^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>f</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>θ</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ϕ</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>θ</mi><mi>o</mi></msub><mo separator="true">,</mo><msub><mi>ϕ</mi><mi>o</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_r(p,\omega_i,\omega_o) \rightarrow f_r(p,\theta_i,\phi_i,\theta_o,\phi_o)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><img src="/images/brdf.png" alt="" /></p><p>Notes:</p><p>这里，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">\omega_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别表示入射与出射方向，如果用球坐标可以表示为第二种形式</p><p>==</p><p>Cook-Torrance 提供的BRDF有漫反射和镜面反射两个部分</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>r</mi></msub><mo>=</mo><msub><mi>k</mi><mi>d</mi></msub><msub><mi>f</mi><mrow><mi>l</mi><mi>a</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>k</mi><mi>s</mi></msub><msub><mi>f</mi><mrow><mi>c</mi><mi>o</mi><mi>o</mi><mi>k</mi><mo>−</mo><mi>t</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_r = k_d f_{lambert} +  k_s f_{cook-torrance}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">k_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">k_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为相应系数，在能量守恒的要求下，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>d</mi></msub><mo>+</mo><msub><mi>k</mi><mi>s</mi></msub><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k_d + k_s \le 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>==</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>l</mi><mi>a</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>t</mi></mrow></msub><mo>=</mo><mfrac><mi>c</mi><mi>π</mi></mfrac></mrow><annotation encoding="application/x-tex">f_{lambert} = \frac{c}{\pi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>Lambertian漫反射部分，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>为表面颜色，除<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>是为了标准化（<a href="https://www.cnblogs.com/jerrycg/p/4941359.html">推导</a>）</p><p><img src="/images/brdf-diffuse.png" alt="" /></p><p>Notes:</p><p>目前存在着许多不同类型的模型来实现BRDF的漫反射部分，大多看上去都相当真实，但是相应的运算开销也非常的昂贵。不过按照Epic公司给出的结论，Lambertian漫反射模型已经足够应付大多数实时渲染的用途了。</p><p>==</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>c</mi><mi>o</mi><mi>o</mi><mi>k</mi><mo>−</mo><mi>t</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mi>F</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo><mi>G</mi><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><mrow><mn>4</mn><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">f_{cook-torrance} = \frac{D(h) F(v,h) G(l,v,h)}{4(\omega_o \cdot n)(\omega_i \cdot n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>镜面方式部分，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>为半角向量：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>v</mi></mrow><mrow><mi mathvariant="normal">∥</mi><mi>l</mi><mo>+</mo><mi>v</mi><mi mathvariant="normal">∥</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">h = \frac{l + v}{\|l + v\|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.400108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∥</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mtight">∥</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>分子的三个函数分别为法线分布函数(Normal <strong>D</strong>istribution Function)，菲涅尔方程(<strong>F</strong>resnel Rquation)和几何函数(<strong>G</strong>eometry Function)，分母为归一化项</p><p>==</p><ul><li><strong>法线分布函数</strong>：估算在受到表面粗糙度的影响下，取向方向与中间向量一致的微平面的数量。估算微平面的主要函数。</li><li><strong>几何函数</strong>：描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。</li><li><strong>菲涅尔方程</strong>：描述不同的表面角下表面所反射的光线所占的比率。</li></ul><p>Notes:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">DFG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span></span></span></span>项其实是近似出来的，用3个函数分别表示了某一种特性。</p><p>==</p><!-- .slide: data-background="#F0F0F0" --><h5 id="将整个brdf放入渲染方程"><a class="markdownIt-Anchor" href="#将整个brdf放入渲染方程"></a> 将整个brdf放入渲染方程</h5><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mo stretchy="false">(</mo><msub><mi>k</mi><mi>d</mi></msub><mfrac><mi>c</mi><mi>π</mi></mfrac><mo>+</mo><msub><mi>k</mi><mi>s</mi></msub><mfrac><mrow><mi>D</mi><mi>F</mi><mi>G</mi></mrow><mrow><mn>4</mn><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega}          (k_d\frac{c}{\pi} + k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})         L_i(p,\omega_i) (n \cdot \omega_i)  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>Notes:</p><p>得到这个式子后我们终于可以开始介绍IBL了。</p><p>==</p><p>对于不同的光源类型，采用不同的计算方法：</p><ul><li>直接光源（点光源、方向光）</li><li>IBL</li><li>面光源</li></ul><p>====</p><!-- .slide: data-background="#49B1F5" --><h3 id="ibl"><a class="markdownIt-Anchor" href="#ibl"></a> IBL</h3><p>基于图像的光照（Image Based Lighting），是指光源不是精确定义的光源（如点光源、方向光），而是由环境贴图上的颜色决定。</p><p>环境贴图一般是实景拍摄的HDR图片</p><p>Notes:</p><p>环境贴图有立方体贴图和球形贴图（等距柱状投影图），一般实时渲染选择性能较高的立方体贴图。</p><p>==</p><p><img src="/images/ibl_hdr_radiance.png" alt="" /></p><p>==</p><p>HDRI图像一般是以**等距柱状投影图(Equirectangular Map)**储存的，看起来非常扭曲。</p><p>实时渲染一般使用<strong>立方体贴图（CubeMap）</strong>，因为其采样性能较高。</p><p>因此需要先做一个转换。</p><p>Notes:</p><p>水平视角附近分辨率较高，而底部和顶部方向分辨率较低,在大多数情况下，这是一个不错的折衷方案，因为对于几乎所有渲染器来说，大部分有意义的光照和环境信息都在水平视角附近方向。</p><p>==</p><p>转换方法：渲染一个立方体，将等距柱状图投影到立方体的每个面，并将立方体的六个面的图像构造成立方体贴图。</p><p>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line">in vec3 localPos;</span><br><span class="line"></span><br><span class="line">uniform sampler2D equirectangularMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vec2 invAtan = vec2(<span class="number">0.1591</span>, <span class="number">0.3183</span>);</span><br><span class="line"><span class="function">vec2 <span class="title">SampleSphericalMap</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    vec2 uv = vec2(<span class="built_in">atan</span>(v.z, v.x), <span class="built_in">asin</span>(v.y));</span><br><span class="line">    uv *= invAtan;</span><br><span class="line">    uv += <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">return</span> uv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">    vec2 uv = SampleSphericalMap(normalize(localPos)); <span class="comment">// make sure to normalize localPos</span></span><br><span class="line">    vec3 color = texture(equirectangularMap, uv).rgb;</span><br><span class="line">    </span><br><span class="line">    FragColor = vec4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>====</p><p>通过立方体贴图，每一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>方向上的光源亮度可以从环境贴图上采样得到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>ω</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>C</mi><mi>U</mi><mi>B</mi><mi>E</mi><mo stretchy="false">(</mo><mi>c</mi><mi>u</mi><mi>b</mi><mi>e</mi><mi>m</mi><mi>a</mi><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>p</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(p,\omega) = texCUBE(cubemap, \omega_p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>这里的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>指物体位置，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">\omega_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>是用物体位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>矫正后的立方体贴图采样向量。</p><p>Notes:</p><p>为什么不直接用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：严格来说，渲染方程中的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>为物体上的某一点。然而我们并不可能为每一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>点创建立方体贴图。</p><p>不过可以放弃一些质量以换取合理性能：在场景中创建多个<strong>环境探针</strong>，找出离<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>最近的环境贴图，并用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>点位置与环境贴图位置得到矫正后的采样向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">\omega_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>==</p><p>还记得这个方程吗？</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mo stretchy="false">(</mo><msub><mi>k</mi><mi>d</mi></msub><mfrac><mi>c</mi><mi>π</mi></mfrac><mo>+</mo><msub><mi>k</mi><mi>s</mi></msub><mfrac><mrow><mi>D</mi><mi>F</mi><mi>G</mi></mrow><mrow><mn>4</mn><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega}          (k_d\frac{c}{\pi} + k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})         L_i(p,\omega_i) (n \cdot \omega_i)  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>==</p><p>我们将这个方程的<strong>漫反射项</strong>与<strong>镜面反射项</strong>分开并去掉系数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">漫</mi><mi mathvariant="normal">反</mi><mi mathvariant="normal">射</mi><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mo stretchy="false">(</mo><mfrac><mi>c</mi><mi>π</mi></mfrac><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">漫反射 L_o(p,\omega_o) = \int\limits_{\Omega} (\frac{c}{\pi}) L_i(p,\omega_i) n \cdot \omega_i  d\omega_i </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">漫</span><span class="mord cjk_fallback">反</span><span class="mord cjk_fallback">射</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">镜</mi><mi mathvariant="normal">面</mi><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mo stretchy="false">(</mo><mfrac><mrow><mi>D</mi><mi>F</mi><mi>G</mi></mrow><mrow><mn>4</mn><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">镜面 L_o(p,\omega_o) = \int\limits_{\Omega} (\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}) L_i(p,\omega_i) (n \cdot \omega_i)  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">镜</span><span class="mord cjk_fallback">面</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>====</p><h4 id="漫反射项"><a class="markdownIt-Anchor" href="#漫反射项"></a> 漫反射项</h4><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>c</mi><mi>π</mi></mfrac><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) =  \frac{c}{\pi} \int\limits_{\Omega} L_i(p,\omega_i) (n \cdot \omega_i)  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>由于其brdf只涉及常数项，将常数项提出后，右式的积分中只涉及到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>在环境贴图的中心，剩下的变量仅剩<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>了，我们可以通过<strong>预计算</strong>解决这一部分的计算。</p><p>Notes:</p><p>这里的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>实际上成为了对计算后的贴图采样的参数。</p><p>==</p><p>这样，右边的积分就可以塞进一个立方体贴图中</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>C</mi><mi>U</mi><mi>B</mi><mi>E</mi><mo stretchy="false">(</mo><mi>l</mi><mi>a</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>t</mi><mi>C</mi><mi>u</mi><mi>b</mi><mi>e</mi><mi>m</mi><mi>a</mi><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mrow><mi>o</mi><mi>p</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(p,\omega_o) = texCUBE(lambertCubemap, \omega_{op})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mrow><mi>o</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\omega_{op}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>为以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>点位置与立方体贴图位置得到的出射向量</p><p>====</p><!-- .slide: data-background="#F0F0F0" --><p><img src="/images/ibl_irradiance.png" alt="" /></p><p>预计算得到的辐照贴图</p><p>==</p><p>接下来就是如何得到预计算的这个贴图了</p><p>需要对环境贴图做<strong>卷积</strong>运算</p><p>Notes:</p><p>实际上，计算结果就是环境贴图与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf n \cdot \omega_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbf">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的卷积。</p><p>==</p><!-- .slide: data-background="#F0F0F0" --><p>对半球积分时，我们很难直接处理立体角<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，故可以用球坐标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>θ</mi><mo separator="true">,</mo><mi>ϕ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\theta,\phi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ϕ</span><span class="mclose">)</span></span></span></span>替代</p><p><img src="/images/ibl_spherical_integrate.png" alt="" /></p><p>立体角与球坐标的关系为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub><mo>=</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>d</mi><mi>θ</mi><mi>d</mi><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">d\omega_i = \sin(\theta) d\theta d\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mord mathdefault">d</span><span class="mord mathdefault">ϕ</span></span></span></span>，多出来的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sin(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>是因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>很小时其立体角也相应小些</p><p>==</p><p>得到球坐标下的积分公式</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ϕ</mi><mi>o</mi></msub><mo separator="true">,</mo><msub><mi>θ</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>c</mi><mi>π</mi></mfrac><msubsup><mo>∫</mo><mrow><mi>ϕ</mi><mo>=</mo><mn>0</mn></mrow><mrow><mn>2</mn><mi>π</mi></mrow></msubsup><msubsup><mo>∫</mo><mrow><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>π</mi></mrow></msubsup><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ϕ</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>θ</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>d</mi><mi>ϕ</mi><mi>d</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">L_o(p,\phi_o, \theta_o) = \frac{c}{\pi} \int_{\phi = 0}^{2\pi} \int_{\theta = 0}^{\frac{1}{2}\pi} L_i(p,\phi_i, \theta_i) \cos(\theta) \sin(\theta)  d\phi d\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.7519780000000003em;vertical-align:-1.048058em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5640079999999998em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ϕ</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.048058em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7039200000000003em;"><span style="top:-2.08805em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-4.112900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">ϕ</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span></p><p>==</p><!-- .slide: data-background="#F0F0F0" --><p>数值积分：对立方体贴图的每一个纹素在纹素所代表的方向的半球<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span></span></span></span>内生成固定数量的采样向量，并对采样结果取平均值</p><p>数量固定的采样向量将<strong>均匀地</strong>分布在半球内部</p><p><img src="/images/ibl_hemisphere_sample.png" alt="" /></p><p>Notes:</p><p>当然也可以用蒙特卡洛之类的方法积分</p><p>==</p><p>积分转化为如下<strong>黎曼和</strong>的形式</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ϕ</mi><mi>o</mi></msub><mo separator="true">,</mo><msub><mi>θ</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>c</mi><mi>π</mi></mfrac><mfrac><mn>1</mn><mrow><mi>n</mi><mn>1</mn><mo>⋅</mo><mi>n</mi><mn>2</mn></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>ϕ</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mn>1</mn></mrow></munderover><munderover><mo>∑</mo><mrow><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mn>2</mn></mrow></munderover><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ϕ</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>θ</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>d</mi><mi>ϕ</mi><mi>d</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">L_o(p,\phi_o,\theta_o) = \frac{c}{\pi} \frac{1}{n1 \cdot n2} \sum_{\phi = 0}^{n1} \sum_{\theta = 0}^{n2} L_i(p,\phi_i, \theta_i) \cos(\theta) \sin(\theta)  d\phi d\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.239334em;vertical-align:-1.438221em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.801113em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ϕ</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.438221em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.801113em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">ϕ</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span></p><p>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vec3 irradiance = vec3(<span class="number">0.0</span>);  </span><br><span class="line"></span><br><span class="line">vec3 up    = vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">vec3 right = cross(up, normal);</span><br><span class="line">vec3 up    = cross(normal, right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> sampleDelta = <span class="number">0.025</span>; </span><br><span class="line"><span class="keyword">float</span> nrSamples = <span class="number">0.0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> phi = <span class="number">0.0</span>; phi &lt; <span class="number">2.0</span> * PI; phi += sampleDelta) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">float</span> theta = <span class="number">0.0</span>; theta &lt; <span class="number">0.5</span> * PI; theta += sampleDelta) &#123;</span><br><span class="line">        <span class="comment">// spherical to cartesian (in tangent space)</span></span><br><span class="line">        vec3 tangentSample = vec3(<span class="built_in">sin</span>(theta) * <span class="built_in">cos</span>(phi),  <span class="built_in">sin</span>(theta) * <span class="built_in">sin</span>(phi), <span class="built_in">cos</span>(theta));</span><br><span class="line">        <span class="comment">// tangent space to world</span></span><br><span class="line">        vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; </span><br><span class="line"></span><br><span class="line">        irradiance += texture(environmentMap, sampleVec).rgb * <span class="built_in">cos</span>(theta) * <span class="built_in">sin</span>(theta);</span><br><span class="line">        nrSamples++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">irradiance = PI * irradiance * (<span class="number">1.0</span> / <span class="keyword">float</span>(nrSamples));</span><br></pre></td></tr></table></figure><!-- .element: style="width:100%;" --><p>Notes:</p><p>因为卷积后图像本就很模糊，其分辨率不需要太高</p><p>====</p><h4 id="漫反射ibl实现的总体流程"><a class="markdownIt-Anchor" href="#漫反射ibl实现的总体流程"></a> 漫反射IBL实现的总体流程</h4><ol><li>导入一张HDR环境贴图作为当前的环境立方体贴图</li><li>对环境贴图求卷积，得到新的卷积环境贴图（看起来模糊的环境贴图）</li><li>在PBR Shader中将新卷积贴图作为输入，以法线<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>为采样坐标，获得某一点的漫反射辐照度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span></li><li>PBR公式根据物体表面属性贴图，计算出最终辐射率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span></li></ol><p>==</p><!-- .slide: data-background="#F0F0F0" --><p>最终效果</p><p><img src="/images/lambert_rendering_equation.jpg" alt="" /></p><p>====</p><h4 id="镜面反射项"><a class="markdownIt-Anchor" href="#镜面反射项"></a> 镜面反射项</h4><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mfrac><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo><mi>G</mi><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><mrow><mn>4</mn><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega} \frac{D(h) F(\omega_o,h) G(\omega_i,\omega_o,h)}{4(\omega_o \cdot n)(\omega_i \cdot n)} L_i(p,\omega_i) (n \cdot \omega_i)  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.032456em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>v</mi></mrow><mrow><mi mathvariant="normal">∥</mi><mi>l</mi><mo>+</mo><mi>v</mi><mi mathvariant="normal">∥</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">h = \frac{l + v}{\|l + v\|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.30744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">∥</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其brdf不仅涉及到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，还包含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">\omega_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，也就意味着不能用CubeMap储存</p><p>Notes:</p><p>之前的漫反射项只涉及2个自由度，可以存在2D贴图中；而现在镜面项涉及4个自由度，难以直接保存。</p><p>==</p><p>Epic Games在其Siggraph2012的<a href="https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf">论文</a>中指出可以将积分以<strong>Split Sum</strong>拆解为两个独立的部分</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub><mo>∗</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><msub><mi>f</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega} L_i(p,\omega_i) d\omega_i * \int\limits_{\Omega} f_r(p, \omega_i, \omega_o) n \cdot \omega_i d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>这种近似在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>恒定时是没有误差的，对于大部分环境来说其误差不大</p><p>==</p><p>前一部分积分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\int\limits_{\Omega} L_i(p,\omega_i) d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.855451em;vertical-align:-1.049891em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8055600000000002em;"><span style="top:-2.050109em;margin-left:-0.19445em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.00056em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op" style="margin-right:0.19445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.049891em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的结果称为<strong>预过滤环境贴图（Pre-Filtered Environment Map）</strong></p><p>将不同<strong>粗糙度（Roughness）<strong>下的卷积图以</strong>Mipmap</strong>的形式储存，并插值读取</p><p>==</p><!-- .slide: data-background="#F0F0F0" --><p><img src="/images/ibl_prefilter_map.png" alt="" /></p><p>==</p><p>由于描述粗糙度的**法线分布函数（NDF）**中涉及观察方向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">\omega_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>而前面说到我们不可能在贴图中记录下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">\omega_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>这个额外的维度</p><p>Epic Games做了一个进一步的假设：视线均来自法线方向</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\omega_o = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>==</p><!-- .slide: data-background="#F0F0F0" --><p>这样，积分就不涉及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">\omega_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>但这个假设也使得我们丢失了倾斜角较大时狭长的反射</p><p><img src="/images/ibl_grazing_angles.png" alt="" /></p><p>Notes:</p><p>这一部分近似是IBL实现中偏差最大的近似，但总的来说算是一个合理的取舍</p><p>==</p><p>后一部分积分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mi>f</mi><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mi>f</mi><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mi>c</mi><mi>o</mi><mi>s</mi><msub><mi>θ</mi><mi>i</mi></msub><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\int\limits_{\Omega} f(\omega_i,\omega_o) (n \cdot \omega_i)  d\omega_i = \int\limits_{\Omega} f(\omega_i,\omega_o) cos\theta_i  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.855451em;vertical-align:-1.049891em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8055600000000002em;"><span style="top:-2.050109em;margin-left:-0.19445em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.00056em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op" style="margin-right:0.19445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.049891em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.855451em;vertical-align:-1.049891em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8055600000000002em;"><span style="top:-2.050109em;margin-left:-0.19445em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.00056em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op" style="margin-right:0.19445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.049891em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>这一部分积分的结果相当于假设了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>恒为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>Epic Games发现代入相应公式后整个公式可以化简到只有2个输入（Roughness和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><msub><mi>θ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">cos\theta_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）与2个输出，而这一部分也是同样用预计算解决</p><p>==</p><!-- .slide: data-background="#F0F0F0" --><p>得到如下的<strong>查找图（LUT，Look-up Texture）</strong></p><p><img src="/images/ibl-lut.png" alt="" /></p><p>Notes:</p><p>这个贴图采用的是<em>R16G16</em>格式，需要更多精度</p><p>如何计算由于时间原因，不讲</p><p>==</p><p>最后，将两部分积分合在一起，得到镜面部分结果</p><p>====</p><!-- .slide: data-background="#F0F0F0" --><p>将近似的模型与物理准确的结果对比</p><p><img src="/images/ibl-result-compare.png" alt="" /></p><p>从上到下：Split Sum近似；包含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">n = v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>的近似；事实参考</p><p>====</p><h3 id="the-end"><a class="markdownIt-Anchor" href="#the-end"></a> The End</h3><p>Reference:</p><ul><li><a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance">https://learnopengl.com/PBR/IBL/Diffuse-irradiance</a></li><li><a href="https://blog.selfshadow.com/publications/s2012-shading-course/hoffman/s2012_pbs_physics_math_notebook.pdf">https://blog.selfshadow.com/publications/s2012-shading-course/hoffman/s2012_pbs_physics_math_notebook.pdf</a></li><li><a href="https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf">https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf</a></li><li><a href="http://www.codinglabs.net/article_physically_based_rendering.aspx">http://www.codinglabs.net/article_physically_based_rendering.aspx</a></li><li><a href="https://zhuanlan.zhihu.com/p/33464301">https://zhuanlan.zhihu.com/p/33464301</a></li><li><a href="https://zhuanlan.zhihu.com/p/21376124">https://zhuanlan.zhihu.com/p/21376124</a></li><li><a href="https://www.cnblogs.com/jerrycg/p/4924761.html">https://www.cnblogs.com/jerrycg/p/4924761.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时渲染 </tag>
            
            <tag> PBR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客更新小记</title>
      <link href="/misc/Blog-upgrade/"/>
      <url>/misc/Blog-upgrade/</url>
      
        <content type="html"><![CDATA[<p>折腾了一天终于决定把之前的hexo博客更换为新的主题，也就是现在这个主题。</p><a id="more"></a><p>这也不是我第一次换主题了，起初接触hexo时用的主题是next（<a href="https://github.com/theme-next/hexo-theme-next"><strong>hexo-theme-next</strong></a>），一个十分流行的hexo主题。这个主题还是很不错的，只是我感觉用起来不太习惯，便换掉了。之后使用的是yilia（<a href="https://github.com/litten/hexo-theme-yilia"><strong>hexo-theme-yilia</strong></a>），它给我的第一感觉是简洁美观，只不过有一些小细节我不太满意。准备自己修改一下时，发觉这个项目已经停更很久了，用的还是几年前的构建工具，以致npm在安装相应工具时出现一堆依赖问题，而更新到新工具链意味着要重写很多构建流程，我也就懒得弄了。</p><p>现在用的主题是melody（<a href="https://github.com/Molunerfinn/hexo-theme-melody"><strong>hexo-theme-melody</strong></a>），整体风格整洁大方，简约而不简单，细节方面我也很满意。而且至今（2019.9）作者还在更新，此外作者还记录了主题开发的一些<a href="https://molunerfinn.com/make-a-hexo-theme/">经验</a>，在这里做个小小的安利。</p><p>另一方面，本来我是想给博客弄个域名的，但仔细一想还是算了。一是自从建立博客以来，没有发多少文章，我也没有必要给这个没什么人看到页面付域名费。二是我还没想好用什么域名（对，我最讨厌取名了:）。目前看来用github pages自带域名访问也还不错。</p><p>github pages用来做文字类等数据量不大的页面储存还是不错的，速度上不会有太大问题。这就要说到我在6月底写了一个web版<a href="https://gomocalc.github.io/#/">五子棋小工具</a>。这个页面每次都需要加载一个大约400K的wasm模块，放到github pages上后，首次加载一般要1~2秒，github pages服务器在国外的劣势就体现了出来（对于文章里有高清图片的也是同样的情况）。之后又需求的话我可能会考虑切到国内的CDN上。</p><p>总的来说，这次博客更新解决了之前的一些历史遗留问题，不过一个博客最重要的还是其中的内容，之前这一段时间我并没有将很多东西记录下来，还是比较可惜的。希望接下来，我能够用博客记录下更多的内容。</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>来玩游戏啦！</title>
      <link href="/game/COSE/"/>
      <url>/game/COSE/</url>
      
        <content type="html"><![CDATA[<p>最近游戏开发导论的课设项目，已经圆满结束啦（<s>其实是没时间以及放弃继续了</s></p><p>这里我导出了一个可以在浏览器中直接玩的版本，欢迎体验，以及提bug~</p><p>操作说明：</p><ul><li>WASD 移动</li><li>鼠标 控制射击方向</li><li>鼠标 <strong>左键</strong>射击</li><li>鼠标 <strong>滚轮</strong>切换武器。</li><li>游戏中 <code>Esc 键</code> 退出。</li></ul><a id="more"></a><p><a href="/resource/COSE/index.html"><strong>点击这里试玩</strong></a></p><p>建议把窗口缩放调到<code>50%</code>以获得更好的分辨率~</p><p><em>（主菜单退出按钮有问题，请忽略…）</em></p><h5 id="版本说明"><a class="markdownIt-Anchor" href="#版本说明"></a> 版本说明</h5><p>v2:</p><ul><li>修复了分辨率的问题。</li></ul><p>v3:</p><ul><li>修改了玩家移动方式，现在移动更自然）</li><li>增强了打击感</li></ul><h5 id="开发团队"><a class="markdownIt-Anchor" href="#开发团队"></a> 开发团队</h5><ul><li>段皓彬</li><li>王霖</li><li>曾磊</li></ul><h5 id="资源信息"><a class="markdownIt-Anchor" href="#资源信息"></a> 资源信息</h5><p>大部分资源来源于网络。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>像素艺术入门课程</title>
      <link href="/game/Pixel%20Art%20Course/"/>
      <url>/game/Pixel%20Art%20Course/</url>
      
        <content type="html"><![CDATA[<p>翻译自<a href="http://www.lesforges.org/">Les Forges</a>上<em>Fil Razorback</em>写的像素画课程系列，原教程（法语）可以在<a href="http://www.lesforges.org/article/cours-pixel-art-preface?scroll_to=article">这里</a>找到，在<a href="https://opengameart.org/">OpenGameArt</a>上此系列文章的<a href="https://opengameart.org/content/les-forges-pixel-art-course">英文翻译</a>，本文为该系列教程的中文翻译。</p><p>本文遵循Creative Common条例</p><p>长文预警…</p><a id="more"></a><h2 id="0-前言"><a class="markdownIt-Anchor" href="#0-前言"></a> 0. 前言</h2><p><em>在胡扯之前来一点严肃的内容</em></p><p>尽管像素艺术在今日的视频游戏行业中已经大大地失去了它的重要性，但它仍是独立创作者和小制作十分青睐的媒介。它易于辨别的形态有着打动各种各样玩家的能力，同时又给予了设计师使用各种技巧的机会。</p><p><img src="%5Cimages%5Cowlboy.png" alt="Owlboy (D-Pad Studio) - 像素画的一个例子" /></p><h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>像素艺术有很多种定义，在这里我们只会用一种：完全手工制作的、由创作者掌控每个像素的颜色和位置的图像。显然，在像素画中不能随意地用各种画刷、模糊工具、自动渐变、亦或是各种“现代”软件提供的工具，他们均会产生“拖拉”的颜色。我们只能用一些简单的工具，比如铅笔或“画点”。</p><p>尽管如此，这并不是说像素画或非像素画哪方更优美，只是像素画相比于传统美术作品是完全不同，更贴近于“复古风格”的游戏（如任天堂Super NES或Game Boy系列）。你也可以将这里讲的技巧和非像素画融合在一起，创造一种“混合风格”。</p><h3 id="这篇教程的内容"><a class="markdownIt-Anchor" href="#这篇教程的内容"></a> 这篇教程的内容</h3><p>所以，在这篇文章中你会学到像素画的许多技术，但这并不能让你成为一个艺术家…简单的原因就是——我也不是。我不会教你人体构造学，艺术作品的构成要素，连透视法都只会涉及一点点。在这个教程中，你可以了解到很多像素艺术方面的信息，到了本教程的最后，你应该能够为你的游戏制作相关的任务和景物，只有你有足够的耐心并且持之以恒地按照给定的建议练习。</p><p>此外，我想指出这篇教程中的只有一小部分的图像是被放大了的，对于那些没被放大的图片，我建议你花点时间复制/粘贴，将它们保存下来，这样你便可以更细致地学习。像素画是关于像素的，仅靠远远观看是无法学到它的。</p><p>最后，我要感谢所有参与写作本课程的艺术师们：感谢Pierre Guyot的线稿和各种琐碎的工作，Xenodrogen高超的颜色技术，Lünn关于透视的知识，还有Panda, Poupi, Ahruon, Dyo, Kryon慷慨给予的用于展示的图片。</p><p>现在，让我们准备开始吧！</p><h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3><ul><li>第一节：使用正确的工具</li><li>第二节：直线与曲线</li><li>第三节：透视法</li><li>第四节：光与影</li><li>第五节：调色盘</li><li>第六节：抗锯齿！</li><li>第七节：贴图和抖动</li><li>第八节：瓦块的世界</li></ul><h2 id="第一节-使用正确的工具"><a class="markdownIt-Anchor" href="#第一节-使用正确的工具"></a> 第一节 使用正确的工具</h2><p><em>坏消息：你在本节一个像素都不会画！（不过这不能成为跳过本节的缘由，是吧？）</em></p><p>如果要说一个我不能忍受的谚语，那就会是：</p><blockquote><p>没有不合格的工具，只有不合格的工人。</p></blockquote><p><img src="%5Cimages%5Ccharamaker-apercu.png" alt="Charamaker 1999 - 一个专注于像素画的软件" /></p><p>确实，我认为这句话离真理不能更远了（可能除了“但凡不能杀死你的,最终都会使你更强大”这句），而像素艺术九就是一个很好的证据。本节旨在介绍各种各样用于制作像素画的软件，并帮助你选择正确的软件。</p><h3 id="古老的东西"><a class="markdownIt-Anchor" href="#古老的东西"></a> 古老的东西</h3><p>当你要选择像素画的软件时，你最经常想到的可能是：</p><blockquote><p>为什么要选软件？我觉得Windows自带的<strong>画图</strong>就已经足够了！</p></blockquote><p>错误来了：我之前说了不合格的工具，这就是一个例子。<strong>画图</strong>有且仅有一个好处：你不需要安装，它已经在你的Windows上了；但它的缺点却有一堆，这里有一个没写完的列表：</p><ul><li>你不能同时打开多个文件</li><li>没有调色盘管理</li><li>没有图层和透明度</li><li>没有矩形选择工具（现在好像有了）</li><li>几乎不存在键盘快捷键</li><li>辣鸡的人性化设计</li></ul><p>简而言之，你还是忘了<strong>画图</strong>吧。我们来看点真正的软件。</p><h3 id="终于"><a class="markdownIt-Anchor" href="#终于"></a> 终于…</h3><p>我们常常想的是：</p><blockquote><p>好吧，<strong>画图</strong>对我来说功能太简陋了，我要用<strong>PhotoShop</strong>（或者<strong>PaintShopPro</strong>或<strong>The Gimp</strong>，都是一样的）这种操作更加丰富的软件。</p></blockquote><p>这可能是一个好事，也可能是一个坏事：如果你已经对这几个程序中的一个很熟悉，你可以用它们来做像素画（需要关闭所有带有自动抗锯齿的选项）。如果你还对它们没那么熟悉，尝试学习那些复杂但我们很少用到的功能是一件得不偿失的事。</p><p>一句话，如果你早已习惯它们，自然就可以用，否则最好选择更加适合像素画的软件。</p><h3 id="最佳软件"><a class="markdownIt-Anchor" href="#最佳软件"></a> 最佳软件</h3><p>用于制作像素画的软件比你可能想的要多得多，但我这里只会选几个最佳的出来。他们功能基本一致（调色板管理，预览重复瓦片，透明度，图层，等等等等），其中的区别只在易用度和…价格。</p><h4 id="charamaker-1999"><a class="markdownIt-Anchor" href="#charamaker-1999"></a> Charamaker 1999</h4><p><strong>Charamaker 1999</strong> 对你这种入门画家来说有着巨大的优势：其官方的软件源在很久之前就停止了，所以你可以轻易的在网上随便一个地方下到它。</p><p><img src="%5Cimages%5Ccharamaker.png" alt="Charamaker 1999的界面" /></p><h4 id="graphicsgale"><a class="markdownIt-Anchor" href="#graphicsgale"></a> Graphicsgale</h4><p>对我自己来说，我发现<strong>Graphicsgale</strong>的界面可读性非常好，并且操作方便。然而，它是收费软件（约92￥），这个价钱并不算高。另外，其试用版<strong>几乎</strong>包括了制作游戏图像所必要的功能。试用版唯一缺少的功能是对<code>.gif</code>文件的支持，但这一般不是问题，因为<code>.png</code>文件已经足够了。试用版并没有限制试用时间，因此不失为一个长期可用的选项。</p><blockquote><p>译注：Graphicsgale在2017年已经成为免费软件，你可以在<a href="https://graphicsgale.com/">这里</a>下载到。</p></blockquote><p><img src="%5Cimages%5Cgraphicsgale.png" alt="Graphicsgale的界面" /></p><h4 id="promotion"><a class="markdownIt-Anchor" href="#promotion"></a> Promotion</h4><p>被专业像素艺术家使用的最多的是<strong>Pro-motion</strong>，它相比<strong>Graphicsgale</strong>更加人性化。然而，它很贵！获取完整版大概需要…380￥（目前它在Steam上售价112）。</p><p><img src="%5Cimages%5Cpro-motion.png" alt="Promotion的界面" /></p><p>你可以在 <a href="http://www.cosmigo.com/promotion/">官方网站</a> 下载到试用版。</p><h4 id="pixen"><a class="markdownIt-Anchor" href="#pixen"></a> Pixen</h4><p>让我们别忘了MaxOS用户…<strong>Pixen</strong>是一个和前几款软件类似的开源软件，有着免费的优点，虽然其开发进程很混乱。我没有Mac，所以不能给你详细的介绍，如果你对它感兴趣，可以在<a href="https://github.com/Pixen/Pixen">Github</a>上找到它。</p><blockquote><p>译注：这篇文章是很多年前写的，这么多年过去，Pixen已经不再是开源软件了…你可能需要寻找一些替代品… 而对于Linux用户，可以看看 <em>JDraw</em> 和 <em>GrafX2</em>。</p></blockquote><hr /><p>我建议你将这些软件的试用版都找来用用，看看哪个最适合你，毕竟这主要是口味的不同。要注意的是，一旦你习惯了某个软件，再去更换是比较困难的。</p><h2 id="第二节-直线与曲线"><a class="markdownIt-Anchor" href="#第二节-直线与曲线"></a> 第二节 直线与曲线</h2><p>如果你还不是一个小有成就的艺术家，对你来说开始绘画的最好方式就是拿起一只铅笔，画上线条，直到满意，然后涂上颜色。这对于像素画来说也是一样的：第一步是描绘出图像的轮廓——这一步称作“线稿”。</p><p>线稿是创造像素画的重要一步。你画的图像的某一小块像素可能占到整幅画的很大一部分（非像素画则不然，对那种尺度来说几个像素不足为道），所以几个像素的错误就有可能会使你的人物严重变形。再强调一下，线条准确性十分<strong>重要</strong>。</p><p><img src="%5Cimages%5Csmw2-contours.png" alt="超级马里奥世界 2 - Yoshi's Island (任天堂)" /></p><h3 id="1直线"><a class="markdownIt-Anchor" href="#1直线"></a> 1.直线</h3><p>线稿是由直线和曲线组成的，我们来先谈论直线。如果你上过数学课，你就知道直线可以由它的斜率来描述。斜率是 “y方向的变化” 除以 “x方向的变化”。在这篇教程中，我会用 Y:X 来表示斜率。因此，一条完美的从左下角到右上角的对角线的斜率为 1:1。这里有一张描述斜率关系的图。</p><p><img src="%5Cimages%5Cdroites-parfaites.png" alt="完美的直线" /></p><p>在像素艺术中，使用简单比例的线（0:1, 1:2, 1:1, 2:1, 1:0）被认为是“完美的直线”。它们让你的图片看起来不错，因为人眼可以轻而易举地跟着它们。除了这些之外，你还可以画出在这之间的线，比如只要把1像素长的片段和2像素长的片段交替放置便可以模拟出1.5:1斜率的线（下图）。然而这样画出的线的美感显然不如之前的好。这就是为什么要少用像中间的这种线条。不过不要担心，它们还是有用的，你在之后的章节也会学到如何嵌入它们到你的画中。</p><p><img src="%5Cimages%5Cdroites.png" alt="1.5：1斜率的直线" /></p><h3 id="2曲线"><a class="markdownIt-Anchor" href="#2曲线"></a> 2.曲线</h3><p>只用直线画不了什么有意思的东西，所以让我们来讲讲更加复杂的曲线。曲线不像直线你们简单，好的曲线和不好的曲线差别很大。</p><p>要画出一条平滑的曲线必须遵循一个原则：每个片段的长度必须渐进的变化，并且你要避免不合理的直角。好吧，这其实是两条规则，但第二条其实已经包含在了第一条中。来看一个例子。</p><p><img src="%5Cimages%5Ccourbes.png" alt="好的曲线和失败的曲线" /></p><ul><li>图中绿色的曲线完全遵循了这条规则。从左到右，每个片段的长度为<strong>5 4 3 2 2 1 1 1 2 3 3 3 2 1 1 2 2 1 2 1 2 1 1</strong>。可以看到，相邻片段长度的变化的绝对值都小于等于1（所以肯定不会出现 <strong>5 3</strong> 或 <strong>2 4</strong> 的情况）。也许有时会变化的多一点，但肯定不会是很突然。</li><li>红色的曲线完全背离的这条规则（注意右边出现的直角）。</li></ul><p>一种好的绘制曲线的技巧是先徒手画出线条，然后再回去修改它，直到符合我们的规则为止，这样的话就保证了曲线看起来不会很糟。</p><hr /><p>我用两幅例子来作为本节的结尾。第一幅画是一条龙，它的曲线完全符合之前所述的规则；第二幅画是一把剑，它有一些明显更尖的线条（比如剑的末梢），这告诉我们即使不平滑的线有时也能派上用场。</p><p><img src="%5Cimages%5Clineart-dragon.png" alt="龙的线稿" /></p><p><img src="%5Cimages%5Clineart-epee.png" alt="剑的线稿" /></p><p>我强烈建议你在继续阅读前练习下线条画，你需要它来完成后续的章节。如果你遇到了问题，不管怎样可以尝试一下临摹。</p><h2 id="第三章-透视"><a class="markdownIt-Anchor" href="#第三章-透视"></a> 第三章 透视</h2><p>2D游戏的透视问题一直频繁出现，这也是许多业余游戏出现不协调的地方。本节主要涉及典型RPG游戏的透视问题，所以如果你需要找关于横版或是第一人称的信息，你可能要去别处找找。有一点需要记住的是，透视是关于“将三维空间的物体以我们平时看到的样子展现在平面上的艺术（在这里，平面就是你的屏幕）”。</p><p><img src="%5Cimages%5Cperspectives-apercu.png" alt="塞尔达传说 ~ The Minish Cape (Capcom)" /></p><p>在开始之前，我想先感谢Lunn，没有他这节就无法完成。本节内容其实是我和他对话内容的编辑版本。</p><h3 id="1透视有几种"><a class="markdownIt-Anchor" href="#1透视有几种"></a> 1.透视——有几种?</h3><p>透视不止一种，如果你看过艺术类的书籍或课程，你就知道有1点，2点，3点透视。不过这不是我们要讲的内容，所以你可以先不管它们。=）</p><p>在2D游戏中，最简单的透视被称作“<em><strong>轴测透视</strong></em>”。这个奇怪的名字指的是什么呢？在轴测透视中，物体的三个坐标（X，Y和Z）沿着直线方向<strong>恒定</strong>地增加。这意味着两条在现实中平行的线在轴测透视中也是平行的，而且物体的大小和观察者与其的距离无关。一图胜千言：</p><p><img src="%5Cimages%5Cgrid.jpg" alt="一个轴测透视的例子" /></p><p>轴测透视有无数种角度，因为你可以随便选择三条轴的角度。我们只关注3种最常用的轴测透视：</p><p><img src="%5Cimages%5Cperspectives-1.png" alt="RPG游戏中常见的3种轴测透视" /></p><p>左边的这个叫做<strong>对等轴测投影</strong>：它一般要求Y轴旋转30°，但30°并不适合像素画（前一章解释了为什么），所以我们取而代之的是用1：2的直线来表示（角度这时为26.5651°）。这个视角很适合战术类RPG游戏，因为它能提供可观的深度和广度；但由于它瓦片的形状，它不适合大多数传统的关卡编辑器（比如RPG Maker）。</p><p>（未完待续…）</p>]]></content>
      
      
      <categories>
          
          <category> 游戏美术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 像素游戏 </tag>
            
            <tag> 像素 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于线性采样的高效高斯模糊实现（译）</title>
      <link href="/code/Efficient-Gaussian-blur-with-linear-sampling/"/>
      <url>/code/Efficient-Gaussian-blur-with-linear-sampling/</url>
      
        <content type="html"><![CDATA[<p>高斯模糊是一种柔和模糊的图像效果。模糊后的图像可以被更复杂的算法用来产生形如炫光（bloom）、景深、热浪或者磨砂玻璃的效果。在本文中，我将会讲解如何利用高斯滤波器的种种优良特性来提高实现的效率，和利用贴图查找中双线性插值的特点，来大大提高高斯模糊效率的小技巧。虽然本文讲述的重点是高斯模糊滤波器，但其中大部分原理都可以运用在实时渲染中的其他卷积滤波器上。</p><a id="more"></a><p>**高斯模糊（Gaussian blur）**是图形学中一种常用的技术。不管我们讨论的是离线渲染器还是游戏引擎，许多渲染技术都需要它来产生可信的照片级效果。既然可编程图形管线早已出现，在片段着色器里采用高斯模糊或其他模糊滤波器俨然已经成为每一个游戏引擎必备的技术。</p><p>基础的卷积滤波算法极其消耗性能，然而许多显著降低计算量的优雅技巧，能使高斯模糊即便在老掉牙的硬件上也能流畅运行。这篇文章将会像教程一样，讲解大部分可行的优化技巧。其中一些技巧你可能已经听过，但线性采样（linear sampling）还是能给你一些惊喜。</p><p>让我们先从基础部分开始。</p><h2 id="术语"><a class="markdownIt-Anchor" href="#术语"></a> 术语</h2><p>为了提前消除你可能产生的疑惑，我会从介绍一些本文中出现术语和概念讲起。</p><p><strong>卷积滤波器（Convolution filter）</strong>– 融合一组像素的颜色值的算法</p><p><strong>NxN-tap滤波器（NxN-tap filter）</strong>– 使用NxN个像素的过滤器</p><p><strong>N-tap滤波器（N-tap filter）</strong>– 使用1xN个像素的过滤器。注意一个N-tap滤波器并不意味着它必须要采样N个纹素，它也可以被实现为采样少于N个纹素。</p><p><strong>滤波器核（Filter kernel）</strong>– 一组用来采样的相对坐标、权重集合</p><p><strong>离散采样（Discrete sampling）</strong>– 恰好只读取一个纹素的采样方法（也就是 <code>GL_NEAREST</code> 采样）</p><p><strong>线性采样（Linear sampling）</strong>– 读取2x2个纹素并双线性插值的采样方法（也就是 <code>GL_LINEAR</code> 采样）</p><h2 id="高斯滤波器"><a class="markdownIt-Anchor" href="#高斯滤波器"></a> 高斯滤波器</h2><p>图像空间的高斯滤波器是一个 NxN的卷积滤波器，它的采样权重基于高斯函数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>π</mi><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">G(x,y)=\frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.3013099999999997em;"><span style="top:-3.4534200000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2112714285714286em;"><span style="top:-2.5061857142857145em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9384399999999999em;"><span style="top:-2.93844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.4623857142857144em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.04844em;"><span style="top:-3.04844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.04844em;"><span style="top:-3.04844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49381428571428565em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>滤波器覆盖的像素将乘以一个有高斯函数得来的权重，来达成模糊的效果。高斯滤波器的空间表示（通常被称为“钟型曲线”），展示了每一个覆盖到的像素如果对最终的像素造成影响。</p><p><img src="%5Cimages%5Cgaussian_graph.png" alt="二维高斯函数的图形表示" /></p><p>看到这个你也许会说：“啊哈，所以我们只需要做NxN次贴图读取然后把它们加权求和就OK了”。虽然是这样，它却没看起来那么高效。比如我们有一张大小为1024x1024的图片，然后用片段着色器实现基于这种方法的33x33高斯模糊滤波器，需要多达1024 * 1024 * 33 * 33 ≈ 11.4 亿次贴图读取才能在整张图片上应用这个模糊滤镜。</p><p>为了得到一个更高效的算法，我们需要分析一下高斯函数的一些良好性质：</p><ul><li><p>二维高斯函数可以拆分为两个一维高斯函数计算</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi><msup><mi>σ</mi><mn>2</mn></msup></mrow></msqrt></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><msup><mi>x</mi><mn>2</mn></msup><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">G(x) = \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{x^2}{2\sigma^2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25144em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.154946em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9550540000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.915054em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08494599999999997em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.24644em;"><span style="top:-3.4534200000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1328857142857145em;"><span style="top:-2.5061857142857145em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9384399999999999em;"><span style="top:-2.93844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.04844em;"><span style="top:-3.04844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49381428571428565em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p></li><li><p>一个有着<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mn>2</mn></msqrt><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sqrt2\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;">2</span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>分布的高斯函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mrow><msqrt><mn>2</mn></msqrt><mi>σ</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G_{\sqrt2\sigma}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1332em;vertical-align:-0.38319999999999993em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.4058085em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;">2</span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.38319999999999993em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>等价于两个有着<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>的高斯函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mi>σ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G_{\sigma}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>应用两次（注：原文此处表述有误，该性质的证明见<a href="https://math.stackexchange.com/questions/3159846/what-is-the-resulting-sigma-after-applying-successive-gaussian-blur">此处</a>）</p></li></ul><p>这两个性质给了我们很大的优化空间。</p><p>基于第一个性质，我们可以将二维高斯函数分离为两个一维高斯函数。这意味着片段着色器的实现中，可以把高斯滤波器分为水平方向和垂直方向的滤波器，比如先应用水平方向的滤波器再应用垂直方向的滤波器，仍然可以得到与直接应用二维滤波器相同的结果。所以，我们最后只需要两个1xN滤波器和一次额外的渲染pass。回到我们的例子，在1024x1024大小的图片上应用两次1x33滤波器，我们需要1024 * 1024 * 33 * 2 ≈ 6900万次贴图读取。这个读取量就远远小于之前的方法了。</p><p>第二个性质可以用来绕过在一个pass中只能读取有限次贴图的硬件限制。</p><h2 id="高斯卷积核的权重"><a class="markdownIt-Anchor" href="#高斯卷积核的权重"></a> 高斯卷积核的权重</h2><p>至少在理论上，我们已经看到了怎么高效地实现一个高斯模糊滤波器，但我们还没讨论为了得到最终的结果，滤波器怎么计算每一个像素所占的权重。最显而易见的方式是为不同坐标分布计算高斯函数的值来确定卷积核权重。虽然这是很通用的方法，但我们有一种更方便的计算权重的方法——二项式系数。为什么我们能怎么做？因为高斯函数其实是正态分布函数，而正态分布的离散形式就是采用二项式系数做加权的二项式分布。</p><blockquote><p><img src="%5Cimages%5Cbinomial_coeff2.png" alt="帕斯卡三角形" /></p><p>帕斯卡三角形（杨辉三角）展示了二项式系数，它可以用来计算卷积核权重（每个元素是上一排的两个相邻元素的和）</p></blockquote><p>为了实现我们的9x1水平滤波器和1x9垂直滤波器，我们将用上图帕斯卡三角形的最后一行来计算权重。你可能会问，为什么不用index为8的行（它刚好有9个数字）？这是个可证明的问题，但回答起来却很简单。这是因为在典型的32位颜色缓冲上最边上的系数对最终结果没有任何的影响。我们希望，在提供最佳质量的同时，使贴图读取次数最小化。显然，当我们需要高精度的结果，且有更高精度的颜色缓冲供我们使用时，用index为8的带小数的那行更好一些。但先回到我们原本的想法，使用最后一行…</p><p>有了必要的系数后，计算线性插值需要的权重就很简单了。我们只需将每个系数除以系数的总和（在这里是4096），当然，为了纠正消去最外层四个系数的影响，我们应该将总格减到4070，否则图片在运用几次滤波器后就会变暗许多。</p><p>现在，有了需要的权重，如何实现我们的片段着色器就显而易见了。我们来看看垂直滤波着色器的GLSL代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D image;</span><br><span class="line"></span><br><span class="line">out vec4 FragmentColor;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> offset[<span class="number">5</span>] = <span class="keyword">float</span>[]( <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span> );</span><br><span class="line">uniform <span class="keyword">float</span> weight[<span class="number">5</span>] = <span class="keyword">float</span>[]( <span class="number">0.2270270270</span>, <span class="number">0.1945945946</span>, <span class="number">0.1216216216</span>,</span><br><span class="line">                                   <span class="number">0.0540540541</span>, <span class="number">0.0162162162</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragmentColor = texture2D( image, vec2(gl_FragCoord)/<span class="number">1024.0</span> ) * weight[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        FragmentColor +=</span><br><span class="line">            texture2D( image, ( vec2(gl_FragCoord)+vec2(<span class="number">0.0</span>, offset[i]) )/<span class="number">1024.0</span> )</span><br><span class="line">                * weight[i];</span><br><span class="line">        FragmentColor +=</span><br><span class="line">            texture2D( image, ( vec2(gl_FragCoord)-vec2(<span class="number">0.0</span>, offset[i]) )/<span class="number">1024.0</span> )</span><br><span class="line">                * weight[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然水平滤波器只是将偏移值从应用在Y坐标上改变为应用在X坐标上。注意，在除以1024以得到屏幕空间的坐标时，我们硬编码了图片的大小。在实际应用中，我们可能会用一个uniform替代它，或直接使用不需要归一化纹理坐标的纹理矩形。</p><p>如果你不得不多次应用滤波器来得到更强烈的效果，唯一要注意的事情是在两个帧缓冲间切换，将着色器应用在前一步保存结果的帧缓冲上。</p><blockquote><p><img src="%5Cimages%5Cgaussian1.png" alt="" /></p><p>1x9和9x1的滤波器应用在大小为1024x1024的图片上：原始图片（左边）、应用1次（中间）、应用9次（右边）。</p></blockquote><h2 id="线性采样"><a class="markdownIt-Anchor" href="#线性采样"></a> 线性采样</h2><p>到此为止，我们已经知道怎么实现一个分离两次渲染的高斯滤波器。我们也看到了，在1024x1024 的图片上可以使用这个滤波器九次来得到33x33大小的滤波器的效果，仅仅只需5千6百万次贴图读取。尽管这已经很高效了，它并没能完全利用到GPU的优势，因为这种算法也能毫无修改，完美地运行在CPU上。</p><p>现在，我们已经可以利用GPU提供的固定功能硬件管线来进一步减少贴图读取的次数。为了达到优化的目的，让我们先回顾一下这篇文章开头所作的一个假设。</p><p>到此为止，我们假设了我们必须要做一次贴图读取来获得一个像素的信息，意味着9个像素需要9次贴图读取。尽管这对于在CPU上的实现来说是成立的，但在GPU上却不总是这样。这是因为在GPU上我们能随意地使用双线性插值（bilinear sampling）而没有什么额外的负担。这意味着如果我们不在纹素中心读取贴图，我们就可以得到多个像素的信息。既然我们已经利用了高斯函数的可分离性，实际上是在1D下工作，双线性插值会给我们提供2个像素的信息。每个纹素贡献对颜色的贡献量则由我们使用的坐标决定。</p><p>通过正确地调整贴图读取的坐标偏移我们可以仅通过一次贴图读取得到两个像素或纹素的准确信息。这意味着为了实现一个9x1或1x9的高斯滤波器我们只需要5次贴图读取。总的来说，Nx1或1xN的滤波器我们需要[N/2]次贴图读取。</p><p>这对我们之前为离散样本高斯滤波器使用的权重值有什么意义呢？这意味着每种情况下我们使用单次的贴图读取获得了两个纹素的信息，我们需要用其乘以两个纹素对应的权重和所计算出的新权重。既然我们知道了权重是什么，我们现在只需要计算正确的纹理坐标偏移了。</p><p>我们可以简单地用两个纹素中心点的中间坐标作为纹理坐标。虽然这是一个好的近似，我们并不会使用它——因为我们能计算出更好的坐标，得到与离散采样一模一样的效果。</p><p>对于两个纹素的合并，我们需要调整坐标使<strong>其与纹素#1中心的距离等于纹素#2的权重除以两个权重之和</strong>。同样的，坐标与纹素#2中心的距离应该等于纹素#1的权重除以两个权重之和。</p><p>然后我们就有了计算线性采样高斯滤波的权重和位移公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>L</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>D</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>D</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><msub><mi>t</mi><mi>L</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><msub><mi>t</mi><mi>D</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>⋅</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>D</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><msub><mi>t</mi><mi>D</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>⋅</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>D</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><mrow><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>L</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">weight_L(t_1,t_2)=weight_D(t_1)+weight_D(t_2)\\offset_L(t_1,t_2)=\frac{offset_D(t_1) \cdot weight_D(t_1) + offset_D(t_2) \cdot weight_D(t_2)}{weight_L(t_1,t_2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>为了使用这个信息，我们只需替换uniform常量并减少纵向滤波器shader中迭代的次数，得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D image;</span><br><span class="line"></span><br><span class="line">out vec4 FragmentColor;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> offset[<span class="number">3</span>] = <span class="keyword">float</span>[]( <span class="number">0.0</span>, <span class="number">1.3846153846</span>, <span class="number">3.2307692308</span> );</span><br><span class="line">uniform <span class="keyword">float</span> weight[<span class="number">3</span>] = <span class="keyword">float</span>[]( <span class="number">0.2270270270</span>, <span class="number">0.3162162162</span>, <span class="number">0.0702702703</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragmentColor = texture2D( image, vec2(gl_FragCoord)/<span class="number">1024.0</span> ) * weight[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        FragmentColor +=</span><br><span class="line">            texture2D( image, ( vec2(gl_FragCoord)+vec2(<span class="number">0.0</span>, offset[i]) )/<span class="number">1024.0</span> )</span><br><span class="line">                * weight[i];</span><br><span class="line">        FragmentColor +=</span><br><span class="line">            texture2D( image, ( vec2(gl_FragCoord)-vec2(<span class="number">0.0</span>, offset[i]) )/<span class="number">1024.0</span> )</span><br><span class="line">                * weight[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个简化后的算法是数学正确的，如果不考虑硬件实现的算线性插值可能带来的舍入误差，我们的线性采样shader将得到和离散采样一样的结果。</p><blockquote><p><img src="%5Cimages%5Cside2side.png" alt="" /></p><p>使用9次9x1高斯模糊，分别采用离散采样（左）和线性采样（右）。注意到我们的两种实现甚至在多次pass后仍然没有视觉上的区别。</p></blockquote><p>尽管线性采样的实现非常简单，它仍在高斯模糊滤波器上有显著的视觉效果。考虑到我们设法只用了5次的贴图读取而非9次就实现了一个9x1的滤波器，再回到我们的例子，用33x1大小滤波器模糊一张1024x1024的图片只需 1024 * 1024 * 5 * 3 * 2 ≈ 3100万次纹理读取，而不是离散采样需要的5600万次读取。这是一个合理的区别，为例体现有多大的提升，我做了一些实验来测量两种实现的区别。结果如下：</p><blockquote><p><img src="%5Cimages%5Ccomparison2.png" alt="" /></p><p>使用9x1高斯模糊，分别采用离散采样和线性采样的性能区别。（在Radeon HD5770上测试）纵轴是每秒帧率（越高越好），横轴是模糊的次数（越高越模糊）。</p></blockquote><p>我们可以看到，线性采样实现的高斯模糊的性能比离散采样实现的高了60%，不管对图片模糊了多少次。这与线性采样省下的贴图读取次数大致呈正比。</p><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><p>我们已经了解到实现一个高效的高斯模糊滤波器是十分简单的，尤其是使用线性采样的时候，得到了一个速度极快的实时算法，而它可以作为更高级的渲染技术的基础。</p><p>尽管这篇文章只讨论了高斯模糊，让其中的原理可以应用在绝大多数卷积核类型。除此之外，大多数理论要求我们模糊一张大小缩减的图片，比如光晕效果（bloom）就经常有这个要求。对于大小缩减的图片的情况来说，唯一的区别就是我们的中心像素也是一个“双重像素”。这意味着我们必须用帕斯卡三角形中有着偶数个系数的行，因为我们也想要线性采样中间的纹素。</p><p>我们也简要地介绍了不同实现的计算复杂度，并说明了怎么在GPU上高效地实现滤波器。</p><p>演示不同采样性能差别的示例程序可以在这里下载：</p><blockquote><h3 id="binary-release"><a class="markdownIt-Anchor" href="#binary-release"></a> Binary release</h3><p><strong>Platform:</strong> Windows<br /><strong>Dependency:</strong> OpenGL 3.3 capable graphics driver<br /><strong>Download link:</strong> <a href="http://www.rastergrid.com/blog/wp-content/uploads/2010/09/gaussian_win32.zip">gaussian_win32.zip (2.96MB)</a></p><p><strong>Source code</strong></p><p><strong>Language:</strong> C++<br /><strong>Platform:</strong> cross-platform<br /><strong>Dependency:</strong> GLEW, SFML, GLM<br /><strong>Download link:</strong> <a href="http://www.rastergrid.com/blog/wp-content/uploads/2010/09/gaussian_src.zip">gaussian_src.zip (5.37KB)</a></p></blockquote><hr /><blockquote><p>原作者：Daniel Rákos</p><p>创作时间： September 7, 2010</p><p>发布地址： <a href="http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> bloom </tag>
            
            <tag> 后期处理 </tag>
            
            <tag> GLSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写光栅渲染器的参考资料</title>
      <link href="/code/SoftRendererRefer/"/>
      <url>/code/SoftRendererRefer/</url>
      
        <content type="html"><![CDATA[<p>最近在写一个简单的软件光栅渲染器.<br />光栅化是实时渲染领域的核心，围绕这方面的主题内容也很多。虽然以前了解过一些图形学知识，但这仍是我第一次比较彻底地了解光栅化的各种算法。<br />在学习的过程中搜索到了一些比较好的资料（主要是中文的），这里做一个总结。</p><a id="more"></a><h3 id="综合起步"><a class="markdownIt-Anchor" href="#综合起步"></a> 综合/起步</h3><ul><li><a href="https://www.zhihu.com/question/24786878">如何开始用 C++ 写一个光栅化渲染器？</a></li><li><a href="https://www.zhihu.com/question/33712299">想用C++实现一个软件渲染器，类似DX和OpenGL，除了《3D游戏编程大师技巧》，或者什么网站推荐？</a></li><li><a href="http://blog.csdn.net/zhanghuanzj/article/category/6278922">从零开始写光栅化渲染器</a></li><li><a href="http://blog.csdn.net/cppyin/article/category/780767">从零实现3D图像引擎</a></li><li><a href="http://blog.csdn.net/teajs/article/details/49989681">软件渲染器入门</a></li><li><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/overview-rasterization-algorithm">Rasterization: a Practical Implementation</a></li></ul><h3 id="渲染管线"><a class="markdownIt-Anchor" href="#渲染管线"></a> 渲染管线</h3><ul><li><a href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview">Rendering Pipeline Overview</a></li><li><a href="http://www.cnblogs.com/hjlweilong/p/5995462.html">详解OpenGL中的各种变换（投影变换，模型变换，视图变换）（一）——模型变换和视图变换</a>; <a href="http://www.cnblogs.com/hjlweilong/p/5995466.html">详解OpenGL中的各种变换（投影变换，模型变换，视图变换）（完）——法线变换</a></li><li><a href="https://en.wikipedia.org/wiki/Framebuffer">Framebuffer - Wiki</a></li></ul><h3 id="光栅化"><a class="markdownIt-Anchor" href="#光栅化"></a> 光栅化</h3><ul><li><a href="http://blog.csdn.net/sixdaycoder/article/details/72723330">光栅化之Bresenham绘线算法</a></li><li><a href="http://blog.csdn.net/cbbbc/article/details/51524032">Windows游戏编程大师技巧之三角形填充</a></li><li><a href="https://www.zhihu.com/question/34100482">三角形填充算法的主要实现细节和注意点是什么？</a></li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/cc627092(v=vs.85).aspx">Rasterization Rules</a></li><li><a href="https://blog.csdn.net/seizeF/article/details/92760068">透视正确插值Perspective Correct Interpolation</a></li></ul><h3 id="光照模型"><a class="markdownIt-Anchor" href="#光照模型"></a> 光照模型</h3><ul><li><a href="http://blog.csdn.net/silangquan/article/details/45629299">Shading中的插值技术</a></li><li><a href="http://blog.csdn.net/zxx43/article/details/46755247">光栅化插值方法</a></li><li><a href="https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model">Blinn–Phong shading model - Wiki</a></li><li><a href="http://blog.csdn.net/silangquan/article/details/45629149">局部光照模型及其BRDF</a></li><li><a href="https://www.cnblogs.com/QG-whz/p/5189831.html">[CG编程] 基本光照模型的实现与拓展以及常见光照模型解析</a></li></ul><h3 id="参考项目"><a class="markdownIt-Anchor" href="#参考项目"></a> 参考项目</h3><ul><li><a href="https://github.com/skywind3000/mini3d">mini3d</a> (推荐 - 很适合初学参考)</li><li><a href="https://github.com/wuye9036/SalviaRenderer">SalviaRenderer</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> 光栅化渲染器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
