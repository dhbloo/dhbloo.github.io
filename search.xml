<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>UE4 文件系统</title>
      <link href="/2020/09/07/UE4-FileSystem/"/>
      <url>/2020/09/07/UE4-FileSystem/</url>
      
        <content type="html"><![CDATA[<blockquote><p>整理了一下实习时记录的有关于Unreal Engine 4的文档，共有两篇。</p></blockquote><p>本文主要讲述UE4文件系统的抽象层次结构。</p><a id="more"></a><h3 id="iplatformfile"><a class="markdownIt-Anchor" href="#iplatformfile"></a> IPlatformFile</h3><p>对平台相关的文件操作都抽象在<code>IPlatformFile</code>接口上进行实现。</p><p><img src="/images/ue4-filesystem-classes.jpg" alt="文件系统类图" /></p><p>从上面的类图可以看出文件操作的实现类可以大致分为2类：</p><ul><li><p>具体平台的文件操作的实现均继承在<code>IPhysicalPlatformFile</code>接口下，包括：</p><ul><li><code>FLinuxPlatformFile</code>：Linux平台文件操作</li><li><code>FWindowsPlatformFile</code>：Windows平台文件操作</li><li><code>FHTML5PlatformFile</code>：HTML5文件操作</li><li><code>FAndroidPlatformFile</code>：Android平台文件操作，继承自<code>IAndroidPlatformFile</code>接口</li><li><code>FApplePlatformFile</code>：Mac OS X平台文件操作</li><li><code>FIOSPlatformFile</code>：IOS平台文件操作，继承自<code>FApplePlatformFile</code></li></ul><p>实际编译的时候以上的几个类只有唯一一个对应目标平台的会被编译进程序中。</p></li><li><p>其余有一些对文件操作的包装类（Warpper）也继承自<code>IPlatformFile</code>接口，它们是虚拟在某一底层文件接口上的一层接口，主要是在某一个已有的文件操作接口上实现一些功能的增强、文件访问监控、性能监测等操作。这一种包装体现为对<code>IPlatformFile</code>的<strong>链式引用</strong>（典型的<strong>责任链</strong>设计模式）：</p><ul><li>继承自<code>IPlatformFile</code>的包装子类中均有一个<strong>指向更底层一层的文件操作接口的<code>IPlatformFile*</code>指针</strong>，这个指针在调用<code>Initialize()</code>对文件操作包装类初始化是就需要传入，之后可以用<code>GetLowerLevel()</code>和<code>SetLowerLevel()</code>获取或设置该底层文件操作接口指针。</li><li>实现具体平台文件操作的<code>IPhysicalPlatformFile</code>接口和其子类，由于不可能有比其更底层的文件操作接口（它们自身已经是最低一层），在<code>IPhysicalPlatformFile</code>接口中屏蔽了设置底层<code>IPlatformFile*</code>指针的函数。</li><li>对已有文件操作的增强，主要就体现为：把文件操作请求转发到更低一层文件操作接口的前后插入其特定的一些操作，如对读写数据进行修改，或者将操作的详细情况记录在一个日志中。还可以选择不转发到更低一层，如实现缓存功能时命中缓存的数据可以直接在内存中读取，无需实际访问文件系统。</li></ul><p>这些逻辑接口共包括：</p><ul><li><code>FCachedReadPlatformFile</code>：实现文件的预读取到内存，每次预读64KB的数据为一个缓存块。</li><li><code>FLoggedPlatformFile</code>：实现文件操作的日志记录，会记录下文件操作的类别、操作执行时间等。</li><li><code>FPlatformFileOpenLog</code>：记录文件的打开操作到日志中（编辑器环境下<code>EditorOpenOrder.log</code>；其他环境下<code>GameOpenOrder.log</code>）。</li><li><code>FNetworkPlatformFile</code>：实现对服务器上文件的访问，将服务器上的文件下载到本地进行访问。</li><li><code>FSandBoxPlatformFile</code>：将文件访问转化为沙盒内的文件访问，对于不在沙盒内的文件以只读的形式访问。可以配置沙盒外文件访问禁止名单。</li><li><code>FPakPlatformFile</code>：对Pak文件读取的封装，将Pak文件虚拟为一个文件系统的形式进行访问。</li><li><code>FPlatformFileReadStats</code>：对文件读取速度进行统计，获取读取的每秒字节数。</li><li><code>FProfiledPlatformFile</code>：记录更详细的文件操作时间，如每一次操作的开始时间、处理字节数、操作间隔等。</li></ul></li></ul><p><code>IPlatformFile</code>接口的函数大致有一下几类：</p><ol><li>返回自身的查询信息：如接口名字<code>GetName()</code>、是否应该使用<code>ShouldBeUsed()</code>、是否启用沙盒<code>IsSandboxEnabled()</code>、获取底层文件接口<code>GetLowerLevel()</code></li><li>初始化和参数设置：如<code>Initialize()</code>，会传入底层文件系统和命令行、<code>SetSandboxEnabled()</code>、<code>AddLocalDirectories()</code>等</li><li>文件相关<ol><li>查询：如是否存在<code>FileExists()/DirectoryExists()</code>、文件大小<code>FileSize()</code>、文件属性（只读？<code>IsReadOnly()</code>，修改时间<code>GetTimeStamp()</code>）等</li><li>修改：删除<code>DeleteFile()/DeleteDirectory()</code>、移动文件<code>MoveFile()</code>、复制<code>CopyFile()/CopyDirectoryTree()</code>、创建目录<code>CreateDirectory()</code>等</li><li>打开文件并读写：<code>OpenRead()</code>、<code>OpenReadNoBuffering()</code>、<code>OpenWrite()</code>，返回一个表示文件句柄的<code>IFileHandle*</code>指针。</li><li>遍历文件/目录：采用了访问者模式，有2种方式实现访问者。调用<code>IterateDirectory</code>等一系列函数便可以遍历文件或目录。<ul><li>通过继承<code>FDirectoryStatVisitor</code>并覆盖<code>visit()</code>函数实现遍历逻辑。</li><li>直接将一个函数传入以<code>TFunctionRef&lt;...&gt;</code>的形式传入，适合用于在匿名函数中写遍历逻辑。</li></ul></li><li>其他一些杂项：如异步文件读取接口<code>OpenAsyncRead()</code>，与文件服务器通信<code>SendMessageToServer()</code>、转换路径为绝对路径<code>ConvertToAbsolutePathForExternalAppForRead()</code>等</li></ol></li><li>返回当前实际的物理文件接口的函数<code>GetPlatformPhysical()</code>和<code>GetPhysicalTypeName()</code>，这个函数的根据编译时选择的目标平台的内容选用不同的版本，在编译时确定下来应该返回<code>IPhysicalPlatformFile</code>中的哪个。</li></ol><h3 id="ifilehandle"><a class="markdownIt-Anchor" href="#ifilehandle"></a> IFileHandle</h3><p>在<code>IPlatformFile</code>中，只有对文件的宏观操作而不涉及文件内容的具体读写操作，而对于文件内容的读取与写入的具体接口则定义在了<code>IFileHandle</code>这个接口中。</p><p>每次读取文件前先在<code>IPlatformFile</code>中以文件名打开文件，之后会返回<code>IFileHandle</code>的指针，返回的就是打开文件的句柄，这个句柄记录了读写文件需要的状态（如当前读写位置），通过这个句柄可以对文件内容进行操作。这一层类似C语言中<code>fopen()</code>后返回的<code>FILE*</code>文件指针。</p><p><code>IFileHandle</code>定义了几个低层次的读写操作，如<code>Read()</code>、<code>Write()</code>、<code>Flush()</code>、<code>Seek()</code>、<code>Tell()</code>等，这些函数读写的均是字节缓冲区。</p><p>上面提到的文件操作的包装类，如果要在文件读写内容上做修改，或者有其他的文件读写源，就需要相应地继承<code>IFileHandle</code>，覆盖对应的函数，并在打开文件时返回实现了特定功能的<code>IFileHandle</code>子类。如<code>FCachedReadPlatformFile</code>对应地有<code>FCachedFileHandle</code>；<code>FPakPlatformFile</code>对应地有<code>FPakFileHandle</code>等。</p><h3 id="fplatformfilemanager"><a class="markdownIt-Anchor" href="#fplatformfilemanager"></a> FPlatformFileManager</h3><p>上面提到了很多实现了<code>IPlatformFile</code>的子类，每个涉及到文件读取的地方都可能使用到这些子类中的某一个，因此需要一个类管理这些子类，这个类就是<code>FPlatformFileManager</code>。</p><p>其中最常用的函数是<code>GetPlatformFile()</code>，这个函数返回当前平台的文件接口实例<code>IPlatformFile&amp;</code>，这样只要使用这个函数，就可以获取一个平台无关的文件访问接口。</p><p>此外，如果用到了实现增强功能的文件接口包装类，这个时候文件接口被更上一层的类包装，实际上形成了一个接口调用链。<code>FPlatformFileManager</code>也负责对这个链进行管理，如：</p><ul><li>设置当前最顶层的文件接口<code>SetPlatformFile()</code></li><li>以名字查找链中的某一文件接口<code>FindPlatformFile()</code></li><li>Tick整条链<code>TickActivePlatformFile()</code></li><li>以名字创建新的接口<code>GetPlatformFile()</code>（这个函数也控制了某编译配置下能用哪些接口，如在Shipping模式下不能使用Log文件接口）</li></ul><h5 id="接口的创建"><a class="markdownIt-Anchor" href="#接口的创建"></a> 接口的创建</h5><p>具体使用到哪些文件接口包装类，由程序启动的命令行参数进行控制。</p><p>对文件接口包装类的实际创建在<code>LaunchEngineLoop.cpp</code>中的<code>LaunchCheckForFileOverride()</code>函数与<code>ConditionallyCreateFileWrapper()</code>函数进行。前者按照预先定义好的顺序，调用后者尝试进行创建包装类。后者会从<code>FPlatformFileManager</code>中记载的所有文件接口类中查找到某一个文件包装类，调用其<code>ShouldBeUsed()</code>函数从命令行中获取是否应该启用该包装类的信息，如果启用，则初始化这个文件包装类，让其包装当前的顶层文件接口，并在<code>FPlatformFileManager</code>中更新该信息。</p><p>以上这些文件接口包装类的链式定义顺序是（下一层包装上一层）：</p><ol><li>PakFile；在非编辑器模式下或MONOLITIC模式下默认启用，除非指定<code>NoPak</code>参数</li><li>CachedReadFile ；在PS4与Windows下默认关闭（因为Windows本身自己会预读取），可通过<code>NoCachedReadFile</code>参数和<code>CachedReadFile</code>参数强行关闭或启用</li><li>SandBoxFile；通过<code>-Sandbox=</code>参数指定沙盒路径并启用</li><li>网络文件包装类三选一，优先级：StreamingFile &gt; CookedIterativeFile &gt; NetworkFile（只用于非Shipping构建下）；通过<code>-FileHostIP=</code>参数指定文件Host并启用，Host必须可以访问，不然程序无法启动。</li><li>ProfileFile（只用于非Shipping构建下）；指定<code>ProfileFile</code>参数开启</li><li>SimpleProfileFile（只用于非Shipping构建下）；指定<code>SimpleProfileFile</code>参数开启</li><li>FileReadStats（只用于非Shipping构建下）；指定<code>FileReadStats</code>参数开启</li><li>FileOpenLog（只用于非Shipping构建下）；指定<code>FileOpenLog</code>参数开启</li><li>LogFile；指定<code>FileLog</code>参数开启</li></ol><p>如果考虑加入自定义的文件接口包装类，需要选择在合适的位置加入。上面的顺序可以看出UE4处理的大致顺序是：先做Pak，再做读取性能优化、再做沙盒权限，之后是网络文件，最后是一系列的性能统计与Log记录。</p><h3 id="ifilemanager"><a class="markdownIt-Anchor" href="#ifilemanager"></a> IFileManager</h3><p>由于<code>IPlatformFile</code>接口比较偏底层（其打开文件后返回的文件句柄<code>IFileHandle</code>也是直接读写字节缓冲区的底层接口），不方便使用，<code>IFileManager</code>定义了更高一层的文件接口，实际的实现在<code>FFileManagerGeneric</code>中。</p><p>由于获取平台无关文件接口经常要调用<code>FPlatformFileManager::Get().GetPlatformFile()</code>，显得繁琐，这一层接口直接完成了这一步骤，并将操作转发到获取到的这个接口上，这样就保证了所有操作都是平台无关的。</p><p>在这一层接口上实现了一些更高层的文件操作，更方便调用：</p><ul><li>打开文件是通过<code>CreateFileReader()</code>、<code>CreateFileWriter()</code>这两个函数，它们返回的是对读写操作包装好了的档案类<code>FArchive*</code>，其中实现了一系列的与<code>UObject</code>相关的序列化方法和许多其他类型的序列化方法，更便于保存对象到文件这个经常性操作。序列化操作最后被<code>FArchiveFileReaderGeneric</code>这个继承于<code>FArchive</code>的类转化为对字节缓冲区的操作，再转发到底层文件接口。</li><li>定义了一些常用的，但是底层接口没有提供的文件操作。如递归查找文件<code>FindFiles()</code>、获取文件寿命<code>GetFileAgeSeconds()</code>等。</li><li>增强了一些文件操作：如带进度回调的文件复制<code>Copy()</code>；在操作失败时打印到Log等。</li></ul><p>有了这些接口，操作文件就十分方便了，实际对文件操作时一般只用的到这个类，而不需要调用最底层的<code>IPlatformFile</code>接口。</p><h2 id="平台相关文件接口"><a class="markdownIt-Anchor" href="#平台相关文件接口"></a> 平台相关文件接口</h2><h3 id="fwindowsplatformfile"><a class="markdownIt-Anchor" href="#fwindowsplatformfile"></a> FWindowsPlatformFile</h3><p>Windows平台的文件接口，与之配套的有文件句柄<code>FFileHandleWindows</code>、文件异步读取接口<code>FAsyncBufferedFileReaderWindows</code>等。</p><p>该接口直接采用Windows API实现Windows平台上的文件相关操作，涉及到<code>CreateFileW()</code>、<code>MoveFileW()</code>、<code>DeleteFileW()</code>、<code>GetFileAttributesExW()</code>、<code>GetFileSizeEx()</code>、<code>SetFileTime()</code>、<code>FindFirstFileW()</code>、<code>GetOverlappedResult()</code>、<code>CloseHandle()</code>等。文件句柄中对文件内容的读写涉及到<code>ReadFile()</code>、<code>WriteFile()</code>、<code>FlushFileBuffers()</code>等。文件异步读取接口中涉及到<code>WaitForAsyncRead()</code>等。</p><p>在实现的时候，也需要完成错误检测相关的功能，需要调用<code>GetLastError()</code>；完成文件路径的本地化转换；将UE4中的内建的数据类型，如时间表示转化为Windows平台上的时间表示等。</p><h2 id="逻辑包装文件接口"><a class="markdownIt-Anchor" href="#逻辑包装文件接口"></a> 逻辑包装文件接口</h2><h3 id="fnetworkplatformfile"><a class="markdownIt-Anchor" href="#fnetworkplatformfile"></a> FNetworkPlatformFile</h3><p>该接口实现网络文件的访问。每次需要访问网络文件时，将文件下载到本地，后续按照本地文件进行访问。</p><p>文件的Host地址由启动命令行参数<code>-FileHostIP=</code>指定，可以同时指定多个Host地址，用<code>+</code>分隔。与Host通信可以指定用TCP协议（以<code>tcp://</code>开头）；也可以指定用HTTP协议（以<code>http://</code>），不指定默认使用TCP。</p><p>接口与服务器通信使用了专门定制的协议，这个协议的一部分定义在<code>Runtime/Sockets/Public/NetworkMessage.h</code>下，包括消息类型、通道类型、连接标志（<code>None</code>/<code>Streaming</code>/<code>PreCookedIterative</code>）、消息头格式、默认端口号等。Socket传输均采用的是阻塞操作，直到传输完成或出错才会返回。</p><p>并不是全部路径都使用网络访问，接口内有一个<code>LocalDirectories</code>数组记录哪些目录只以本地的形式访问。默认有一些目录以本地形式访问，如Binaries目录、Intermediate目录、Backup目录、Config目录、Logs目录、Sandboxes目录和所有的DDC目录。接口在每次做相关的文件操作前，先用函数<code>IsInLocalDirectoryUnGuarded()</code>判断一下路径是否应该以本地形式访问，如果是则不会在服务器上获取该路径的文件。</p><p>对于不在<code>LocalDirectories</code>数组中的路径，文件应该从服务器上获取。在涉及到需要访问这些文件的操作时，接口会先从服务器上将文件下载到本地，确保之后能以本地的形式访问，这一步由<code>EnsureFileIsLocal()</code>函数完成。为了知道哪些文件已经被下载过，每个被尝试下载过的路径会加入缓存路径列表<code>CachedLocalFiles</code>中，这样下次就可以直接查询出文件是否已在本地（即使下载失败，也会加入该表，下次不会再尝试下载）。</p><p>对于写入文件的操作，直接在本地文件系统上进行，<strong>不会</strong>写回到服务器上（服务器不需要对文件进行修改）。</p><p>网络文件路径与本地文件路径有一个对应关系，这个对应关系在初始化函数<code>InitializeAfterSetActive()</code>中，与服务器通信后建立。与服务器通信并初始化的过程大致如下：</p><ol><li>接口将平台版本号、游戏名、本地的一系列常用目录路径发送给服务器，包括游戏目录路径（项目目录路径）、引擎路径、插件路径。扩展路径等。</li><li>服务器发送：<ul><li>Cooked Package版本号，用于与本地版本对比。</li><li>4个本地路径对应的服务器目录路径，包括服务器引擎路径、服务器项目路径、服务器引擎扩展路径、服务器项目扩展路径。</li><li>一个服务器文件表<code>ServerFiles</code>，这个表中记录了服务器中的所有文件与文件的时间戳信息。有了这个表后，不需要访问服务器就可以知道服务器上有哪些文件，遍历服务器上的文件路径。</li><li>一个服务器缓存表<code>ServerCachedFiles</code>，这个表中记录了服务器中的所有缓存文件与时间戳信息。（这个表具体含义不明）</li></ul></li><li>将服务器的Cooked Package版本号与本地<code>CookedVersion.txt</code>中的版本号对比，如果服务器的版本未变，则不需要删除任何本地已经缓存的文件。</li><li>否则需要删除本地缓存的过期文件：通过对比服务器缓存表中的时间戳与本地文件的时间戳，将服务器上有更新版本的本地缓存文件删除。此外本地缓存了而服务器缓存表中没有的文件，也需要删除。</li></ol><p>有了对应关系后，就可以把服务器上的文件路径对应到本地文件路径（进行字符串替换即可），<code>ConvertServerFilenameToClientFilename()</code>函数就实现了这个对应操作。</p><p>服务器的文件随时可能更新，接口会实时监测服务器上的更新并让本地的文件保持更新：<code>Tick()</code>中每5秒会调用<code>PerformHeartbeat()</code>与服务器进行心跳沟通，获得一个更新了的文件列表<code>UpdatedFiles</code>，并将本地过期的文件删除（同时删除缓存路径列表<code>CachedLocalFiles</code>中的对应项）。这样，下次访问到更新了的文件时，会重新从服务器下载最新版本。</p><h5 id="fcookediterativenetworkfile"><a class="markdownIt-Anchor" href="#fcookediterativenetworkfile"></a> FCookedIterativeNetworkFile</h5><p>该接口在<code>FNetworkPlatformFile</code>的基础上，多了允许本地PAK文件绕过网络访问的功能。如果在一个迭代流程中，一些PAK文件不会被修改，则它们不需要从服务器上获取，直接用本地版本就可以了，这个接口便是提供了这个功能。</p><p>服务器在初始化时额外返回一个可以本地使用的PAK文件列表<code>ServerValidPakFileFiles</code>，之后访问文件时，如果文件在这些可以直接本地访问的PAK中，就不再需要网络访问，而是直接转发到底层的<code>FPakPlatformFile</code>进行访问。这个判断在<code>ShouldPassToPak()</code>函数中进行。</p><h5 id="fstreamingnetworkplatformfile"><a class="markdownIt-Anchor" href="#fstreamingnetworkplatformfile"></a> FStreamingNetworkPlatformFile</h5><p>这个接口在<code>FNetworkPlatformFile</code>的基础上，实现了真正的流式文件传输。所有对文件的访问、读写操作都被转化为对服务器的访问，通过Socket与实时与服务器通信（除了遍历文件不需要访问服务器，因为初始化时就已经获得了服务器上所有文件的文件表）。这个接口也可以实际修改服务器上的文件。</p><p>每一种文件操作都有一个协议中定义的消息类型与之对应，操作时将消息类型、参数等以协议定义的格式序列化为一个Payload发送给服务器，阻塞等待服务器返回。</p><p>打开文件的<code>OpenRead()</code>、<code>OpenWrite()</code>函数使用<code>SendOpenMessage()</code>通知服务器打开文件，服务器会返回一个文件的句柄ID，后续对该文件的操作以这个句柄ID作为标识。在接口配套定义的<code>FStreamingNetworkFileHandle</code>文件句柄中，<code>Read()</code>、<code>Write()</code>等操作都被转换到对服务器发送消息，分别在<code>SendReadMessage()</code>与<code>SendWriteMessage()</code>中。这样，对文件的读取实时从服务器获得（每次网络传输以64KB的块为单位进行，进行缓存），而对文件的写入则实时发送到服务器。</p><h3 id="fsandboxplatformfile"><a class="markdownIt-Anchor" href="#fsandboxplatformfile"></a> FSandboxPlatformFile</h3><p>该接口实现了一个简单的沙盒机制：将访问的文件路径转换为沙盒内的文件路径进行访问。</p><p>接口的使用者有对沙盒内文件的读写权限，而对于沙盒外的文件默认只有读取权限而没有写入权限。此外，还可以用通配符的方式设置对哪些沙盒外的文件或目录禁止读取权限（也就是读取权限的黑名单）。判断沙盒外文件是否在这个名单内的函数是<code>OkForInnerAccess()</code>；用<code>AddExclusion()</code>函数加入通配符到黑名单中。</p><p>其核心的功能是将文件路径与沙盒内路径进行相互转换，分别通过<code>ConvertToSandboxPath()</code>、<code>ConvertFromSandboxPath()</code>这两个函数进行。其转换逻辑大致如下：</p><ol><li>对于已在沙盒内的文件路径，保持原样</li><li>对于在游戏目录下（即项目目录<code>FPaths::ProjectDir()</code>）的路径，转换为沙盒内的对应路径（<code>沙盒根目录/项目名/...</code>）</li><li>对于根目录下（即<code>FPaths::RootDir()</code>）的路径，转换为沙盒内的对应路径（<code>沙盒根目录/...</code>）</li></ol><p>对于只涉及读取的文件操作，首先会将路径转换为沙盒内路径，尝试以这个路径访问。如果访问失败（文件不在沙盒内），则用<code>OkForInnerAccess()</code>判断该沙盒外的路径是否允许读取，如果是则访问。对于涉及到写入的文件操作，如<code>OpenWrite()</code>、<code>DeleteFile()</code>、<code>MoveFile()</code>、<code>CreateDirectory()</code>等，只以沙盒内的路径进行写入，以确保不会写入到沙盒外部。</p><p>有了路径转换和对写入操作的限制后，沙盒化功能就实现了。沙盒功能的具体开关由<code>bSandboxEnabled</code>变量控制，其可以通过<code>SetSandboxEnabled()</code>来开启或关闭。</p><p>此外该接口还有一些杂项功能，如清除沙盒内全部文件的<code>WipeSandboxFolder()</code>函数，这个函数通过初始化时给接口提供的命令行参数触发（在命令行参数中加入<code>wipe:</code>前缀）。命令行中通过<code>-Sandbox=</code>可以设置沙盒路径，可以是绝对路径/相对路径，也可以是一些常用路径，如<code>User</code>表示用户文件夹下的一个路径<code>用户目录/My Games/UE4</code>、<code>Unique</code>表示以Guid生成一个独一无二的根目录下的随机路径。</p><h3 id="fpakplatformfile"><a class="markdownIt-Anchor" href="#fpakplatformfile"></a> FPakPlatformFile</h3><p>该接口是UE4对PAK文件的读写封装。PAK文件的具体实现在<code>PAKFile</code>类中，<code>FPakPlatformFile</code>将各种对PAK的读取访问操作，最后变为调用<code>PAKFile</code>的实现函数。</p><p>PAK文件挂载后便可以像普通的文件一样访问PAK中的文件，挂载与卸载分别通过<code>Mount()</code>与<code>Unmount()</code>函数进行。挂载除了要提供PAK文件名外，还可以提供挂载路径，可以指定将PAK文件挂载在某个虚拟文件系统的路径下（这样便可以将虚拟目录里的文件分散到多个PAK进行储存了）。支持同时挂载多个PAK，考虑到经常需要挂载一个目录下的所有PAK文件，接口还提供了一个<code>MountAllPakFiles()</code>函数通过通配符批量挂载PAK文件，初始化时便会用该函数从几个常用目录下挂载所有找到的PAK文件夹。</p><p>PAK文件都有一个挂载优先级，优先级决定了若多个PAK文件都含有同一个虚拟路径的文件，应该选用哪个PAK中的文件的问题。PAK文件的挂载优先级可以在<code>Mount()</code>时制定。当用<code>MountAllPakFiles()</code>批量挂载时，挂载优先级由一个硬编码的逻辑决定，为主游戏PAK &gt; 游戏Content PAK &gt; 引擎Content PAK &gt; Saved Dir PAK &gt; 其他PAK。</p><p>挂载优先级同时也是打补丁的重要机制。在UE4中，补丁包PAK文件名规定以<code>_P</code>结尾，并且可以额外附加补丁版本号，如<code>XXX_001_P.pak</code>。在<code>Mount()</code>函数中，如果发现PAK是一个补丁包，便会根据补丁的版本号给优先级加上一个bonus，比如<code>XXX_001_P.pak</code>文件的优先级就会增加(1+1)*100=200。这样就确保了补丁包PAK的优先级永远高于被打补丁的包。</p><p>由于PAK文件只读，不允许对PAK内的文件进行写入，因此使用<code>OpenWrite()</code>打开文件写入时实际上是在往本地文件系统写入。</p><p><code>OpenRead()</code>打开文件读取时，首先用<code>FindFileInPakFiles()</code>函数在所有已挂载的PAK中查找是否有该文件，找到了则返回PAK内的文件句柄；若没找到，还会使用<code>IsNonPakFilenameAllowed()</code>函数查询是否允许通过本地文件系统访问，允许的话，则转发到底层的本地文件系统进行读取。</p><h3 id="fplatformfilereadstats"><a class="markdownIt-Anchor" href="#fplatformfilereadstats"></a> FPlatformFileReadStats</h3><p>该接口实现了统计读取操作的速度的功能，共统计了以下7个指标：</p><ul><li>1 Tick下平均读取速度（MB/s）</li><li>1 Tick下平均每次读取操作的读取大小（KB）</li><li>1 Tick下发起的读取操作总数</li><li>总平均读取速度（MB/s）</li><li>总平均每次读取操作的读取大小（KB）</li><li>总读取大小（MB）</li><li>总读取操作次数</li></ul><p>对读取速度的统计需要在调用底层文件接口的<code>Read()</code>函数前后获取时间，以求出前后的时间差，即操作花费的时间。该功能实现在文件句柄类的子类<code>FPlatformFileReadStatsHandle::Read()</code>函数中。由于需要计算每Tick下的读取速度均值，在<code>Tick()</code>函数中需要清空并更新统计量。</p><p>获取当前平台时间使用了<code>FPlatformTime::Seconds()</code>返回<code>double</code>类型的秒数。当秒数不会过小时（防止除零），计算<code>BytesPerSec</code>每秒读取KB数。更新统计量的时候采用了原子操作，主要是避免多文件句柄同时读取时，多线程更新统计量导致竞争。</p><p>这个包装接口在需要对文件读取速度做性能剖析时使用，不能用于Shipping发布版本。</p><h2 id="qa"><a class="markdownIt-Anchor" href="#qa"></a> Q&amp;A</h2><ol><li><p>NetWorkPlatformFile和本地同名文件的关系？</p><blockquote><p>本地的文件不被考虑，只以服务器文件为准。引擎内存中有一个数组记录了哪些文件在本次运行中被缓存，所有不在这个数组中的文件路径被访问时都会从服务器获取，并<strong>覆盖</strong>原有的本地文件。</p><p>总的来说，所有本次运行所访问到的文件都一定是源自服务器的。</p></blockquote></li><li><p>SandBox的具体作用？什么情况下要用SandBox？</p><blockquote><p>防止引擎对本地文件系统写入。当运行未知来源的游戏文件、或者是不希望游戏对文件系统做任何修改时，用SandBox（我猜的）</p></blockquote></li><li><p>NetWorkPlatformFile和PakPlatformFile的关系？</p><blockquote><p>前者为网络文件层，该层从服务器获取文件。</p><p>后者为PAK文件层，该层从打包好的PAK文件中获取文件。</p></blockquote></li><li><p>文件读取速度的统计方式？</p><blockquote><p>见<code>FPlatformFileReadStats</code>类的描述。</p></blockquote></li></ol><h3 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h3><ol><li><a href="https://zhuanlan.zhihu.com/p/35925797">UE4 文件系统</a></li><li><a href="%5Bhttps://arcecho.github.io/2017/07/02/UE4-Pak-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/%5D(https://arcecho.github.io/2017/07/02/UE4-Pak-%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/)">UE4 Pak 相关知识总结</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4 </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探 UE4 内存分配</title>
      <link href="/2020/09/07/UE4-Memory-Allocation/"/>
      <url>/2020/09/07/UE4-Memory-Allocation/</url>
      
        <content type="html"><![CDATA[<blockquote><p>整理了一下实习时记录的有关于Unreal Engine 4的文档，共有两篇。</p></blockquote><p>本文讲述了UE4内存分配器的抽象层次结构。</p><a id="more"></a><h3 id="大纲"><a class="markdownIt-Anchor" href="#大纲"></a> 大纲</h3><ol><li>内存分配介绍<ol><li>目标</li><li>常用分配方案</li><li>底层分配器介绍</li></ol></li><li>UE4 内存抽象层次<ol><li>平台相关抽象层</li><li>分配器层</li><li>全局用户接口层</li></ol></li></ol><h2 id="内存分配介绍"><a class="markdownIt-Anchor" href="#内存分配介绍"></a> 内存分配介绍</h2><h3 id="内存分配的目标"><a class="markdownIt-Anchor" href="#内存分配的目标"></a> 内存分配的目标</h3><p>《游戏引擎架构》中将影响内存性能的提升点分为两方面：</p><ul><li>调用<code>operator new</code>/<code>malloc</code>的<strong>动态内存分配</strong>开销较大，使用自定制的内存分配器可以避免此开销。</li><li><strong>内存访问模式</strong>会显著地影响一个程序的性能，让数据安排在小的、连续的内存块内可以有效地提高CPU的利用率。</li></ul><p>这里主要谈的是<strong>内存分配</strong>，也就是第一点。</p><h4 id="堆分配"><a class="markdownIt-Anchor" href="#堆分配"></a> 堆分配</h4><p><code>malloc</code>与<code>operator new</code>是C/C++中最低级的内存分配接口，是对操作系统堆分配的封装。既然涉及到操作系统API调用，就也会涉及到用户模式到内核模式的切换，开销很大。虽然一般的实现会自带内存块管理以减少进入内核模式的次数，但这种行为不可控，在实时性很高要求的时候可能带来严重的性能问题。另一方面，底层内存分配的实现以通用性为主，从几KB到几GB都要支持；而如果自己定制的话，就可以利用已有的分配需求，实现更高效的分配算法。</p><h4 id="自定制内存分配的好处"><a class="markdownIt-Anchor" href="#自定制内存分配的好处"></a> 自定制内存分配的好处</h4><ul><li><p>自行维护可用内存，减少切换内核模式的次数。</p></li><li><p>针对特定的使用场景，对分配器的使用模式做出限定，进一步优化。</p></li></ul><h3 id="常用分配方案"><a class="markdownIt-Anchor" href="#常用分配方案"></a> 常用分配方案</h3><ul><li>全局分配：分配的内存在整个游戏启动期间均需要使用。</li><li>栈式分配：分配与回收以相反的顺序进行。</li><li>双端栈式分配：相比栈式分配更好地利用空闲内存。</li><li>池分配：每次分配固定大小的块，便于管理，也减少碎片。</li><li>单帧分配/双缓冲分配：利用游戏中每一帧分配的空间可以在下一帧/下两帧回收的特点，让帧内的临时分配（如异步处理）高效的完成。</li><li>动态分配：对分配和回收的大小和时间没有要求，如<code>malloc</code>和<code>operator new</code>。</li></ul><p>关于这几种分配器和相关的性能评估可见<a href="https://github.com/mtrebi/memory-allocators">memory-allocators</a>。</p><h3 id="底层分配器介绍"><a class="markdownIt-Anchor" href="#底层分配器介绍"></a> 底层分配器介绍</h3><p>在上述的分配方案中，动态分配仍然是最通用的一种。底层动态分配器从操作系统提供的堆空间分配接口（如Linux的<code>brk/sbrk</code>和Windows的<code>HeapAlloc</code>）获得空闲内存并进行管理，最后由<code>malloc</code>或<code>operator new</code>分配给上层的程序。由于底层动态分配器要有足有的通用性，也要解决诸如多线程并发分配、内存碎片等问题，不同的方案最后的综合的性能也各不同。</p><p>通用分配算法并不多，实际常用的有如下几种。</p><h4 id="dlmalloc"><a class="markdownIt-Anchor" href="#dlmalloc"></a> dlmalloc</h4><p>又称<em>Doug Lea’s Malloc</em>，是Doug Lea从1987年开始编写并维护的一个分配器。</p><h4 id="ptmalloc"><a class="markdownIt-Anchor" href="#ptmalloc"></a> ptmalloc</h4><p>全名pthreads malloc，在dlmalloc的基础上加入了对多线程的支持，是目前glibc的malloc实现。</p><p><a href="http://www.malloc.de/en/">Wolfram Gloger’s malloc homepage</a></p><h4 id="jemalloc"><a class="markdownIt-Anchor" href="#jemalloc"></a> jemalloc</h4><p>有着在多线程下高性能、内存碎片少的优点，最早是FreeBSD libc的分配器，目前Facebook采用。</p><p><a href="https://github.com/jemalloc/jemalloc">jemalloc</a></p><h4 id="tcmalloc"><a class="markdownIt-Anchor" href="#tcmalloc"></a> tcmalloc</h4><p>Thread Cache Malloc是由Google为并发程序设计的分配器，其特点是通过per CPU/per thread的缓冲降低多线程分配的竞争，使得并行性能有很高的可扩展性。</p><p><a href="https://github.com/google/tcmalloc">tcmalloc</a></p><h4 id="mimalloc"><a class="markdownIt-Anchor" href="#mimalloc"></a> mimalloc</h4><p>Microsoft的一个较新的分配器，在其benchmark中综合性能超过了上述一众分配器。</p><p><a href="https://github.com/microsoft/mimalloc">mimalloc</a></p><p>更多关于分配器相关的资源可以见<a href="https://github.com/rain-1/awesome-allocators">awesome-allocators</a>。</p><h2 id="ue4-内存抽象层次"><a class="markdownIt-Anchor" href="#ue4-内存抽象层次"></a> UE4 内存抽象层次</h2><p>UE4在内存分配上侧重动态分配的高效性，除了实现上述内存分配的目标，UE4还特别注重了<strong>跨平台</strong>和<strong>易用性</strong>两个方面。</p><p>类似文件系统，UE4的内存相关的操作也是通过多层抽象实现的。为了实现这几个目标，其大致可以分为以下3层：</p><ul><li>平台相关抽象层（<code>FPlatformMamory</code>）</li><li>分配器层（<code>FMalloc</code>）</li><li>全局用户接口层（<code>FMemory</code>）</li></ul><p>它们的顺序也基本上是一个从底层封装到高层的关系。</p><h3 id="平台相关抽象层"><a class="markdownIt-Anchor" href="#平台相关抽象层"></a> 平台相关抽象层</h3><p>UE4为了适配各个不同的平台的内存分配接口，在**硬件抽象层（HAL）**定义了一层平台相关的内存操作接口，即<code>PlatformMemory.h</code>文件。其中定义了一个表示内存相关的接口的类<code>FPlatformMemory</code>，所有操作系统特定和平台特定的内存接口均封装在此类中。</p><p>正如硬件抽象层的其他接口，这些平台通用的逻辑实现在了<code>GeneraicPlatformMemory.h</code>下；而平台特定的接口定义则放在了<code>XXXPlatformMemory.h</code>下。后者中平台特定的类一般直接继承前者中通用的类，以实现功能的扩充。最后通过一个typedef完成在编译时替换平台接口的操作，比如在Windows平台的内存接口文件中的最后一行就有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> FWindowsPlatformMemory FPlatformMemory;</span><br></pre></td></tr></table></figure><p>在此时<code>FPlatformMemory</code>就已经指替为了平台特定的接口实现，后续直接使用即可。</p><blockquote><p>UE4中绝大部分平台无关的接口均是由这种方式实现，由于在不同平台的头文件中有着不同的typedef定义，最后UBT在编译时只需要将合适的头文件include进来就可以了。事实上UE4专门定义了一个宏表示平台头文件的引入。如在<code>PlatformMemory.h</code>文件中就有这一行，通过宏的拼接，根据UBT定义的平台宏将其更换为对应的头文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include COMPILED_PLATFORM_HEADER(PlatformMemory.h)</span><br></pre></td></tr></table></figure></blockquote><p>在<code>GeneraicPlatformMemory.h</code>中，定义了数个与内存相关的类：</p><ul><li><code>FGenericPlatformMemoryConstants</code>：存放描述一个平台内存相关常数的类，常数包括总内存大小、虚拟内存大小、页大小等。更高层的内存分配器可以利用这些信息来调优。</li><li><code>FGenericPlatformMemoryStats</code>：存放描述当前内存使用状况的类，如可用大小、已用大小等。</li><li><code>FSharedMemoryRegion</code>：表示一段共享内存区域。</li><li><code>FBasicVirtualMemoryBlock</code>：表示一个虚拟内存块。</li><li><code>FGenericPlatformMemory</code>：内存相关接口的集合，主要包括：<ul><li>初始化、设置内存池</li><li>处理Out of Memory异常</li><li>获得该平台上的基础分配器</li><li>获取统计信息、内存相关常数，Dump内存和分配器信息</li><li>对虚拟内存页面施加保护</li><li>从操作系统分配对齐的大块内存页面（用于Binned Allocator）</li><li>常规内存内存操作，如<code>Memmove</code>、<code>Memcmp</code>、<code>Memset</code>、<code>Memzero</code>、<code>Memcpy</code></li></ul></li></ul><p>它们基本上最后都会用上面提到的方法定义出实际使用的类，去掉开头的<code>Generaic</code>就是实际类的名字。</p><h3 id="分配器层"><a class="markdownIt-Anchor" href="#分配器层"></a> 分配器层</h3><p>从<code>FPlatformMemory::BaseAllocator()</code>可以获得平台上的基础分配器。分配器均继承自<code>FMalloc</code>。<code>FMalloc</code>可以看做是一切分配器的基类，其定义了分配器的基础接口，包括<code>(Try)Malloc</code>、<code>(Try)Realloc</code>、<code>Free</code>等虚函数。</p><p>分配器从功能上也可以分为几类：</p><ul><li>平台底层分配器：一个平台上最底层的一层分配器，一般是OS上内存相关接口的直接封装。</li><li>功能修饰分配器：在底层分配器的基础上实现一些额外功能，如检测双重释放、检测泄漏、性能统计等等。</li><li>崩溃后备分配器：当遇到Out of Memory而崩溃时，不能再从平台底层分配器中申请内存。此时全局分配器会切换到一个预先分配好的后备分配器，以便完成错误信息收集与汇报等流程。</li></ul><p>按照这种分层，可以比较清楚的看到各类分配器的作用：</p><p><img src="/images/ue4-memory-allocator.png" alt="" /></p><h4 id="平台底层分配器"><a class="markdownIt-Anchor" href="#平台底层分配器"></a> 平台底层分配器</h4><p>目前，可使用的底层分配器定义在如下的枚举中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EMemoryAllocatorToUse</span><br><span class="line">&#123;</span><br><span class="line">Ansi, <span class="comment">// Default C allocator</span></span><br><span class="line">Stomp, <span class="comment">// Allocator to check for memory stomping</span></span><br><span class="line">TBB, <span class="comment">// Thread Building Blocks malloc</span></span><br><span class="line">Jemalloc, <span class="comment">// Linux/FreeBSD malloc</span></span><br><span class="line">Binned, <span class="comment">// Older binned malloc</span></span><br><span class="line">Binned2, <span class="comment">// Newer binned malloc</span></span><br><span class="line">Binned3, <span class="comment">// Newer VM-based binned malloc, 64 bit only</span></span><br><span class="line">Platform, <span class="comment">// Custom platform specific allocator</span></span><br><span class="line">Mimalloc, <span class="comment">// mimalloc</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>底层分配器的创建在每个平台自己的<code>FXXXPlatformMemory::BaseAllocator()</code>函数下创建，默认具体创建哪一个根据编译选项决定。各种平台下可以使用的分配器：</p><table><thead><tr><th>平台</th><th>可以使用的分配器</th><th>默认分配器（64Bits，游戏构建）</th></tr></thead><tbody><tr><td>Windows</td><td>Ansi/TBB/Mimalloc/Binned3/Binned2/Binned/Stomp</td><td>Binned2</td></tr><tr><td>Unix/Linux</td><td>Ansi/Binned2/Binned/Stomp</td><td>Binned2</td></tr><tr><td>Mac</td><td>Ansi/TBB/Binned2/Binned/Stomp</td><td>Binned2</td></tr><tr><td>IOS</td><td>Ansi/Binned2/Binned</td><td>Binned</td></tr><tr><td>Android</td><td>Binned3/Binned2/Binned</td><td>Binned2</td></tr></tbody></table><p>在桌面端平台下，也可以通过启动命令行参数覆盖默认选择，如<code>-stompmalloc</code>就是使用Stomp分配器。</p><p>下面详细介绍每一种底层分配器。</p><h5 id="fmallocansi"><a class="markdownIt-Anchor" href="#fmallocansi"></a> FMallocAnsi</h5><p>实际分配使用C语言标准库<code>malloc</code>/<code>realloc</code>/<code>free</code>函数，FMallocAnsi通过分配一点额外空间来处理对齐问题。</p><p>解决对齐的做法和《游戏引擎架构》6.2.1.3中提到的一样：额外分配一个Alignment大小的空间，此外还有一个<code>void*</code>大小的指针记录实际从<code>malloc</code>取得的地址，和<code>SIZE_T</code>大小的变量表示分配大小以通过指针供反查询分配空间大小。在归还内存时，便可以通过对齐的指针反向查询出malloc原本返回的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* originPtr = *((<span class="keyword">void</span>**)((uint8*)Ptr - <span class="keyword">sizeof</span>(<span class="keyword">void</span>*)));</span><br><span class="line"><span class="built_in">free</span>(originPtr);</span><br></pre></td></tr></table></figure><p>其内存布局大致如下：</p><p><img src="/images/AnsiMalloc.png" alt="" /></p><h5 id="fmallocbinned2"><a class="markdownIt-Anchor" href="#fmallocbinned2"></a> FMallocBinned2</h5><p>在游戏引擎中，经常需要分配很多很小块的内存（几十bytes到几百bytes之间）。这些内存被频繁地分配释放，很容易导致大量的碎片问题，而UE4中的Binned Malloc就是为了解决内存碎片引发的性能问题。由于OS已经通过虚拟内存分页管理的方式解决了以页为单位的碎片，那么UE4就只需要解决小对象的分配就行了。</p><p>Binned的意思是“分箱”，意思是将小块的内存装在一个大箱中，便于管理。比如一个对象的大小是86 bytes，在实际分配时并不一定就按这个大小进行分配，而是将其放在一个比其大小稍大的箱子中，比如96 bytes的箱子。“分箱”的好处是减少了可能的分配大小数量，不需要再去考虑各种大小，只需要考虑几个预先确定下来的箱子大小。固定大小的另一个好处是非常便于用<strong>内存池</strong>的方式管理，进一步解决了碎片问题；此外也增加了内存复用，减少了调用OS内存分配这个较慢的操作。</p><p>箱子大小的确定是一个比较有技巧的事情，如果选择的不合适会导致内存空间的浪费过多。在<code>FMallocBinned2</code>中的<code>SmallPoolTables</code>表就记录了各种预先定义的箱大小，在分配一个特定大小的内存块时，会找一个与其最接近的箱子。箱子大小应该是分页大小的偶数因子，也需要让其做到16 bytes对齐，保证任何对齐要求都能被满足。目前箱子的大小共划分了45个档位：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> uint16 SmallBlockSizes[<span class="number">45</span>] =</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">16</span>, <span class="number">32</span>, <span class="number">48</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">96</span>, <span class="number">112</span>, <span class="number">128</span>,</span><br><span class="line"><span class="number">160</span>, <span class="number">192</span>, <span class="number">224</span>, <span class="number">256</span>, <span class="number">288</span>, <span class="number">320</span>, <span class="number">384</span>, <span class="number">448</span>,</span><br><span class="line"><span class="number">512</span>, <span class="number">576</span>, <span class="number">640</span>, <span class="number">704</span>, <span class="number">768</span>, <span class="number">896</span>, <span class="number">1024</span> - <span class="number">16</span>, <span class="number">1168</span>,</span><br><span class="line"><span class="number">1360</span>, <span class="number">1632</span>, <span class="number">2048</span> - <span class="number">16</span>, <span class="number">2336</span>, <span class="number">2720</span>, <span class="number">3264</span>, <span class="number">4096</span> - <span class="number">16</span>, <span class="number">4368</span>,</span><br><span class="line"><span class="number">4672</span>, <span class="number">5040</span>, <span class="number">5456</span>, <span class="number">5952</span>, <span class="number">6544</span> - <span class="number">16</span>, <span class="number">7280</span>, <span class="number">8192</span> - <span class="number">16</span>, <span class="number">9360</span>,</span><br><span class="line"><span class="number">10912</span>, <span class="number">13104</span>, <span class="number">16384</span> - <span class="number">16</span>, <span class="number">21840</span>, <span class="number">32768</span> - <span class="number">16</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最低一档为16 bytes，最高一档为32768 - 16 bytes，只要分配大小小于最高一档，就采用这种分箱的分配方法。在分配时为了尽快找到最接近的大小档位，预先建立了一个查找表，并在<code>BoundSizeToPoolIndex()</code>中根据分配大小转换到箱大小。注意到其中有一些项减去了16，目的主要是预留额外空间，让块的地址满足对齐要求。</p><p>分配器对于箱内存的管理采用了内存池的方式，每一种箱大小对应一个内存池列表，而一个内存池实际上对应到一个逻辑页表。<strong>逻辑页表</strong>是Binned Malloc2分配器自己定义了一个内存单位，由多个连续的OS页表组成。目前一个逻辑页表的大小为64KB，在Windows下一个OS页表为4KB，也就是一个逻辑页表由16个连续的OS页表组成。</p><p>在每个内存池（逻辑页表）内，空间被分为以块为单位，每块的大小就是这个内存池的箱大小，其中的空闲块称作FreeBlock。在划分块的适合尽量要让多出来的剩余空间较小，这也是为什么前面在内存池分块时大小选定为分页大小的偶数因子。</p><p>内存池中空闲块的管理采用Free List方法，也就是链表结构，这里free的意思指链表的实际节点就储存在空闲块内部（类似intrusive list）。每当需要分配的时候就从链表头取出一个节点，释放时再挂回去。链表的节点由<code>FFreeBlock</code>描述，一个节点不一定只表示一个独立的块，而是可以直接表示多个连续的块。这样，在初始化时只需要处理一个节点即可。若一个<code>FFreeBlock</code>中有多个块，单个块的分配是从后往前分配的；而如果<code>FFreeBlock</code>只有一个块，就直接进行分配。</p><p>一个内存池的布局大致如下图所示：</p><p><img src="/images/BinnedMalloc2-Pool.png" alt="" /></p><p>在Binned Malloc2，从最上层的内存池列表到最下层的FreeBlock的管理，涉及到了几个结构：</p><ul><li><p>FFreeBlock：空闲块链表节点，大小刚好为16 bytes（最小的一个箱大小）。其中记录了该块大小、在内存池中的序号、魔数（检验内存完整性）、此处连续的空闲块的块数，最重要的还是指向下一个<code>FFreeBlock</code>的指针，以将池中的所有空闲块链起来。</p></li><li><p>FPoolInfo：描述一个内存池的信息，其中<code>FirstFreeblock</code>指向第一个<code>FFreeBlock</code>节点。不同的内存池之间形成双向链表。</p></li><li><p>FPoolList：管理由<code>FPoolInfo</code>组成的内存池信息列表。</p></li><li><p>FPoolTable：存放一种箱大小的<code>FPoolList</code>，由于之前分了45档，<code>FPoolTable</code>也一共有45个。<code>FPoolTable</code>中将内存池分为活跃和非活跃的两种，对应到<code>ActivePools</code>和<code>ExhaustedPools</code>两种内存池列表。一旦一个内存池的块全部分配完毕，就认为其是非活跃的；而活跃的内存池一定是有非分配的空闲块的。活跃的内存池的已分配块全部清空后，可以将该内存池空间归还。</p></li></ul><p>由于以上的结构为全局结构，在实际操作时需要加锁，多线程性能较差。为了并发分配的问题，Binned Malloc2还设置了一种<strong>线程局部块列表缓存</strong><code>FPerThreadFreeBlockLists</code>，但线程归还某个块时，并不是直接还给内存池，而是先挂在这个缓存的块列表中。该缓存通过**TLS（Thread Loacl Storage）**实现，保证线程安全性。当缓存中的块数超过一个包（<code>FBundle</code>）的大小时，再批量地将这些块还给内存池。</p><p>当分配大小大于最大的箱大小时，会走另一条分配途径，直接从OS中分配连续的虚拟内存页面，具体的过程就不细说了。</p><p>此外，UE4还对OS分配的页表做了缓存（<code>FCachedOSPageAllocator</code>）。</p><p>整个Binned Malloc的实现，和Jemalloc、Mimalloc中的分配算法处理有不少相似之处。</p><p>一些更详细的介绍可以参考<a href="https://zhuanlan.zhihu.com/p/79715624">这篇文章</a>。</p><h5 id="fmallocbinned"><a class="markdownIt-Anchor" href="#fmallocbinned"></a> FMallocBinned</h5><p>Binned Malloc是Binned Malloc 2的上一代版本，目前默认只有IOS使用。</p><p>分配的思路和Binned Malloc 2相差不多，也是采用分箱和池的思想。按照分配的大小，共有4条分配路径：</p><ol><li><p>Size &lt;= SMALL_BLOCK_POOL_SIZE (256B)</p><p>IOS由于其硬件的内存较小，系统的分配器采用一些特殊的处理，将内存分配按大小分为nano、tiny、small、large几种类型，申请时按需进行最适分配。</p><p><img src="/images/IOS-malloc.png" alt="" /></p><p>在64位的IOS系统分配器中，对于小于256 bytes的分配会优先考虑nano分配。而在Binned Malloc中，也考虑了这一点，对于小于<code>SMALL_BLOCK_POOL_SIZE</code>的分配大小（在IOS下<code>SMALL_BLOCK_POOL_SIZE</code>为256），会导向<code>SmallOSAlloc</code>分配路径，最后直接从系统的<code>malloc</code>中进行分配，也就是IOS的nano分配。至于nano malloc区的实际空间有多大，是在<code>FMallocBinned</code>的构造函数中试出来的：首先通过分配一块极小的内存得知nano区域的位置，然后再循环尝试获取nano的全部空间，统计出其大小。由于nano区域的地址是确定的，在free时可以判断指针是否来自nano区域，从而正确地归还给nano malloc。</p></li><li><p>Size &lt;= BinnedSizeLimit (32KB)</p><p>根据分配大小找到最接近的箱大小，从内存池中取出一个箱子的空间用于分配，和Binned Malloc 2类似。这里的池的个数只有42种。</p></li><li><p>Size &gt; BinnedSizeLimit &amp;&amp; Size &lt;= <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mn>3</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{3}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> BinnedSizeLimit || Size &gt;  PageSize &lt;= PageSize + BinnedSizeLimit</p><p>根据大小在两个有较大的块的池中选择进行分配，过程和2中的类似。</p></li><li><p>其他情况</p><p>对齐后直接调用OS的分配。</p></li></ol><h5 id="fmallocbinned3"><a class="markdownIt-Anchor" href="#fmallocbinned3"></a> FMallocBinned3</h5><p>为Binned Malloc 2的升级版本，其使用了PlatformMemory中提供的新接口，通过直接操作OS的虚拟地址，使得内存池索引和管理能够更高效地进行。</p><p>比如其先进行虚拟内存的保留，等到实际使用时才真正进行页面分配。</p><p>目前Binned Malloc 3只在Windows和Android上支持。</p><blockquote><p>据称Epic在Fortnite中通过切换到Binned Malloc 3，将内存占用减少了几十MB。</p></blockquote><h5 id="fmalloctbb"><a class="markdownIt-Anchor" href="#fmalloctbb"></a> FMallocTBB</h5><p>使用<a href="https://software.intel.com/content/www/us/en/develop/tools/threading-building-blocks.html">Intel® Threading Building Blocks</a>的分配器实现。</p><p>TBB分配器提供扩展性好的并行内存分配，防止多线程伪共享问题。</p><h5 id="fmallocjemalloc"><a class="markdownIt-Anchor" href="#fmallocjemalloc"></a> FMallocJemalloc</h5><p>使用<a href="http://jemalloc.net/">Jemalloc</a>分配器实现。</p><h5 id="fmallocmimalloc"><a class="markdownIt-Anchor" href="#fmallocmimalloc"></a> FMallocMimalloc</h5><p>使用<a href="https://microsoft.github.io/mimalloc/">Mimalloc</a>分配器实现。Mimalloc是目前benchmark中最好的分配器实现，该分配器在2020年1月加入到UE4中。</p><h5 id="fmallocstomp"><a class="markdownIt-Anchor" href="#fmallocstomp"></a> FMallocStomp</h5><p>缓冲区溢出检测分配器，可以用于发现如下的bug：</p><ul><li>在分配区域的尾部之后读写</li><li>在分配区域的头部之前读写</li><li>在释放区域后读写（Windows下）</li></ul><p>检测的方式是额外分配一个虚拟内存页面，并设置该页面的保护属性为不可访问，当写溢出时会触发操作系统保护。</p><p>Windows平台能够实现只分配虚拟地址而不分配物理地址的功能，可以用于保留已经分配过的虚拟地址，检测在释放后的读写操作。这种方式的副作用是造成OS页表项的大量分配。</p><blockquote><p>Windows页表项使用VAD Trees管理，页表项只是描述这个页的信息，而实际的页不一定进行了分配。只要Windows在页表中保留了描述某个页范围的项，这个范围内的页就不会被分配给其他人。</p><p>详情见<a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">Win32 API - VirtualAlloc</a></p></blockquote><h4 id="功能修饰分配器"><a class="markdownIt-Anchor" href="#功能修饰分配器"></a> 功能修饰分配器</h4><p>这类分配器只是在已有分配器的一层包装，依赖于已有的分配器（在构造时需要传入原分配器指针），以实现一些额外功能。功能主要为一系列相关检测、性能统计、线程安全等。</p><blockquote><p>这里又用到了责任链设计模式</p></blockquote><ul><li><p><code>FMallocVerify</code>：检验内存指针有效性，即检测释放时还给分配器的指针是不是真的分配过。</p></li><li><p><code>FMallocLeakDetectionProxy</code>：实际上为<code>FMallocLeakDetection</code>的代理，检测内存泄漏。</p><p>为了定位泄漏的地点，其内部采用了作用域记录的方式，用户代码配合<code>MALLOCLEAK_SCOPED_CONTEXT(Context)</code>和<code>MALLOCLEAK_WHITELIST_SCOPE()</code>这两个宏来自定义作用域，以便于记录分配的作用域，更准确地定位泄漏位置。</p></li><li><p><code>FMallocPoisonProxy</code>：“毒化”内存，即在分配后空间填充特殊字节<code>0xcd</code>，回收后空间填充<code>0xdd</code>。一些变量未初始化的问题可以比较明显地体现出来。</p></li><li><p><code>FMallocDoubleFreeFinder</code>：检测指针被释放两次的问题。</p></li><li><p><code>FMallocThreadSafeProxy</code>：给内存各种操作上锁，使其变为线程安全的。</p></li><li><p><code>FMallocReplayProxy</code>：将所有的内存分配操作记录下来，记录在磁盘文件中，以便后续回放（可以用来比较不同的底层分配器实现）。</p><p>目前只有Linux开启了该功能。</p></li><li><p><code>FMallocPurgatoryProxy</code>：类似<code>FMallocStomp</code>检测已释放内存被写入的功能，但可适用于所有平台。</p><p>实际上是将内存释放推迟了几帧，并在真正释放时检测是否修改过其中的内容。</p></li><li><p><code>FStatsMallocProfilerProxy</code>：统计内存分配操作到线程统计信息中。</p></li><li><p><code>FMallocProfiler</code>：内存分配性能剖析，将内存分配信息记录到文件中以供后续分析。</p></li></ul><h4 id="崩溃后备分配器"><a class="markdownIt-Anchor" href="#崩溃后备分配器"></a> 崩溃后备分配器</h4><p>在<code>PlatformMallocCrash.h</code>中，定义了<code>FPlatformMallocCrash</code>类用于处理崩溃时的内存分配。根据编译选项，其相当于以下两个类中的一个：</p><ul><li><code>FGenericStackBasedMallocCrash</code>：不释放的栈式分配</li><li><code>FGenericPlatformMallocCrash</code>：针对小块内存使用池分配；大块内存只分配不释放。</li></ul><p>后备分配器的空间在引擎启动之处，随着全局分配器的创建而预选分配好，保证在后备分配器可用后才进行任何动态分配。</p><h3 id="全局用户接口层"><a class="markdownIt-Anchor" href="#全局用户接口层"></a> 全局用户接口层</h3><p><code>FMemory</code>是对引擎全局内存接口的一个轻量级封装，提供了供引擎其他部分实际调用的内存接口。</p><p>一些常规操作（如<code>memcpy</code>、<code>memset</code>等）基本上是直接转发到<code>FPlatformMemory</code>中。</p><p>至于分配操作，需要持有一个分配器的实例，这个实例就是<code>GMalloc</code>。其创建在<code>FMemory_GCreateMalloc_ThreadUnsafe()</code>函数中进行。创建的过程如下：</p><ol><li>从<code>FPlatformMemory</code>获得平台底层分配器</li><li>初始化崩溃后备分配器<code>FPlatformMallocCrash</code></li><li>如果开启了性能统计，用<code>FMallocProfiler</code>包装当前<code>GMalloc</code></li><li>如果当前<code>GMalloc</code>不是线程安全的，用<code>FMallocThreadSafeProxy</code>包装，使其成为线程安全的</li><li>如果开启了指针有效性检验，用<code>FMallocVerifyProxy</code>包装当前<code>GMalloc</code></li><li>如果开启了泄漏检测，用<code>FMallocLeakDetectionProxy</code>包装当前<code>GMalloc</code></li><li>如果开启了内存毒化，用<code>FMallocVerifyProxy</code>包装当前<code>GMalloc</code></li><li>如果开启了双重释放检测，调用<code>FMallocDoubleFreeFinder::OverrideIfEnabled()</code>包装当前<code>GMalloc</code></li></ol><p>实际进行分配时，如果发现<code>GMalloc</code>实例还没有创建，就会调用上述函数进行创建（创建过程保证是线程安全的）。之后直接调用<code>GMalloc-&gt;Malloc()</code>等接口进行分配和释放。</p><p>综上，在UE4中需要动态分配内存时，均应该通过<code>FMemory::Malloc</code>等接口进行，若用operator new或C语言的malloc，就无法享受到UE4内存分配器带来的好处。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li>《游戏引擎架构》Chapter 6.2</li><li><a href="https://github.com/mtrebi/memory-allocators">memory-allocators</a></li><li><a href="https://github.com/rain-1/awesome-allocators#awesome-allocators">awesome-allocators</a></li><li><a href="http://gee.cs.oswego.edu/dl/html/malloc.html">A Memory Allocator</a></li><li><a href="%5Bhttps://wertherzhang.com/dlmalloc%E6%B5%85%E6%9E%90/%5D(https://wertherzhang.com/dlmalloc%E6%B5%85%E6%9E%90/)">dlmalloc浅析</a></li><li><a href="%5Bhttps://wertherzhang.com/tcmalloc2.1%E6%B5%85%E6%9E%90/#tcmalloc%5D(https://wertherzhang.com/tcmalloc2.1%E6%B5%85%E6%9E%90/#tcmalloc)">tcmalloc2.1 浅析</a></li><li><a href="https://qiita.com/EGJ-Yutaro_Sawada/items/4983d0ebfa945611d324">[UE4] About Memory Allocation</a></li><li><a href="https://zhuanlan.zhihu.com/p/79715624">UE4 MallocBinned2分配器</a></li><li><a href="https://zhuanlan.zhihu.com/p/75826986">UE4源码剖析：MallocBinned（上）</a></li><li><a href="http://tinylab.org/memory-allocation-mystery-malloc-in-os-x-ios/">内存分配奥义·malloc in OS X</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UE4 </tag>
            
            <tag> 内存分配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++知识点笔记与踩坑记录</title>
      <link href="/2020/09/06/Cpp-Notes/"/>
      <url>/2020/09/06/Cpp-Notes/</url>
      
        <content type="html"><![CDATA[<p>记录一些遇到过的大大小小的C++坑，或者是C++比较优秀的惯用技巧、设计模式。这些知识点十分分散却很有用，但他们单独拿出来难以构成一篇完整的文章，这里我以杂记的方式将它们记录下来，以便后续翻阅。</p><p>（最后更新于2020.09.06）</p><a id="more"></a><h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>C++很久以来被称作是“博大精深”的一门语言，不仅是因为其语言特性较为复杂且多到令人叹为观止的地步；也是因为细节很多，稍不留神就有可能踏入隐藏的深坑。</p><p>说到语言特性复杂，C++确实有很多不同方面的语言特性，在cppreference上一眼望去都会眼花缭乱。众所周知，C++被称作一门“多范式”的语言，相比于其他一些“纯粹”的编程语言，它不纯粹，因为它的设计者们认为没有一种设计思想适用于所有的情况：C++不仅支持从C直接继承而来的命令式编程，也支持层次性的面向对象编程、泛型编程、函数式编程、编译期编程等编程范式。这种“不纯粹”的设计观念被一些人反感，但也正是这种多样性，使得C++得以很好的应用在各个行业领域。</p><p>除此之外，C++还有许多很好的设计理念与思想：</p><ul><li>“Zero-overhead Principle”：对于不使用的部分，不需要为其付出代价；对于使用到的抽象，自己手写的代码不会更好。</li><li>既能向上增加抽象层次，丰富语义减轻思维负担；也能向下足够接近硬件，充分利用硬件资源。</li><li>用户可扩充的静态类型系统：最大发挥编译器的作用，在编译期解决绝大多数的错误。</li><li>对值类型与引用类型的同等支持。</li><li>系统性的资源管理思想与机制：RAII。</li><li>库与语言一样重要：对于用户来说，语言设计与库设计没有区别，是紧密结合的。</li><li>…</li></ul><p>C++已经历经的多个版本，并在C++11之后以3年为周期持续演进新的版本；每次演进都旨在解决之前出现的痛点，或是引入新的特性或组件。当然，这样也使得C++的学习成本在不断增加（如果真的要了解所有细节的话）。不过C++的设计初衷并不是让我们用上所有的语言特性，而是选择最适合自己项目的语言特性，毕竟没有什么单一的思想是万能。</p><p>对我而言，C++最大想吸引力就是“能上能下”，足够的抽象能力让简单的事情与复杂的事情都能较好地表达；而需要极致性能的时候又可以深入到机器底层开展细致的优化。当然坑的问题仍然存在，它不像其他一些对程序编写有严格要求的语言（如Rust），旨在给以最大的自由，这时就需要我们自己保持良好的程序风格与规范。不过好在既有C++11以来的“现代C++”给我们带来越来越多的安全的抽象能力，也有如<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">CppCoreGuideline</a>这样的从经验中总结的编程规范，让我们离这个目标越来越近。</p><h2 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h2><ol start="2"><li><p><strong>默认实参</strong>的问题：</p><ol><li>多个声明时，（同一作用域下）后面的声明可以获得前面声明的实参；也就是说可以在后面添加默认实参。</li><li>虚函数调用的默认实参，根据调用时的静态类型来定。</li><li>运算符重载不能有默认实参。</li></ol></li><li><p>关于取重载函数的指针问题：用<code>static_cast</code>进行强制类型装换后再取地址即可。注意在函数指针作为模版参数时，重载函数会导致模版参数推导失败，这个时候可以手动指定模版参数。</p></li><li><p><strong>Inline namespace</strong>可用于管理library versioning，将库的不同版本放置于一个特定的namespace中，再对目前使用的namespace前加上inline即可。其好处是在ABI的符号中保留了inline namespace的名称。</p><p><a href="https://stackoverflow.com/questions/11016220/what-are-inline-namespaces-for">参考</a></p></li><li><p><strong>Anonymous namespace</strong>用于定于翻译单元范围内的符号，其作用与<code>static</code>类似，不过相比<code>static</code>来说可以作用在类型定义上。Anonymous namespace只用于<code>.cpp</code>文件而不用于头文件，因为在头文件中的匿名空间里定义的符号可能会被多个翻译单元编译，导致在链接时发生意想不到的结果（违背了ODR原则）。对于头文件中的“私有”符号，需要采用私有的名字空间（如目前流行的<code>detail</code>/<code>internal</code>）。</p><p><a href="https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions">参考1</a> <a href="https://stackoverflow.com/questions/4726570/deprecation-of-the-static-keyword-no-more">参考2</a> <a href="https://stackoverflow.com/questions/4422507/superiority-of-unnamed-namespace-over-static">参考3</a> <a href="https://stackoverflow.com/questions/357564/uses-for-anonymous-namespaces-in-header-files">参考4</a> <a href="https://wiki.sei.cmu.edu/confluence/display/cplusplus/DCL59-CPP.+Do+not+define+an+unnamed+namespace+in+a+header+file">参考5</a></p></li><li><p><code>noexcept()</code>有在不同地方两种含义：</p><ul><li>在函数声明时的<code>noexcept(x)</code>表示如果<code>x</code>为<code>true</code>，则该函数为no-throw。<ul><li><code>noexcept(x)</code>也可以作为操作符，返回表达式<code>x</code>是否会抛出异常。</li></ul></li></ul><p>所以<code>void foo() noexcept(noexcept(y));</code>表示函数<code>foo()</code>是否抛出异常与表达式<code>y</code>是否抛出异常相同。</p><p><a href="https://stackoverflow.com/questions/48703988/c-iso-noexcept-of-noexcept">参考</a></p></li><li><p>在作为参数传递Functor时，为了保证其传递的值类型不变，需要使用<code>std::forward</code>；此外，在最后调用Functor时，也需要先用<code>std::forward</code>得到原本的值类型，否则会导致Functor的值类型变化，调用到不正确的重载函数版本（如<code>const &amp;&amp;</code>被调用为<code>const &amp;</code>的版本）。</p><p><a href="https://stackoverflow.com/questions/31253334/when-should-i-stdforward-a-function-call">参考</a></p></li><li><p>C++ 11之后支持了<strong>构造函数委托（Delegating constructor）</strong>：支持一个构造函数调用另一个构造函数，可以节省很多冗余构造的代码。这种委托可以形成一个链式调用，如“A-&gt;B-&gt;C”；当然，循环调用的结果是未定义的。</p><p><a href="https://en.cppreference.com/w/cpp/language/constructor">参考1</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1986.pdf">参考2</a></p></li><li><p>默认初始化 vs 值初始化/聚合初始化</p><p>首先区分<strong>标量类型</strong>和<strong>聚合类型</strong>：</p><ul><li>标量类型：基础算术类型、指针、枚举、<code>std::nullptr_t</code></li><li>聚合类型：数组、平凡类（仅有public成员、非静态成员，没有用户提供的构造函数、没有虚/非公有基类、没有虚函数）</li></ul><p><strong>值初始化</strong>保证了对所有标量类型对象；<strong>聚合初始化</strong>保证了对所有聚合类型对象的初始化。注意提供了用户自定义构造函数的类不算在聚合类型中，此时成员是否构造由构造函数是否对其初始化决定。值初始化/聚合初始化发生在对象后面跟随<code>()</code>，<code>&#123;&#125;</code>，<code>= &#123;&#125;</code>初始化器的地方，对于未显式指定初始化值的对象，对其使用零初始化。</p><p><strong>默认初始化</strong>不对标量类型对象和聚合类型对象初始化，也就是其有未初始化值。对于提供了用户自定义构造函数的类，默认初始化相当于调用其无参构造函数。默认初始化发生在对象后没有跟随初始化器的地方。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> foo[<span class="number">3</span>];<span class="comment">// 默认初始化</span></span><br><span class="line">  <span class="keyword">int</span> bar[<span class="number">3</span>] = &#123;&#125;;<span class="comment">// 聚合零初始化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++11之后，值初始化一个没有用户定义构造函数的类，该类中的成员在调用构造函数前会先被零初始化。下面这个例子（from cppreference）中<code>a.i</code>的值在第一种值初始化下为0，而在聚合初始化下为未初始化值：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    A() &#123;&#125; <span class="comment">// user-provided default ctor, does not initialize i</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> A a; &#125;; <span class="comment">// implicitly-defined default ctor</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; B().a.i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 值初始化, B().a.i = 0</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; B&#123;&#125;.a.i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// 聚合初始化, B().a.i = ?</span></span><br></pre></td></tr></table></figure><p>此外需要注意<code>=default</code>只在第一次声明时才表示为默认提供实现（非用户定义）。</p><p><a href="https://abseil.io/tips/146">参考</a> <a href="https://en.cppreference.com/w/cpp/language/value_initialization">参考2</a></p></li><li><p>平凡类型、标准排布类型、POD类型的关系：</p></li></ol><ul><li><p><strong>平凡类型（Trivial Types）</strong>：有着编译器提供，或是显式声明为<code>default</code>的特殊成员函数的类或结构体。平凡类型可以有不同访问权限的非静态数据成员。平凡类型可以用<code>std::is_trivial</code>检测。</p><p>注意到这里要求的是所有的特殊成员函数，如果将限制放宽，<strong>不</strong>要求有编译器提供，或是显式声明为<code>default</code>的<em>默认构造函数</em>，就符合<strong>可平凡复制类型（Trivial Copyable Types）</strong>。可平凡复制类型可以用<code>std::is_trivially_copyable</code>检测。</p></li><li><p>对于非静态成员排布（Layout），不同访问权限的成员，编译器对其的排布顺序不定。如果限制使用C++的一些特性，结构体的数据排布规则就能够确定下来，便于与其他语言交互，这样就得到了标准排布类型。</p><p>**标准排布类型（Standard Layout Types）**有如下的要求：</p><ul><li>所有非静态数据成员有<em>相同的访问权限</em></li><li>没有虚函数或虚基类</li><li>没有引用类型的非静态数据成员</li><li>所有非静态数据成员和基类本身也是标准排布</li><li>没有多个同一类型的基类</li><li>没有与首个非静态数据成员类型相同的基类</li><li>所有的位域和非静态数据成员定义在同一个类中（即非静态数据成员要么全在派生类，要么在某单个基类中）</li></ul></li><li><p><strong>POD类型（Plain Old Data Types）</strong>：即是平凡类型，又是标准排布类型的类或结构体，其与C语言中的类型兼容，可以与C语言互通。</p><p><a href="https://docs.microsoft.com/en-us/cpp/cpp/trivial-standard-layout-and-pod-types?view=vs-2019">参考1</a> <a href="https://en.cppreference.com/w/cpp/named_req/TrivialType">参考2</a> <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable">参考3</a> <a href="https://en.cppreference.com/w/cpp/language/data_members">参考4</a> <a href="https://en.cppreference.com/w/cpp/named_req/StandardLayoutType">参考5</a></p></li></ul><ol start="11"><li>…</li></ol><h2 id="模版"><a class="markdownIt-Anchor" href="#模版"></a> 模版</h2><ol><li><p>Fold expression: 目前只支持32种C++内置的二元运算符，共4种展开形式（左折叠or右折叠 x 不带初值or带初值）</p><p>其中比较特殊的<code>,</code>二元运算用法较独特：可以用作依次的无返回值函数调用，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back_vec</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&amp; v, Args&amp;&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>((<span class="built_in">std</span>::is_constructible_v&lt;T, Args&amp;&amp;&gt; &amp;&amp; ...));</span><br><span class="line">    (v.push_back(<span class="built_in">std</span>::forward&lt;Args&gt;(args)), ...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见有返回值的函数可以将返回值Reduce收集，而无返回值的可以采用<code>,</code>运算符展开。</p><p><a href="https://en.cppreference.com/w/cpp/language/fold">参考1</a> <a href="https://stackoverflow.com/questions/27582862/fold-expressions-with-arbitrary-callable">参考2</a> <a href="http://picanumber.github.io/reduce/">参考3</a></p></li><li><p>当重载函数/模版函数作为参数传递给一个模版函数时，该模版函数的deduction会失败。这是因为C++目前不允许传递<strong>重载集（Overload Sets）</strong>。比如以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v1 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">3</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> v2 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> v3 = <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;&#125;;</span><br><span class="line"><span class="built_in">std</span>::transform(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), <span class="built_in">std</span>::back_inserter(v3), <span class="built_in">std</span>::<span class="built_in">max</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>std::max</code>为重载模版函数，其作为参数传递给<code>std::transform</code>时决议失败。然而此时是可以推导出<code>std::max</code>应有的重载版本的，解决方案是用lambda将<code>std::max</code>包起来，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::transform(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), <span class="built_in">std</span>::back_inserter(v3),</span><br><span class="line">               [](<span class="keyword">auto</span> l, <span class="keyword">auto</span> r)&#123;<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">max</span>(l, r);&#125;);</span><br></pre></td></tr></table></figure><p>不过这里的参数类型可能发送变化，为了得到与之前完全一样的类型，需要用到完美转发，再让lambda自动推导返回类型。假设函数为<code>fun</code>，传入的函数应该写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[](<span class="keyword">auto</span>&amp;&amp;...args)-&gt;<span class="keyword">decltype</span>(<span class="keyword">auto</span>)&#123;<span class="keyword">return</span> fun(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...);&#125;</span><br></pre></td></tr></table></figure><p>用一个宏简化一下，这里的函数用<code>__VA_ARGS__</code>表示，以支持更复杂的情况，如静态成员函数模版等；并加上了异常的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIFT(...) \</span></span><br><span class="line">    [](<span class="keyword">auto</span> &amp;&amp;... args) <span class="keyword">noexcept</span>(<span class="keyword">noexcept</span>( \</span><br><span class="line">__VA_ARGS__(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...))) -&gt; <span class="keyword">decltype</span>(<span class="keyword">auto</span>) \</span><br><span class="line">&#123; <span class="keyword">return</span> __VA_ARGS__(<span class="built_in">std</span>::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...); &#125;</span><br></pre></td></tr></table></figure><p><a href="https://akrzemi1.wordpress.com/2018/07/07/functions-in-std/">参考2</a>指出该宏在多个地方均有出现，意味着语言特性的缺失；此外也有一些关于解决此问题的提案。</p><p><a href="https://florianjw.de/en/passing_overloaded_functions.html">参考1</a> <a href="https://akrzemi1.wordpress.com/2018/07/07/functions-in-std/">参考2</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0834r0.html">参考3</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1170r0.html">参考4</a> <a href="https://stackoverflow.com/questions/30855193/passing-template-function-as-argument-for-normal-function">参考5</a></p></li><li><p><strong>SFINAE（Substitution Failure Is Not An Error）</strong>：函数模版在重载决议时，当特化模版时失败，该特化就会从重载集中移除，而不是导致编译错误。特化模版时失败指替换后的类型或表达式为语义错误的（ill-formed）。</p><p>SFINAE为模版级别的重载开启了可能。在C++ 20的Concepts到来之前，SFINAE还经常用于模拟Concept，为模版参数增加限制。</p><p>SFINAE可以分为两种：类型SFINAE与表达式SFINAE。STL中的<code>std::enable_if</code>与<code>std::void_t</code>对应着这两种SFINAE的实现。</p><p><a href="https://en.cppreference.com/w/cpp/language/sfinae">参考1</a> <a href="https://zhuanlan.zhihu.com/p/21314708">参考2</a> <a href="https://www.bfilipek.com/2016/02/notes-on-c-sfinae.html">参考3</a></p></li><li><p>MDFINAE（Method Definition Failure Is Not An Error）：指模版成员函数在没有调用时，其正确性不会被检查。</p><p>这个小特性值得不同的接口可以被同时考虑进来，而不会引发编译错误（只要不被使用）。</p><p><a href="https://www.youtube.com/watch?v=LIb3L4vKZ7U">出自此处</a></p></li><li><p>…</p></li></ol><h2 id="stl"><a class="markdownIt-Anchor" href="#stl"></a> STL</h2><ol><li><p><code>emplace_back(Args&amp;&amp;... args)</code>通过<code>std::allocator_traits&lt;A&gt;::construct(allocator, p, args)</code>构造元素，<code>args</code>是传递给元素<code>T</code>构造函数的参数。<code>::construct()</code>函数内调用<code>::new ((void*)_Ptr) T(std::forward&lt;Args&gt;(args)...)</code>进行构造，因此这里没有使用<strong>统一初始化（Uniform Initialization）</strong>。</p><p>如果有一个POD <code>struct X&#123;int a; int b;&#125;;</code>没有定义任何构造函数，对其容器<code>std::vector&lt;X&gt;</code>进行<code>emplace_back(1, 2)</code>就会编译错误，因为找不到对应的构造函数。尽管聚合体<code>struct X</code>能被initializer_list初始化，此时也不能用<code>emplace_back(&#123;1, 2&#125;)</code>，因为**大括号initializer list（brace-enclosed initializer list）**不能被<code>std::forward</code>传递。</p><p><strong>解决</strong>：这时要么给<code>struct X</code>定义构造函数，要么改用显式初始化的<code>emplace_back(X&#123;1, 2&#125;)</code>/<code>emplace_back&lt;X&gt;(&#123;1, 2&#125;)</code>，或隐式初始化的<code>push_back(&#123;1, 2&#125;)</code>。</p><p><a href="https://stackoverflow.com/questions/13962063/emplacing-a-pod">来源</a></p></li><li><p>对于<code>std::make_shared()</code>，要求相应对象的构造函数必须为public的。然而，即使调用<code>std::make_shared()</code>的一方有对于非public构造函数的访问权限（类内部的static public的<code>create()</code>构造方法、友元类里的构造），<code>std::make_shared()</code>此时还是不能work，因为其访问权限永远被认为是外部的。</p><p><strong>解决</strong>：a. 简单来说，可以改用<code>std::shared_ptr&lt;A&gt;(new A)</code>这样的分离形式。但这样会造成其内存空间不连续。</p><p>​b. 从原本的类派送一个类，这样获得了其public的构造函数的访问权。</p><p>​c. 增加新构造函数，区分有访问权的构造。</p><p><a href="https://stackoverflow.com/questions/8147027/how-do-i-call-stdmake-shared-on-a-class-with-only-protected-or-private-const/8147213#8147213">参考1</a> <a href="https://github.com/isocpp/CppCoreGuidelines/issues/1205">参考2</a> <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#discussion-use-a-factory-function-if-you-need-virtual-behavior-during-initialization">参考3</a></p></li><li><p>…</p></li></ol><h2 id="底层实现优化"><a class="markdownIt-Anchor" href="#底层实现优化"></a> 底层实现|优化</h2><h3 id="polymorphism-rtti"><a class="markdownIt-Anchor" href="#polymorphism-rtti"></a> Polymorphism &amp; RTTI</h3><ul><li><p>多态对象（有虚函数或继承了虚类）的首元素为一个虚表指针，之后是自己的成员变量。对于多继承的多态对象来说，布局为多个对象（首先为派生类，后面依次为各个基类）的叠加，比如对于继承关系C-&gt;{A,B}来说，其布局为 <code>[A虚表指针|A元素] [B虚表指针|B元素]</code>，注意到C本身不需要虚表指针，因为C的虚表其实就等价于A的虚表，因为它们的偏移量（<code>vptr[-16]</code>）均为0。也就是说，在单继承链中，对象均只有一个虚表指针，而多继承对象则有多个虚表指针。这样，在做<code>static_cast</code>的向下转型时只需将指针加上一个偏移量；而做<code>dynamic_cast</code>的向上转型时只需减去一个偏移量（从虚表中获得）。</p></li><li><p>RTTI的信息放在虚表的负偏移处。如<code>vptr[-8]</code>存放多态类型的<code>typeinfo</code>，<code>vptr[-16]</code>存放多态类型到其最派生的类（Most Derived Class）的<strong>负</strong>偏移量<code>offset_to_top</code>。在<code>dynamic_cast</code>中。正是用基类对象指针加上<code>vptr[-16]</code>这个偏移量，得到上层派生对象的实例。</p></li><li><p>对于偏移量不为0的基类虚表，其虚函数有所不同，前面会带一个<code>non-virtual thunk</code>。这是因为调用上层类的虚函数时，需要先调整<code>this</code>指针为上层对象的<code>this</code>，而带<code>thunk</code>的函数就会先进行转换再去调用原虚函数。</p></li><li><p>对于虚继承，虚基类的派生类无法确定虚基类关于本对象<code>this</code>的偏移，因此需要在虚表中加入一项<code>vbase_offset</code>，表示基类关于<code>this</code>的偏移，一般在负偏移<code>vptr[-24]</code>处。反过来，当虚基类要调用其虚函数时，需要的偏移量也不同，对于派生类没有覆盖的虚函数，偏移为0；而派生类覆盖了的虚函数则偏移不为0。该偏移记录在<code>vcall_offset</code>中，在<code>offset_to_top</code>上方。</p></li><li><p>（具体实现与具体编译器相关，上述内容在Clang中验证过）</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/41309205">参考1</a></p></li></ul><h3 id="性能优化"><a class="markdownIt-Anchor" href="#性能优化"></a> 性能优化</h3><ol><li><p>对于确定不会被继承的类，采用<code>final</code>修饰可能带来一定的性能提升，比如以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">final</span> :</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">call_f</span><span class="params">(B <span class="keyword">const</span>&amp; x)</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> x.f(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>struct B</code>有<code>final</code>修饰，编译器知道在<code>call_f</code>函数中调用虚函数<code>x.f()</code>一定是调用的<code>B::f</code>，在此就可以采用inline优化。</p><p><a href="https://devblogs.microsoft.com/cppblog/the-performance-benefits-of-final-classes/">参考</a></p></li><li><p><strong><code>std::unique_ptr&lt;T&gt;</code>并不是<code>T*</code>的零开销抽象</strong>。</p><p>背后的原因是ABI中定义的C++对象传递规则：System V ABI中说明，如果一个C++对象有非平凡复制构造（non-trivial copy constructor）或非平凡析构函数（non-trivial destructor），则它由<strong>不可见的引用</strong>进行传递，因为这类对象必须有明确的地址，不能通过寄存器传递。有着平凡复制构造和平凡析构函数，且能装进2个寄存器（大小不超过16 byte）的C++对象可以通过寄存器传递。在Itanium C++ ABI中也有类似的说明。</p><p>至于non-trivial对象为什么需要有明确的地址，跟异常的实现细节有关。在栈退解（stack unwinding）的过程中，自动储存周期的对象需要被析构，它们的地址必须要能通过函数栈帧得到，因为此时寄存器的值已经被污染了。为了调用析构函数，对象不能储存在寄存器中，因为这样的话对象将没有地址。</p><p>由于<code>std::unique_ptr&lt;T&gt;</code>的析构函数非平凡，根据ABI的要求需要将其放在栈上，即使理论上析构函数并不需要用到对象地址。</p><p>注意ABI并不限制内联函数，此外能进行链接时优化的编译器也可能绕过该限制。</p><p>Clang的编译器扩展属性<code>[[clang::trivial_abi]]</code>能够绕过这个限制。</p><p><a href="https://stackoverflow.com/questions/58339165/why-can-a-t-be-passed-in-register-but-a-unique-ptrt-cannot">参考1</a> <a href="https://www.youtube.com/watch?v=rHIkrotSwcc">参考2</a> <a href="https://quuxplusone.github.io/blog/2018/05/02/trivial-abi-101/">参考3</a></p></li><li><p>…</p></li></ol><h2 id="惯用技巧"><a class="markdownIt-Anchor" href="#惯用技巧"></a> 惯用技巧</h2><h3 id="模版-2"><a class="markdownIt-Anchor" href="#模版-2"></a> 模版</h3><ol><li><p><strong>奇异递归模板模式</strong>（Curiously Recurring Template Pattern, CRTP）：把派生类作为基类的模板参数。</p><p>应用：</p><ul><li>将派生类个共同代码以模版的形式提取处理，以减少派生类中的冗余代码。如多态<code>clone()</code>函数，<code>std::enable_shared_from_this</code>。</li><li>根据派生类的类型做区分处理，如对象计数。</li><li>产生不可被继承的类（final）：将CRTP基类的构造函数声明为私有，同时将对应类设为其友元。</li><li>实现<strong>多态链调用（Polymorphic chaining）</strong>：链式调用时，涉及到基类的方法返回的是基类的引用，这样就导致了链式调用的对象被“向下转换”了。解决方法就是采用CRTP，基类的方法返回派生类的引用。</li><li>提供静态的接口，可以充当类似Concept的用法（不过C++20后有Concept就不需要这个了）。</li></ul><p>为了同时兼顾静态多态与动态多态，可以设计用于动态多态的基类<code>Base</code>，用于静态多态的中间类<code>Base_CRTP&lt;T&gt;</code>，派生类为<code>class Derived : Base_CRTP&lt;Derived&gt;</code>。</p><p>此外，为了防止派生CRTP类时在模版参数中填错派生类，可以在<code>CRTP&lt;T&gt;</code>基类中将构造函数定义为<code>private</code>的，同时设置<code>T</code>为友元。</p><p>注意派生类与基类的方法同名导致的名字遮蔽问题。</p><p>CRTP中经常要用到<code>static_cast&lt;T&amp;&gt;(this)</code>，显得代码和冗余。可以写一个模版类自动完成<code>static_cast</code>，详见参考5。</p><p><a href="%5Bhttps://zh.wikipedia.org/wiki/%E5%A5%87%E5%BC%82%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F%5D(https://zh.wikipedia.org/wiki/%E5%A5%87%E5%BC%82%E9%80%92%E5%BD%92%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F)">参考1</a> <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">参考2</a> <a href="https://www.fluentcpp.com/2017/05/12/curiously-recurring-template-pattern/">参考3</a> <a href="https://stackoverflow.com/questions/262254/crtp-to-avoid-dynamic-polymorphism/262984#262984">参考4</a> <a href="https://www.fluentcpp.com/2017/05/19/crtp-helper/">参考5</a></p></li><li><p><strong>类型擦除（Type Erasure）</strong>：使用单点多态实现包含不同实际类型的统一类型容器。</p><p>仅仅看上面这句话其实很绕…但其实拆开来说很容易理解：提供一个统一的接口，实际上为一个可能包含不同实际类型的容器，并且这是通过多态实现的。类型擦除实际上将多态的细节隐藏在了统一接口的后面，使其可以像值类型一样使用。此外，由于类型擦除基于多态，其难以解决涉及超过二元参数的多分派行为。</p><p>目前类型擦除广泛用于<code>std::function</code>、<code>std::any</code>、<code>std::variant</code>等类的实现中。还在提案中的<code>std::polymorphic_value</code>（让多态类型像值类型一样使用）也是采用类型擦除实现的。</p><blockquote><p>另一个小话题：<code>shared_ptr&lt;void&gt;</code>可以存放任何类型的对象指针，并且能调用到正确的析构函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span>&gt; <span class="title">sp</span><span class="params">( <span class="keyword">new</span> A )</span></span>;</span><br><span class="line">&#125; <span class="comment">// calls A::~A() here</span></span><br></pre></td></tr></table></figure><p>因为其默认的deleter使用的是构造函数传入的类型，也是通过类型擦除实现的。</p></blockquote><p>由于涉及到多态，自然就需要对派生对象分配空间。考虑到储存的对象大多较小，**小对象优化（Small Object Optimization）**基本也是类型擦除容器必备的。C++ 11中考虑到了让这些类型支持自定义分配器（如<code>std::function</code>），然而在C++ 17中完全去除了这个设定。这是因为在类型擦除语境中难以恢复迭代器以支持在拷贝赋值期间的分配操作。</p><p><a href="https://quuxplusone.github.io/blog/2019/03/18/what-is-type-erasure/">参考1</a> <a href="https://akrzemi1.wordpress.com/2013/11/18/type-erasure-part-i/">参考2</a> <a href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Erasure">参考3</a> <a href="https://stackoverflow.com/questions/5450159/type-erasure-techniques">参考4</a> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0302r1.html">参考5</a></p></li><li><p><strong>成员检测（Member Detector）</strong>：基于SFINAE检测一个类是否有某个成员函数，以实现基本的反射。在有了C++20 Concepts后，这个模式就不再需要了。</p><p>该模式的实现已经集成进了STL（<code>std::experimental::is_detected</code>）。</p><p><a href="https://en.wikibooks.org/wiki/More_C++_Idioms/Member_Detector">参考1</a> <a href="https://people.eecs.berkeley.edu/~brock/blog/detection_idiom.php">参考2</a> <a href="https://en.cppreference.com/w/cpp/experimental/is_detected">参考3</a></p></li><li><p>…</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cppcon 笔记</title>
      <link href="/2020/09/06/Cppcon-Notes/"/>
      <url>/2020/09/06/Cppcon-Notes/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cppcon.org/">Cppcon</a>是个著名的C++会议，由C++社区举办，每年有很多来自全球各地的演讲者分享C++语言相关的内容。其中的演讲大多数质量很高，不乏出自一些社区中知名的C++专家的精彩演讲。此外，也有很多C++在不同领域的相关实践，如游戏开发、嵌入式、HPC、高频交易等等，可以吸收到来自不同领域的经验。总的来说，Cppcon是一个十分难得的优质学习资源。</p><p>本文主要记录了一系列的观看Cppcon presentation时做的笔记，供后续参考使用。</p><p>（最后更新于2020.09.06）</p><a id="more"></a><hr /><h2 id="目录按主题分类"><a class="markdownIt-Anchor" href="#目录按主题分类"></a> 目录（按主题分类）</h2><ul><li>C++特性介绍<ul><li><a href="#concepts-in-60-everything-you-need-to-know-and-nothing-you-dont-andrew-sutton">Concepts in 60: Everything you need to know and nothing you don’t</a></li></ul></li><li>内存管理与分配<ul><li><a href="#stdallocator-andrei-alexandrescu">std::allocator…</a></li></ul></li><li>硬件与性能优化<ul><li><a href="#want-fast-c-know-your-hardware-timur-doumler">Want fast C++? Know your hardware!</a></li><li><a href="#Garbage-In-Garbage-Out-Arguing-about-Undefined-Behavior-Chandler-Carruth">Garbage In, Garbage Out: Arguing about Undefined Behavior…</a></li></ul></li></ul><hr /><h2 id="2018"><a class="markdownIt-Anchor" href="#2018"></a> 2018</h2><h3 id="concepts-in-60-everything-you-need-to-know-and-nothing-you-dont-andrew-sutton"><a class="markdownIt-Anchor" href="#concepts-in-60-everything-you-need-to-know-and-nothing-you-dont-andrew-sutton"></a> Concepts in 60: Everything you need to know and nothing you don’t - Andrew Sutton</h3><blockquote><p>概述：Concepts快速介绍</p></blockquote><ul><li><p>Concepts有助于提高泛型代码的两个方面：</p><ul><li>更好的泛型约束</li><li>使用多余的约束提高代码性能</li></ul></li><li><p>泛型代码目前来说有2种，“泛用性”从低到高：</p><ol><li><p>函数重载，如运算符重载，不同的<code>sin</code>、<code>cos</code>等等</p><p>并不是“真正”的泛型，只是从用户角度的泛型。</p></li><li><p>模版（<code>template &lt;typename T&gt;</code>）</p><p>真正的泛型，“所有具体的实现都可以看做是某个模版算法的示例”。</p><p>然而模版的问题是其<em>过度通用</em>了，显然一个模版算法不能适用于所有的类型，然而在接口中却没有表达任何限制，导致一旦误用，就会出现很可怕的错误信息（如<code>std::vector&lt;int&amp;&gt;</code>）</p></li></ol></li><li><p>**Concepts（概念）**正是解决模版过度通用问题的良药，其能够让我们限制模版参数适用的范围，也带来了如下的好处：</p><ul><li>直接表达模版参数意图</li><li>在使用点检查模版参数是否符合限制（而不是在模版实例化后）</li><li>基于多余限制做特殊优化</li><li>更好的编译器信息提示（相比使用一些别扭的语法规则如SFINAE时的编译器信息）</li></ul><p>Concepts本质上是表达对模版参数提出要求的<strong>具名谓词</strong>。</p><p>要求一般可以分为3种：</p><ol><li>语法要求：需要使用到哪些语法操作、哪些相关类型</li><li>语义要求：操作的行为应该是什么</li><li>复杂度要求：操作的性能应该达到什么</li></ol></li><li><p>一些Tips：</p><ul><li>要写出好的Concepts并不容易，需要不断地尝试与迭代。所以，在自己写之前，最好看看有没有库已经写过类似的了，如果有就直接拿来用吧~</li><li>编译器只能检测类型是否满足Concepts的语法要求，而对于语义和复杂度要求则无能为力。</li><li>一个Concept可以由几个不同限制的Concept组成，一个Concept可以限制多个模版参数类型。</li><li>基本上所有模版代码中的模版参数均有一些<strong>前提条件</strong>的要求，也可以用某种Concept表示，只是你可能还没有发觉。也就是说，不要再有裸的<code>typename T</code>出现在模版参数里了！</li></ul></li><li><p>注意<strong>语法要求</strong>和<strong>语义要求</strong>的区别，某些操作的语法要求一般不要求其在<em>所有值</em>上适用，如</p><ul><li>浮点数满足<code>TotallyOrdered</code>，即使有NaNs值的存在</li><li>定点整数满足<code>Arithmetic</code>，即使overflow时行为undefined</li></ul></li><li><p>限制表示了一个算法所使用的抽象，注意这种抽象并不是仅仅看使用到了什么语法，否则实际上就是在暴露实现的细节。</p><p><strong>过度限制</strong>并不是一件坏事：</p><ul><li>从比较强的要求开始抽象，在实现上有更高的自由度，也防止了偶然的模版误用</li><li>限制在以后总是可以放宽，并保证向前兼容。</li></ul><p>反之，过松的限制容易导致不成熟的泛用：</p><ul><li>较弱的语义难以推断其行为，限制实现的自由度</li><li>过于追求“泛用”只会导致“面向语法的Concept”（不要让Concept表达“可加”、“可减”之类的语法限制！）</li></ul></li><li><p>Concept还可以利用特殊情况优化性能：对于更强要求的Concept，其<strong>多余的要求有时可以用于优化</strong>。</p><p>可以衡量Concept的要求严格程度：如果Concept D的要求Concept C都能满足，且C相比D有更多的要求，就认为C相比D更严格，称C<strong>隐含</strong>D。（比如<code>BidirectionalIterator</code>隐含<code>ForwardIterator</code>）</p><p>基于这种严格程度的比较，就可以定义Concept的特化了：如果对于一个算法，Concept P可以替换Concept Q，也就是Concept P隐含Concept Q，那么P就是Q的特化。</p><p>这种Concept的特化和模版的特化类似，也是决定函数重载的规则，编译器会选择最特化的Concept限制的函数版本。</p><p>比如下面这个例子就利用了<code>RandomAccessIterator</code>相比<code>InputIterator</code>多出的限制，将原本O(N)复杂度的算法降低到了O(1)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;InputIterator Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(Iter first, Iter last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (first++ != last) ++n;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;RandomAccessIterator Iter&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">distance</span><span class="params">(Iter first, Iter last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些时候两个特化之间编译器无法决定哪一个更好的时候，就会导致ambiguous报错，这时可以用<code>if constexpr</code>在函数体内判断，同样可以实现类似的优化。</p></li></ul><p><a href="https://www.youtube.com/watch?v=ZeU6OPaGxwM">Talk</a></p><h2 id="2016"><a class="markdownIt-Anchor" href="#2016"></a> 2016</h2><h3 id="want-fast-c-know-your-hardware-timur-doumler"><a class="markdownIt-Anchor" href="#want-fast-c-know-your-hardware-timur-doumler"></a> Want fast C++? Know your hardware! - Timur Doumler</h3><blockquote><p>概述：通过实际测量的数据说明现代处理器不同方面对性能的影响</p></blockquote><ul><li><p>2D数组遍历：</p><ul><li><p>行主序（Row major）和列主序（Column major），后者比前者慢30倍</p><p>不同数组大小的测试中可以看出，两者在很小的数组时有一个基础的性能差异，而数组大小超过L2 Cache和L3 Cache时差距有显著提高。</p><p>如果在循环中加入一点计算，基础性能差异就消失了，只剩在超过L3 Cache时的差距。可以认为左侧速度受限于计算，右侧受限于数据访问。</p><p><img src="./Cppcon16-01-01.png" alt="" /></p></li><li><p>访问每N个int元素：N&gt;16时速度明显下降，因为一个Cacheline为64bytes，刚好为16个int。</p><p><img src="./Cppcon16-01-02.png" alt="" /></p></li><li><p>数组的遍历顺序很重要，比如一个图像处理程序，需要经常访问局部一个范围内的数据，可以进行分块遍历，甚至可以用希博尔特曲线…</p><p><img src="./Cppcon16-01-03.png" alt="" /></p><p>核心思想是用好数据局部性，让访问的数据尽量都在Cache中。</p></li><li><p>当比较列主序遍历和随机遍历时，随机遍历比前者还要慢几倍。这可能是由于CPU中**预取器（Prefetcher）**的作用导致的，它能够识别出数据访问分模式，并对固定步长的访问做数据预取以降低cache miss带来的影响。</p></li></ul></li><li><p>每隔N个元素访问一次，循环进行，得到了如下的图。</p><p><img src="./Cppcon16-01-04.png" alt="" /></p><p>在N=256、N=512、1024时访问时间一下变为了几十倍。出现这种现象的原因是<strong>Cache相联性</strong>，事实上现代CPU Cahce采用了组相联的方式，而每组内又是直接相联，导致在特殊步长（如2的指数）下可能经常发生碰撞，相当于很多数据在竞争Cache中的几个位置。</p></li><li><p>数据对齐很重要，在某些机器上未对齐的数据访问比对齐的要慢几倍。</p></li><li><p>避免<strong>随机分支</strong>。分支预测失败导致流水线被清空，造成显著的性能损失。有模式的分支如循环、判空指针、可预测的虚函数访问等经过CPU分支预测器，开销被降到很低，而分支预测器对随机分支无能为力。</p><blockquote><p>注：较新的CPU可以在分支预测失败时“快速恢复”，不必清空流水线。<a href="https://stackoverflow.com/questions/50984007/what-exactly-happens-when-a-skylake-cpu-mispredicts-a-branch">参考</a></p></blockquote></li><li><p>避免原子变量的核间共享访问。不同核对同一个原子变量的竞争，导致其他核的Cache经常被失效，导致性能随线程数的提高而显著下降。</p><p>另一个相关概念是<strong>伪共享（false sharing）</strong>：虽然不同核访问的变量不一样，但由于它们在同一Cacheline内，出现同样的问题。解决办法是将变量显式对齐到一个Cacheline。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">64</span>)</span> aligned_type </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>避免循环的不同迭代间的数据依赖，改写为同一迭代间的依赖可以有助于编译器进行自动SIMD向量化。</p></li><li><p>SIMD数据的对齐在某些机器上很重要。</p></li><li><p>浮点数乘法需要注意**次正规数（denormal）**对性能的影响：其运算速度比一般的乘法慢30倍。</p><p>如果它们对计算结果影响不大，可以考虑之前将次正规数变为0（一般在编译选项中开启<code>-ffast-math</code>即可）。</p><p>相关讨论可以参考<a href="https://randomascii.wordpress.com/2012/05/20/thats-not-normalthe-performance-of-odd-floats/">这篇文章</a></p></li></ul><p>总结性能问题的着手处：</p><ul><li>了解程序速度是受限于计算，还是受限于数据访问。</li><li>数据在内存中的排布：连续 &gt; 常数步长 &gt; 完全随机（注重数据访问在时间与空间上的局部性）</li><li>避免连续计算之间、循环的不同迭代之间的数据依赖</li><li>避免难以预测的分支</li><li>了解Cacheline和对齐，避免线程间Cacheline的共享</li><li>不要惊讶于硬件古怪的地方（Cache相联性、浮点denormal…）</li></ul><p><a href="https://www.youtube.com/watch?v=BP6NxVxDQIs">Talk</a></p><h3 id="garbage-in-garbage-out-arguing-about-undefined-behavior-chandler-carruth"><a class="markdownIt-Anchor" href="#garbage-in-garbage-out-arguing-about-undefined-behavior-chandler-carruth"></a> Garbage In, Garbage Out: Arguing about Undefined Behavior… - Chandler Carruth</h3><blockquote><p>概述：Undefined Behaviour的背后是约定</p></blockquote><ul><li><p><strong>未定义行为（Undefined Behaviour）<strong>实质上是</strong>程序编写错误</strong>所引发的综合征，与调用API时没有准守约定一样。</p><p>很多时候，我们难以定义错误程序的行为，因为它们和实现密切相关，这个时候，只能指定其为未定义行为。</p></li><li><p>正如API对参数的要求一样，部分语言操作也对操作数有要求（典型的如<code>*</code>解引用运算符）。</p><p>这里就涉及到两个关于约定的概念：</p><ol><li><strong>宽约定（Wide contract）</strong>：一个函数或操作对于所有的输入都有效</li><li><strong>窄约定（Narrow）</strong>：一个函数或操作只对满足特定前提条件的输入有效</li></ol><p>比如对于<code>std::vector</code>的<code>size()</code>成员函数就是一个宽约定函数，因为其对于任何的<code>std::vector</code>实例都有效；而<code>operator[](size_t index)</code>就是一个窄约定函数，因为其只对于满足<code>index &lt; size()</code>的输入有效，而对于其他输入为未定义行为。</p></li><li><p>怎样解决UB带来的问题？</p><ul><li>定义所有行为？显然不行，一些行为只在特定平台上适合实现，而其他平台则难以实现；在语言层面上定义所有的行为也不是C++的风格。</li><li>限制UB的行为？然而限制UB的行为实际上偏离了正确的道路；不同的用户想要的行为也是不同的。</li></ul><p>唯一合理的选择依然是，在合适的地方引入窄约定（当然，违反了约定的行为还是UB）。</p></li><li><p>何时是引入窄约定的好时机呢？</p><p>窄约定是一种更简单的语义模型，只不过某些时候不符合人们的预期。</p><p>引入窄约定的原则有：</p><ol><li>在运行时（可能）可以检测</li><li>提供显著的价值：发现bug、简化实现、优化</li><li>易于解释</li><li>没有被现有代码大量违背</li></ol></li><li><p>几个例子：</p><ul><li><p>位移量超过字长</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> y = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> result = x &lt;&lt; y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该操作是UB的原因：为了达到最大的可移植性，不同的平台（x86、arm、powerPC）对其均有不同的实现。如果定义了某种行为，就一定意味着某些平台上的性能下降。至于为什么不能定义其为<em>平台定义</em>的呢？因为这样就不能提醒潜在的程序错误了。</p></li><li><p>有符号整数溢出</p><p>这里举了一个比较特殊的地址，用32位无符号整数作为数组下标索引。相同的程序，修改为32位有符号整数下标后生成的汇编代码少了很多。原因是64位x86平台下，为了实现32位无符号整数的溢出模运算，需要生成更多的汇编代码；然而32位有符号数本身的溢出是UB，实际实现时转换为了64为整数计算，生成的汇编代码反而更少。</p><p>这里就体现了窄约定带来的好处：实现可以利用额外的自由度实现特定的优化。</p></li></ul></li></ul><p><a href="https://youtu.be/yG1OZ69H_-o">Talk</a></p><h2 id="2015"><a class="markdownIt-Anchor" href="#2015"></a> 2015</h2><h3 id="stdallocator-andrei-alexandrescu"><a class="markdownIt-Anchor" href="#stdallocator-andrei-alexandrescu"></a> std::allocator… - Andrei Alexandrescu</h3><blockquote><p>概述：吐槽现有的内存分配设计，讲述如何设计可组合的内存分配器</p></blockquote><ul><li><p><code>malloc</code>分配时需要提供size，而<code>free</code>却不用 -&gt; 说明allocator需要想办法记住这个信息。显然这个接口设计是不合理的</p><p>改进：分配器不是返回指针，而是一个struct，如</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk</span> &#123;</span> <span class="keyword">void</span>* ptr; <span class="keyword">size_t</span> <span class="built_in">size</span>; &#125;;</span><br></pre></td></tr></table></figure><p>好在C++14之后operator new/delete新增了带size的版本 ; )</p></li><li><p>operator new加入了类型信息，但是语法有些奇怪：即使是fixed-size的数组（如<code>int[100]</code>），也是调用的动态分配的数组operator new，而语义上fixed-sized数组应该看做一个类型。</p><p>还提到不要使用class operator new…</p><p>此外<code>delete</code>和<code>delete[]</code>完全没区别，应该统一…</p></li><li><p><code>std::allocator</code>原本并不是为了分配内存而生的，是为了解决“near/far pointer”的问题。目前标准中已经把这一部分完全移除了。</p><p>Allocator设计奇烂无比，设计后的20年还在思考如何使其work… 可以看<a href="https://www.youtube.com/watch?v=YkiYOP3d64E">Alisdair Meredith的&quot;Making Allocators Work&quot;演讲</a>。体现在：</p><ul><li>Allocator应该完全不知道类型信息，只需要size和alignment</li><li>Allocator不是factory，不应该管构造/析构</li><li><code>rebind&lt;U&gt;::other</code>太恶心了</li><li>假定Allocator是stateless的（C++14后终于支持了Allocator有state）</li></ul></li><li><p>Allocator的关键是“组合”：有针对特定大小的Allocator、有不同实现的Allocator、有hook其他Allocator的Allocator（以实现debug、stat等）</p><p>讲到了一下的可组合Allocator：</p><ul><li><p>Fallback Allocator：连接两个Allocator，分别为Primary和Fallback，如果前者失败则尝试后者。</p><p>分配很简单，free就…需要知道指针来自哪个allocator。显然当前的接口是无法知道的，可以增加一个<code>owns</code>接口，查询一个指针是否来自此分配器</p></li><li><p>Stack Allocator：在栈空间上用后进先出思想分配。</p><p>优点是栈空间为hot内存区域，访问很快。缺点自然也是对free的顺序要求很严格。</p><p>后进先出可搭配<code>SCOPE_EXIT</code>辅助使用。</p></li><li><p>Freelist Allocator：在空闲块内维护一个intrusive list管理空闲块。据说freelist的cache friendly不好。</p><p>可改进的点：加入适用块大小范围、成批分配、加入块数上限。</p></li><li><p>Affix Allocator：可在在分配块上加入prefix和suffix。可用于调试、统计等信息，或访问越界检查。</p></li><li><p>Allocator With Stats：专门收集分配信息的Allocator，如call count、failures、byte count、high water、caller file/line/function/time。</p></li><li><p>Bitmapped Block：用bitmap管理固定大小块的分配信息。</p><p>优点：meta信息可以fit进cache，分配很快，额外空间开销小。</p></li><li><p>Cascading Allocator：维持一个allocator list，当allocator不够用时就产生一个新的。</p></li><li><p>Segregator：size &lt; threshold的走small allocator，否则走large allocator。通过组合可以实现一个二叉搜索树。</p></li><li><p>Bucketizer：分配大小从min到max以指数方式递增分成桶。</p></li></ul></li></ul><p><a href="https://www.youtube.com/watch?v=LIb3L4vKZ7U">Talk</a> [Slide]([<a href="https://github.com/CppCon/CppCon2015/blob/master/Presentations/allocator%20Is%20to%20Allocation%20what%20vector%20Is%20to%20Vexation/allocator%20Is%20to%20Allocation%20what%20vector%20Is%20to%20Vexation%20-%20Andrei%20Alexandrescu%20-%20CppCon%202015.pdf">https://github.com/CppCon/CppCon2015/blob/master/Presentations/allocator Is to Allocation what vector Is to Vexation/allocator Is to Allocation what vector Is to Vexation - Andrei Alexandrescu - CppCon 2015.pdf</a>](<a href="https://github.com/CppCon/CppCon2015/blob/master/Presentations/allocator">https://github.com/CppCon/CppCon2015/blob/master/Presentations/allocator</a> Is to Allocation what vector Is to Vexation/allocator Is to Allocation what vector Is to Vexation - Andrei Alexandrescu - CppCon 2015.pdf))</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Cppcon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程在C++中的应用</title>
      <link href="/2020/04/30/Functional-prog-in-cpp/"/>
      <url>/2020/04/30/Functional-prog-in-cpp/</url>
      
        <content type="html"><![CDATA[<p>函数式作为一种独特的编程范式，本着一切皆为函数的思想使它与传统的命令式编程、声明式编程形成了鲜明的差异。说到函数式编程，大部分人首先想到的是像Lisp、ML、Haskell、Scala这样的主打函数式编程的“纯”函数式语言，不过，这些语言从使用人数上来说算是小众语言，对于绝大部分的程序，命令式编程仍然占到主流。随着近些年来一些热门语言，如Python、JavaScript对函数式编程的越来越强的支持，函数式的思想可以说是逐渐成为了编程人员不可不知的一种主流编程范式。在这篇文章中我会讨论函数式编程在一门“古老”的语言——C++中的应用。可以看到，即使是C++这种偏向底层的系统级开发语言，近几年来也逐步加入了对函数式编程越来越多的支持。</p><a id="more"></a><h3 id="函数式编程简介"><a class="markdownIt-Anchor" href="#函数式编程简介"></a> 函数式编程简介</h3><p>函数式编程相比传统的编程范式有许多特点，我们可以在这里简单列举一些主要的特点：</p><ol><li><p>函数被认为是“一等公民”：函数可以像其他数据类型一样，被很容易地定义，被赋值传递等。</p></li><li><p>强调“无副作用”的函数/引用透明：函数内部不会修改任何的外部状态，且函数的返回值仅取决于传入的参数。</p></li><li><p>变量是**不可变（immutable）**的：变量不同于命令式编程的储存单元，不能被赋值，只能说是计算得到了一个新变量。</p></li><li><p>强调基于表达式而不是语句：表达式只是一个单独的计算过程，而语句一般表示“执行某个（产生副作用）的操作”，这与上面一点也是对应的。</p></li></ol><p>正是有了这些特点的“约束”，函数式编程与之而来的也有许多命令式编程望而止步的优点，比如善于以一些短小精悍的小函数，逐步组建为一个功能强大的程序，在减少了代码重复的同时，也加快了程序开发速度；由于有了引用透明，函数在什么时候求值均可以，所以可以<strong>惰性求值</strong>；由于函数不会修改外部状态产生副作用，代码可以完美转换到并行执行而不用担心数据竞争的问题…</p><p>C++这门语言从基于命令式的C语言发展而来，从源头上就和函数式编程“背道而驰”。比如函数不能随处定义传递；绝大部分函数都是有副作用的，还有专门为了副作用而生的函数（如<code>printf</code>）；基于语句而非表达式等。这就造成了很大的割裂，背后的原因也很明显，在C语言出现的那个年代，由于计算器的性能极低且极其昂贵，人们更偏向于“面向机器编程”，因此更接近机器底层的寄存器模型的C语言受到了广泛欢迎。不过到了今天，接近底层机器不再是优势，随着程序规模的膨胀，具有更好抽象能力、更接近数学的函数式编程方式更加受到人们的青睐。C++一直以来的设计目标是一种“多范式语言”，认为没有一种编程范式是适用于任何情况的，对各种编程范式的均支持才会有更强的表达能力。随着近几年的发展演变，C++引入了越来越多的函数式思想，让我们真正看到了函数式编程可以走入实际应用之中。</p><h3 id="函数式编程与c"><a class="markdownIt-Anchor" href="#函数式编程与c"></a> 函数式编程与C++</h3><p>有人将函数式与命令式的区别总结为：</p><blockquote><p>函数式编程关心数据的映射，命令式编程关心解决问题的步骤</p></blockquote><p>命令式编程就好像告诉计算机每一步要做什么，而函数式编程则告诉计算机问题的定义是什么，余下的让计算机自行求解。举个例子，要求一个列表<code>[1,2,3,...]</code>的和，在命令式编程中我们会用一个for循环，定义累加变量，告诉计算机每一步要加上一个数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; L.<span class="built_in">size</span>(); i++)</span><br><span class="line">s = s + L[i];</span><br></pre></td></tr></table></figure><p>而在函数式编程中，根本没有循环这种结构，我们只需要告诉计算机求和的定义是什么就可以了：比如求和可以看做是列表的头加上剩余列表的求和，且空列表的和为0。从这个简单的定义我们就可以得到如下的ML程序：</p><figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> sum <span class="literal">[]</span> = <span class="number">0</span></span><br><span class="line">  | sum (x::<span class="type">L</span>) = x + sum <span class="type">L</span></span><br></pre></td></tr></table></figure><p>显而易见，下面的程序比上面的程序更加简短，且不会出现循环条件错误，忘记初始化等等bug。</p><p>如果单对函数式编程泛泛而谈，我们可能很难摸清其具体的轮廓。更好的方式是寻找函数式编程中的具体<strong>特性</strong>，如果C++对这些特性有足够的支持，那么它就足够用于函数式编程（当然，纯函数式的语言表达这些特性一般会更简单）：</p><ol><li><p><strong>纯函数</strong>（Pure Function）：函数不产生可以观测的副作用。C++中并没有明确表示纯函数的方式，不过只要函数本身没有对外部状态的修改，我们就可以认为它是纯函数。不过，并不是所有函数都是纯函数，总会有一些操作，它们不能以纯函数的形式表示（如IO操作），这时候我们可以放宽要求，允许一定的非纯函数，不过我们仍然可以让非纯函数的数量减到最少。</p></li><li><p>对<strong>递归</strong>的支持：由于函数式编程中变量是不可变的，自然也就没有了循环结构，这时，如果算法需要迭代，唯一的途径只有递归，因此在函数式编程中需要大量用到递归，需要语言对递归有较好的支持，比如自动将尾递归转换为循环等。</p></li><li><p><strong>高阶函数</strong>（High-Order Function）：参数为函数或者返回值为函数的函数，也就是函数要能够作为一等公民。在C++中，高阶函数可以以函数指针或函数对象（Function Object）实现，比如一个函数对象就是重载了<code>operator()</code>运算符的类的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Add</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C++11及以后引入了<strong>匿名函数</strong>（Lambda Function），其本质上与函数对象相同，不过进一步简化了函数定义的语法，让函数可以随处进行定义和传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> Add = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>偏应用的函数</strong>（Partially Applied Functions）与<strong>柯里化</strong>（Currying）：对函数的部分参数提前进行绑定，得到需要剩下参数的函数。比如上面定义的<code>Add</code>函数，如果要改造为柯里化的形式，可以在C++中写作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> PartialAdd = [=](<span class="keyword">auto</span> a) &#123;</span><br><span class="line"><span class="keyword">return</span> [=](<span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> Add(a, b); &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样，在应用时就可以提前绑定一个参数，在得到返回的函数后绑定剩下的一个参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = PartialAdd(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">auto</span> x = f(<span class="number">5</span>);<span class="comment">// x = 7; </span></span><br></pre></td></tr></table></figure></li><li><p><strong>闭包</strong>（Closure）：闭包是自动捕获了外部状态的函数，在C++中体现为有成员变量的函数对象。不过在C++11后的Lambda函数，我们可以很方便的捕获外部变量形成闭包。比如上面的<code>PartialAdd</code>函数就应用到了闭包，其外层函数捕获了<code>Add</code>函数，其内层函数捕获了传入<code>a</code>参数和<code>Add</code>函数。捕获的表示在两个方括号<code>[]</code>之间，<code>[=]</code>表示的是默认以值拷贝的方式捕获，与之对应的还有<code>[&amp;]</code>表示默认以引用的方式捕获。</p></li><li><p><strong>模式匹配</strong>（Pattern Match）：模式匹配也是函数式编程中的一大利器，在递归时作为分支选择必不可少的攻击。可惜C++中对模式匹配的支持尚且不强，运行时的函数只能通过<code>if</code>语句手动进行匹配，不过，C++对于编译时的模版元编程中还是支持了一定的模式匹配。</p></li><li><p><strong>惰性求值</strong>（Lazy evaluation）：惰性求值可以让表达式的计算推延到实际使用时再进行，可以避免不必要的计算。在C++中也有相应的方法实现惰性求值。</p></li></ol><p>从上面可以看出C++11以后对函数式编程有着足够的支持，在一些方面不亚于函数式语言。我们可以从不同的几个实例来感受一下C++中的函数式编程是什么样的。</p><h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2><h3 id="1-高阶函数-泛型-闭包"><a class="markdownIt-Anchor" href="#1-高阶函数-泛型-闭包"></a> 1. 高阶函数、泛型、闭包</h3><p>在C++中有多种对象都都可以被认为是函数。运用鸭子类型（Duck Typing）的说法：任何“可以像函数一样调用的东西就是函数”。前面说到，C++中主要有3种类型的函数：函数指针、函数对象（重载<code>operator()</code>的类对象）、匿名函数。要进一步地深入使用函数式，我们可以用数学化的方式表达类型。比如平时我们常见的函数声明方式一般是这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqrThenAdd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x * x + y; &#125;</span><br></pre></td></tr></table></figure><p>这个函数的类型我们可以表示为<code>(int * int) -&gt; int</code>，因为它可以看做是一个变化：将一个<code>int</code>二元组变换为一个<code>int</code>。在函数式语言中也可以很自然地得到如下定义与其类型：</p><figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">fun</span> sqrThenAdd (x : <span class="built_in">int</span>, y : <span class="built_in">int</span>) : <span class="built_in">int</span> = x * x + y;</span><br><span class="line"><span class="keyword">val</span> sqrThenAdd = <span class="keyword">fn</span> : <span class="built_in">int</span> * <span class="built_in">int</span> -&gt; <span class="built_in">int</span></span><br></pre></td></tr></table></figure><p>C++11后也可以写成这种更自然的表示法：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto sqrThenAdd(int x, int y) -&gt; int &#123; return x * x + y; &#125;</span><br></pre></td></tr></table></figure><p>不过，一般在函数式语言中我们不会明确标注类型，取而代之的是使用<strong>泛型</strong>，并让编译器推导相关类型。这样既减少了对类型思考的负担，也增强了程序的适用范围。在C++中也可以实现这个目标，比如使用模版函数：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Arithmetic1, <span class="keyword">typename</span> Arithmetic2&gt;</span><br><span class="line">auto sqrThenAdd(Arithmetic1 x, Arithmetic2 y) -&gt; decltype(auto) &#123; return x * x + y; &#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>Arithmetic</code>代指一个泛型类型，返回值的<code>decltype(auto)</code>表示让编译器自动推导返回表达式的类型作为返回类型。当我们以<code>sqrThenAdd(1, 2)</code>调用时，编译器会将其推导为<code>(int * int) -&gt; int</code>；而当我们以<code>sqrThenAdd(1.0, 2.0)</code>调用时，编译器会推导为<code>(double * double) -&gt; double</code>，这里就体现了一个重要的特性——<strong>静态多态</strong>，极大地增强了函数的适用范围。不过，过大的范围也不是好事，比如这里的<code>Arithmetic</code>仅指代算术类型，即有<code>*</code>、<code>+</code>运算符的数据类型，对于其他类型这段程序是没有意义的。目前阶段的C++要实现这个限制较为麻烦，而在C++20后即将引入了Concept较好地解决了这个问题。</p><p>另一种更为符合函数式的函数定义语法是匿名函数。在C++14之后加入的Generic Lambda让匿名函数也很好地支持了泛型，比如下面这个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mapThenAdd = [](<span class="keyword">auto</span> f, <span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123; <span class="keyword">return</span> f(x) + y; &#125;;</span><br></pre></td></tr></table></figure><p>其中除了<code>auto</code>标识符并没有任何类型声明，其类型会像模版一样自动推导。可以看到<code>f</code>在函数体内被调用，是一类函数参数。<code>mapThenAdd</code>自身就是一个高阶函数，其作用是对参数<code>x</code>应用<code>f</code>函数并加上<code>y</code>。按照函数式语言中的数据类型定义，<code>mapThenAdd</code>接受的是一个有3个元素的元组，如果我们想要柯里化的函数形式，需要对其的部分做绑定。在函数式编程中我们可能会写出以下的程序：</p><figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> mapThenAdd (f, x, y) = f(x) + y;</span><br><span class="line"><span class="keyword">fun</span> bind (f, arg) = <span class="keyword">fn</span> (x, y) =&gt; f(arg, x, y);</span><br><span class="line"><span class="keyword">val</span> sqrThenAdd = bind(mapThenAdd, <span class="keyword">fn</span> x =&gt; x * x);</span><br><span class="line"><span class="keyword">val</span> r = sqrThenAdd(<span class="number">2</span>, <span class="number">3</span>);<span class="comment">(* r = 7 *)</span></span><br></pre></td></tr></table></figure><p>上面这段程序将<code>mapThenAdd</code>函数的<code>f</code>参数提前进行绑定，<code>bind</code>函数就是完成这个工作的高阶函数，传入其中的<code>f</code>和<code>arg</code>都被<strong>闭包</strong>绑定了下来，在绑定了一个平方函数后就返回了完成<code>sqrThenAdd</code>功能的函数。通过这个方法，我们也可以很容易地对这个函数进行柯里化。在C++中实现相同功能也一样很简单：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> bind = [](<span class="keyword">auto</span> f, <span class="keyword">auto</span> arg) &#123;<span class="keyword">return</span> [=](<span class="keyword">auto</span> x, <span class="keyword">auto</span> y) &#123;<span class="keyword">return</span> f(arg, x, y);&#125;;&#125;;</span><br><span class="line"><span class="keyword">auto</span> sqrThenAdd = bind(mapThenAdd, [](<span class="keyword">auto</span> x) &#123;<span class="keyword">return</span> x * x;&#125;);</span><br><span class="line"><span class="keyword">auto</span> r = sqrThenAdd(<span class="number">2</span>, <span class="number">3</span>);<span class="comment">// r = 7</span></span><br></pre></td></tr></table></figure><p>从上面的这些例子中，我们一窥了C++中的函数式编程，有了这些语言上的基础，我们才得以将其逐步应用在更加实用且复杂的场合。</p><h3 id="2-stl中的函数式编程"><a class="markdownIt-Anchor" href="#2-stl中的函数式编程"></a> 2. STL中的函数式编程</h3><p>STL（Standard Template Library）标准模版库是C++的自带库，虽然C++一直以来被认为是“面向对象语言”，也常常被用作“C with class”，但是STL的作者却很少地用到了面向对象的编程范式，而是大量用到了以模版为支撑的泛型编程与函数式编程的范式，在使用STL时就能明显的感到这一点。比如排序函数<code>std::sort</code>的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ns &#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::sort(ns.<span class="built_in">begin</span>(), ns.<span class="built_in">end</span>(), [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;<span class="keyword">return</span> x &lt; y;&#125;);</span><br></pre></td></tr></table></figure><p>这里<code>std::sort</code>的第三个参数是用于比较大小的谓词，也就是一个匿名函数。常见的比较谓词在标准库中已经写好了，比如上面程序中的小于谓词可以写作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::sort(ns.<span class="built_in">begin</span>(), ns.<span class="built_in">end</span>(), <span class="built_in">std</span>::less&lt;<span class="keyword">int</span>&gt;());</span><br></pre></td></tr></table></figure><p>在函数式编程中被大量使用的“三件套”：Map、Filter、Fold在STL中也都有对应物。通过这3个函数的任意组合，我们可以创建处理变换数据的<strong>流水线</strong>（Pipeline），实现强大的功能。</p><p>让我们用一段小程序体会一下：假设现在我想实现一个统计代码行数的功能，输入是一个代码文本文件名组成的序列，输出是所有代码的总行数，但是要避免计入一些琐碎的小文件，也就是说对于行数少于10行的文件不计入总行数中。如果习惯了传统编程思维，很容易写出下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_lines_in_files</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;files)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  total_lines = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> c           = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;f : files) &#123;</span><br><span class="line">        <span class="keyword">int</span>           lines = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::ifstream <span class="title">in</span><span class="params">(f)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (in.<span class="built_in">get</span>(c)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                lines++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lines &gt;= <span class="number">10</span>)</span><br><span class="line">            total_lines += lines;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_lines;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使是一段简单的逻辑也用到了二重循环和几个维护局部状态的变量。这样写出来的程序确实能用，但是我们很快可以发现它的缺点：容易不小心出现bug，比如局部变量忘记初始化、循环条件错误、状态设置错误等；此外程序显得啰嗦，修改起来也并不方便。</p><p>如果换成函数式的思想，需要将程序的“可变状态”减少，因为一旦状态一多，出错的可能性就大幅增加。稍加思索我们就可以发现这段程序所做的操作都在“三件套”描述的范围内：</p><ol><li>Map：将文本文件名转换为文件的行数，转换函数的类型为<code>std::string -&gt; int</code></li><li>Filter：筛选出不少于10的行数，谓词函数的类型为<code>int -&gt; bool</code></li><li>Fold：计算出满足条件的行数之和，折叠函数为求和运算</li></ol><p>通过使用STL中“三件套”的对应物，我们可以写出以下程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_lines_in_files</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;files)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lines</span><span class="params">(files.<span class="built_in">size</span>())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> count_lines = [](<span class="built_in">std</span>::<span class="built_in">string</span> file) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::ifstream in(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::count(<span class="built_in">std</span>::istreambuf_iterator&lt;<span class="keyword">char</span>&gt;(in),</span><br><span class="line">                          <span class="built_in">std</span>::istreambuf_iterator&lt;<span class="keyword">char</span>&gt;(),</span><br><span class="line">                          <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> pred = [](<span class="keyword">int</span> i) -&gt; <span class="keyword">bool</span> &#123; <span class="keyword">return</span> i &lt; <span class="number">10</span>; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::transform(files.<span class="built_in">begin</span>(), files.<span class="built_in">end</span>(), lines.<span class="built_in">begin</span>(), count_lines); <span class="comment">// Map</span></span><br><span class="line">    <span class="keyword">auto</span> lines_end = <span class="built_in">std</span>::remove_if(lines.<span class="built_in">begin</span>(), lines.<span class="built_in">end</span>(), pred);<span class="comment">// Filter</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::accumulate(lines.<span class="built_in">begin</span>(), lines_end, <span class="number">0</span>, <span class="built_in">std</span>::plus&lt;<span class="keyword">int</span>&gt;());<span class="comment">// Foldl</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，高阶函数<code>std::transform</code>、<code>std::remove_if</code>、<code>std::accumulate</code>定义好了Map、Filter、Fold的操作，而我们只需要传入符合我们要求的函数，就可以描述出我们需要的功能，相比于命令式编程要清晰明了许多。另外，使用函数式的好处就是可以很轻易的复用已有的代码，比如在<code>count_lines</code>就用到了标准中的<code>std::count</code>函数来统计文件中的换行符的个数，其另外一个版本<code>std::count_if</code>就可以自己传入判断谓词，这样不管是什么我们外部的条件怎么变化，这个算法都可以适用。</p><p>在命令式的程序啰嗦且繁杂易出错的情况下，函数式程序仍然可以清晰地表述，并且更加符合人类的思维，这也是函数式的重大优点之一。此外还有一个函数式的闪光点：易于并行化。因为算法的高度复用性和引用透明性，函数式程序可以很轻易地变为并行程序，且不用当心各种竞争问题。实际上，函数式的并行算法只要在描述各种操作的高阶函数中完成一次就行，任何其他地方的调用都可以享受到并行的好处。比如只要将上面的代码加一个<code>std::execution::par</code>的标签就可以变为并行的版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::transform(<span class="built_in">std</span>::execution::par, files.<span class="built_in">begin</span>(), files.<span class="built_in">end</span>(), </span><br><span class="line">   lines.<span class="built_in">begin</span>(), count_lines);</span><br></pre></td></tr></table></figure><p>此外，函数式编程中还经常会用到一些常见的**“算术数据类型”**（Algebraic data type），它们在STL也有对应产物。比如在Sumed Type对应<code>std::variant</code>与<code>std::optional</code>、Product Type对应<code>std::pair</code>与<code>std::tuple</code>等。这些原本在函数式语言中普遍使用的类型的引入也让平时的命令式编程得到了改进。</p><h3 id="3-模版元编程与函数式编程"><a class="markdownIt-Anchor" href="#3-模版元编程与函数式编程"></a> 3. 模版元编程与函数式编程</h3><p>C++的另一大亮点就是对编译期编程的支持。编译期编程是一个庞大的话题，甚至可以写一本上千页厚的书。不过我们还是可以简单地了解一下编译期编程与模版元编程，因为它们其实与函数式编程非常接近。</p><p>模版元编程，顾名思义，是基于C++的模版而来的编程方式。C++的模版被创造的初衷是对泛型编程的支持，也就是创造出于类型无关的算法。不过人们很快发现它能做的事远远不止如此。由于模版中有着对<strong>模式匹配</strong>（Pattern Matching）的支持，它完全可以看做是一类纯函数式编程语言。举个经典的例子——计算斐波那契数列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> i&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fib</span> &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = Fib&lt;i<span class="number">-1</span>&gt;::value + Fib&lt;i<span class="number">-2</span>&gt;::value; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fib</span>&lt;1&gt; &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = <span class="number">1</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fib</span>&lt;0&gt; &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> x = Fib&lt;<span class="number">20</span>&gt;::value;<span class="comment">// x = 6765</span></span><br></pre></td></tr></table></figure><p>这个程序和函数式的程序如出一辙：</p><figure class="highlight ml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fun</span> <span class="type">Fib</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line">  | <span class="type">Fib</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">  | <span class="type">Fib</span> i = <span class="type">Fib</span>(i-<span class="number">1</span>) + <span class="type">Fib</span>(i-<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>模版编程所做的事情很简单，C++编译器对于每次出现的模版类型，会将其模版参数代入，<strong>实例化</strong>出特定参数的类型，如果这个类型本身内部引用别的模版类型，实例化的过程就会递归进行…是不是很像函数式编程中的递归过程？这里模版参数就对应着函数参数，类型名对应着函数名，类型内部定义对应着函数体。此外C++在对类型实例化时还会应用模式匹配，也就是说，匹配“最合适”的类型。在上面的例子中，<code>Fib&lt;1&gt;</code>和<code>Fib&lt;0&gt;</code>被称作是<strong>偏特化</strong>的类型，就如同在函数式语言中匹配的特例一样，当实例化到它们的时候，编译器会选择最具体、最合适的偏特化类型，从而形成递归的终止条件。</p><p>让我们试试用元编程实现经典的找零问题：给定整数n、一批硬币L，是否能找出总值为n的硬币子集。实现的大致思路是，每次取出列表中的第一枚硬币，如果该硬币的数额比当前总值小，则有两种选择：一是使用该硬币，二是不使用该硬币；如过该硬币的数额比当前总值大，那么一定不能使用该硬币。该算法在C++中可以用如下的模版元编程实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> Select, <span class="keyword">int</span> N, <span class="keyword">int</span> X, <span class="keyword">int</span>...Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change_Impl</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span>... Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> solution_count = Change_Impl&lt;<span class="number">2</span>, N, Ls...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span> X, <span class="keyword">int</span>...Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change_Impl</span>&lt;2, N, X, Ls...&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = Change_Impl&lt;<span class="keyword">int</span>(X &lt;= N), N, X, Ls...&gt;::value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span> X, <span class="keyword">int</span>...Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change_Impl</span>&lt;1, N, X, Ls...&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = Change&lt;N - X, Ls...&gt;::solution_count </span><br><span class="line">           + Change&lt;N, Ls...&gt;::solution_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span> X, <span class="keyword">int</span>...Ls&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change_Impl</span>&lt;0, N, X, Ls...&gt; &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> value = Change&lt;N, Ls...&gt;::solution_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span>&lt;0&gt; &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> solution_count = <span class="number">1</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Change</span>&lt;N&gt; &#123;</span> <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> solution_count = <span class="number">0</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Change&lt;<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>&gt;::solution_count;<span class="comment">// 3种(1+3+6,6+4,1+4+5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来十分复杂，但是仔细看的话，这个程序只是在简单地使用模式匹配。传入<code>Change</code>的第一个模版参数为目标总额，其余的模版参数为硬币数额列表，以一个变长模版参数包表示<code>int... Ls</code>。底下两行匹配的是硬币列表为空时的情况，当此时的目标金额为0时则有一种解决方法；否则没有解决方案。为了方便模式匹配，还定义了<code>Change_Impl</code>结构体，它仅接收非空列表，并会对目标金额与首枚硬币的金额进行判断，依次作为匹配依据。<code>Change</code>最后会得到找零方案的个数，比如硬币列表为<code>[1, 3, 6, 4, 5]</code>，目标金额为<code>10</code>时得到的找零方案有3种。</p><p>可以看出，模式匹配让我们可以很方便的实现判断逻辑，配合递归可以实现复杂的逻辑。借助函数式编程的思想，模版元编程也可以有很强的表达能力。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>本文简单的概述了一些函数式思想在C++中的应用，这种简洁高效的编程范式让C++这门被广泛运用的语言有了更强的表达能力。我们也看到了，函数式编程让我们的思维从“告诉计算机每一步的步骤”转变为“告诉计算机问题是什么”，从而得到更接近数学的抽象能力，也让程序免于Bug的灾难。不过，函数式编程也不是万能的，有许多问题不能用“纯函数式”的思想实现。而C++这门多范式语言让我们有了更加丰富的选择：不管是命令式、面向对象、函数式，还是泛型编程，都可以作为工具，只要我们将它们用在合适的地方。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本模型——球的N种画法</title>
      <link href="/2020/03/12/Sphere/"/>
      <url>/2020/03/12/Sphere/</url>
      
        <content type="html"><![CDATA[<p>最近在做个小渲染Demo，展示效果需要一些基本图元。基本图元的三角网格均可以程序化生成，这篇文章主要收集了这些生成方法。</p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>图形学中，模型表示的方法很多，它们大致可以分为两类：<strong>显式表示（Explicit）<strong>与</strong>隐式表示（Implicit）</strong>。</p><p>显式表示的常见方法有：点/线/多边形表示和曲线/曲面表示等。而隐式表示，就可以直接给出几何体表面的定义方程，却不用管其如何求解：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">F(x,y,z)=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span></p><p>比如对于三维球体，我们知道它的隐式表示为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>F</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo>+</mo><msup><mi>z</mi><mn>2</mn></msup><mo>−</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">F(x,y,z)=x^2+y^2+z^2-r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0585479999999998em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span></span></p><p>实时渲染中我们主要使用的是多边形表示，就需要将几何体的隐式表示转换为显式表示。常用的方法是将隐式表示的方程先转化为<strong>参数方程</strong>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">f(s,t)=(x(s,t),y(s,t),z(s,t))^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></p><p>参数方程本身作为一种显式表示，其给出了几何体表面的点坐标，再将这些点坐标连接起来形成为多边形网格（一般是三角形）后，就得到了几何体最终的显式表示。</p><p>本文主要介绍几种球体的转换方法。</p><a id="more"></a><h2 id="球坐标转换"><a class="markdownIt-Anchor" href="#球坐标转换"></a> 球坐标转换</h2><p>对于球面来说，最常见的参数化方式是采用球坐标公式。</p><img src="/images/gl_sphere01.png" alt="球坐标系，图来自[2]" style="zoom: 50%;" /><p>图中球坐标系有三个参数：半径<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>， 方位角<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>和倾斜角<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>。如果将球体看做是地球的话，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>角就是经度，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>角就是维度。为了方便起见，我们在本文中采用的球坐标系与上图有一些不同（因为实在找不到图了= =）：我们将<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>角定义为与z轴的夹角（注意这里z朝上）而不是与xy平面的夹角，这时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>角表示的是余纬（colatitude），也就是$90^{\circ} - $ 纬度。这样定义的好处是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>角的取值不会涉及到负数，方便我们进一步处理。</p><p>上述定义下的球坐标公式为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>s</mi><mi>i</mi><mi>n</mi><mi>ϕ</mi><mo>⋅</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>s</mi><mi>i</mi><mi>n</mi><mi>ϕ</mi><mo>⋅</mo><mi>s</mi><mi>i</mi><mi>n</mi><mi>θ</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>z</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>c</mi><mi>o</mi><mi>s</mi><mi>ϕ</mi></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{aligned}x &amp;= r \cdot sin\phi \cdot cos\theta \\y &amp;= r \cdot sin\phi \cdot sin\theta \\z &amp;= r \cdot cos\phi\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">ϕ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">ϕ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">ϕ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其中两个角的在弧度制下取值范围是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn><mi>π</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\theta \in [0,2\pi]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mi>π</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\phi \in [0,\pi]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mclose">]</span></span></span></span>。</p><p>接下来的问题是如何给<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>取值。我们首先想到的自然是均匀取值，也就是用以下的公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>θ</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>2</mn><mi>π</mi><mo>⋅</mo><mfrac><mi>i</mi><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>ϕ</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>π</mi><mo>⋅</mo><mfrac><mi>j</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>s</mi></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}\theta &amp;= 2\pi \cdot \frac{i}{sectors} \\\phi &amp;= \pi \cdot \frac{j}{stacks}\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.645040000000001em;vertical-align:-2.0725200000000004em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5725200000000004em;"><span style="top:-4.57252em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0725200000000004em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5725200000000004em;"><span style="top:-4.57252em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.33652em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.0725200000000004em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>此处我们把横向（经度）上的划分称为sectors，纵向（维度）上的划分称为stacks。通过控制不同的横向与纵向的分段数，我们就可以控制球体的精度。由于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>角的范围是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">ϕ</span></span></span></span>角的两倍，为了让生成的球在横向与纵向上有相同密度的点，一般设定<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi><mo>=</mo><mn>2</mn><mo>×</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">sectors = 2 \times stacks</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span></span></span></span>，这样控制精度的参数就仅需一个。</p><p>球坐标本身经过三角函数的变换，角度上的均匀分布在球面上并不均匀。从下图我们可以看出在南北极的点分布要比赤道上的密一些（如果看成是地球的话）。</p><img src="/images/gl_sphere02.png" alt="球坐标下分区是不均匀的，图来自[2]" style="zoom: 67%;" /><p>点的分布不均导致了每个小区的面积并不相等，不过与生成球面上的随机点不同，这并不妨碍渲染的结果，因为从模型本身的轮廓来说，正视图与俯视图看到的圆都分别有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mo>×</mo><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">2 \times stacks</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span></span></span></span>条边和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">sectors</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span></span></span></span>条边，而我们已经设定了它们相等。</p><p>有了顶点坐标的计算公式后，下一步就是将顶点连接形成多边形网格。一般我们采用的是三角形网格（Triangle Mesh），需要把上图的四边形切分为2个三角形。由于渲染API一般要利用“背面剔除”特性加速渲染，我们需要保证三角面的顶点顺序一致。如果正面的顶点顺序为逆时针，则一个四边形的两个三角形的顶点就是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">{</mo><mi>k</mi><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mn>2</mn><mo separator="true">,</mo><mi>k</mi><mn>1</mn><mo>+</mo><mn>1</mn><mo stretchy="false">}</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>k</mi><mn>1</mn><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>k</mi><mn>2</mn><mo separator="true">,</mo><mi>k</mi><mn>2</mn><mo>+</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{k1,k2,k1+1\},\{k1+1,k2,k2+1\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>。储存顶点时，一般可以共享相邻三角形的顶点，以减少储存空间的开销；不过，如果共享顶点的法线、贴图坐标不同的话，就不能采用共享顶点了。</p><img src="/images/gl_sphere03.png" alt="三角网格，图来自[2]" style="zoom: 67%;" /><p>基础模型的一个好处就是具有良好定义的贴图映射、法线信息。对于球来说，其每个顶点的法线就是单位化后的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y,z)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span>坐标，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mi mathvariant="normal">/</mi><mi>r</mi><mo separator="true">,</mo><mi>y</mi><mi mathvariant="normal">/</mi><mi>r</mi><mo separator="true">,</mo><mi>z</mi><mi mathvariant="normal">/</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x/r,y/r,z/r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>。对于球的贴图映射有多种方案，在本方案中可以直接用归一化的方位角和倾斜角来获取，即</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>u</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mi>θ</mi><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><mo>=</mo><mfrac><mi>i</mi><mrow><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi></mrow></mfrac></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>v</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mfrac><mi>ϕ</mi><mi>π</mi></mfrac><mo>=</mo><mfrac><mi>j</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>s</mi></mrow></mfrac></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{aligned}u &amp;= \frac{\theta}{2\pi} = \frac{i}{sectors} \\v &amp;= \frac{\phi}{\pi} = \frac{j}{stacks} \\\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.80004em;vertical-align:-2.15002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.65002em;"><span style="top:-1.8999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-1.8999899999999998em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.1999899999999997em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.90002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.15002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.60744em;"><span style="top:-4.6074399999999995em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mord mathdefault">u</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.10744em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.60744em;"><span style="top:-4.6074399999999995em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.3714399999999998em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3365200000000002em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.10744em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>由于球坐标的方案与球体UV坐标有很强的关系，这种生成的球体有时也被称作UV球体（UV Sphere）。</p><p>以上，球坐标方案的生成代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> r = <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> stacks = <span class="number">10</span>, sectors = <span class="number">2</span> * stacks;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; verts, norms, texCoords;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indices;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= stacks; j++) &#123;</span><br><span class="line">    <span class="keyword">float</span> v   = (<span class="keyword">float</span>)j / stacks;</span><br><span class="line">    <span class="keyword">float</span> phi = PI * v;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= sectors; i++) &#123;</span><br><span class="line">        <span class="keyword">float</span> u     = (<span class="keyword">float</span>)i / sectors;</span><br><span class="line">        <span class="keyword">float</span> theta = <span class="number">2</span> * PI * u;</span><br><span class="line">        </span><br><span class="line">        verts.push_back(r * <span class="built_in">sin</span>(phi) * <span class="built_in">cos</span>(theta));</span><br><span class="line">        verts.push_back(r * <span class="built_in">cos</span>(phi));</span><br><span class="line">        verts.push_back(r * <span class="built_in">cos</span>(phi) * <span class="built_in">sin</span>(theta));</span><br><span class="line">        norms.push_back(<span class="built_in">sin</span>(phi) * <span class="built_in">cos</span>(theta));</span><br><span class="line">        norms.push_back(<span class="built_in">cos</span>(phi));</span><br><span class="line">        norms.push_back(<span class="built_in">cos</span>(phi) * <span class="built_in">sin</span>(theta));</span><br><span class="line">        texCoords.push_back(u); texCoords.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; stacks; j++) &#123;</span><br><span class="line"><span class="keyword">int</span> k1 = j * (sectors + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> k2 = k1 + sectors + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sectors; i++, k1++, k2++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">            indices.push_back(k1);</span><br><span class="line">            indices.push_back(k1 + <span class="number">1</span>);</span><br><span class="line">            indices.push_back(k2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j != stacks - <span class="number">1</span>) &#123;</span><br><span class="line">            indices.push_back(k2);</span><br><span class="line">            indices.push_back(k1 + <span class="number">1</span>);</span><br><span class="line">            indices.push_back(k2 + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码需要注意的是，在顶部与底部的小区块，由于有一个顶点重合，只用绘制一个三角形即可。</p><h2 id="细分多面体"><a class="markdownIt-Anchor" href="#细分多面体"></a> 细分多面体</h2><p>细分多面体也是一种常见的创建球体Mesh的方法。其相对UV球体，点的分布更加均匀（UV球体的很多顶点浪费在了靠近南北极的地方），因此用较少的顶点就可以实现不错的精度。</p><p>细分的方法也比较简单，对于每个三角形来说，每经过一步，就分裂为4个新的三角形，递归地进行这个过程，就可以得到面数更多更精细的模型。</p><p><img src="/images/icosphere-tessellation.png" alt="" /></p><p>当然，需要将这些多出来的顶点移到球壳上，不然怎么细分都还是球面。。因为我们已经假定了球心的位置在坐标原点，而球壳上的点到球心的距离为一常数，我们只需要让点沿着过原点的线移动并设定其到原点长度为半径即可。形象的说，这个过程类似把把多边形表面“膨胀”出去的过程，如下图所示：</p><p><img src="/images/icosphere-bulge.gif" alt="" /></p><p>有个这个过程，我们就可以把任意多面体细分为球体了。</p><p>下面以正二十面体为例，详细说一下这个过程。</p><h3 id="细分正二十面体icosphere"><a class="markdownIt-Anchor" href="#细分正二十面体icosphere"></a> 细分正二十面体（Icosphere）</h3><p>正二十面体本身顶点比较均匀，适合作为基础几何体，这样细分为球体后分布依然会比较均匀。正二十面体有12个顶点，将两个顶点放在顶部<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>与底部<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0,0,-1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，剩下的10个顶点分别在高度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>±</mo><mi>t</mi><mi>a</mi><mi>n</mi><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\pm tan\frac{1}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord">±</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>的平面上，且每个平面上的点正好是正五边形。</p><table><thead><tr><th>侧视图</th><th>俯视图</th></tr></thead><tbody><tr><td><img src="/images/gl_sphere09.png" style="zoom: 50%;" /></td><td><img src="/images/gl_sphere10.png" style="zoom:50%;" /></td></tr></tbody></table><p>用球坐标可以简单地算出这些点来：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>x</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><msup><mi>n</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⋅</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mn>72</mn><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>y</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><msup><mi>n</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>⋅</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mn>72</mn><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>z</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>r</mi><mo>⋅</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>t</mi><mi>a</mi><msup><mi>n</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}x &amp;= r \cdot cos(tan^{-1}(\frac 1 2)) \cdot cos(72 \cdot n) \\y &amp;= r \cdot cos(tan^{-1}(\frac 1 2)) \cdot sin(72 \cdot n) \\z &amp;= r \cdot sin(tan^{-1}(\frac 1 2))\end{aligned}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.922320000000001em;vertical-align:-3.2111600000000005em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.71116em;"><span style="top:-5.71116em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord mathdefault">x</span></span></span><span style="top:-3.40372em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span><span style="top:-1.0962799999999997em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.2111600000000005em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.71116em;"><span style="top:-5.71116em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord">2</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord">7</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.40372em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord">2</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord">7</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-1.0962799999999997em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord">2</span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord">1</span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.2111600000000005em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>有了基础的正多面体，细分的过程就很容易了，分别区三角形三条边上的中点，并将中点投影到球壳上即可。可以用以下的伪代码来表述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Subdivide(triangles, radius)</span><br><span class="line">newTriangles &#x3D; &#123;&#125;</span><br><span class="line">    for (each triangle &#123;A,B,C&#125; in triangles)</span><br><span class="line">        D &#x3D; Normalize(A + B) * radius</span><br><span class="line">        E &#x3D; Normalize(A + C) * radius</span><br><span class="line">        F &#x3D; Normalize(B + C) * radius</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; Compute 3 new vertices by spliting half on each edge</span><br><span class="line">        &#x2F;&#x2F;         A</span><br><span class="line">        &#x2F;&#x2F;        &#x2F; \</span><br><span class="line">        &#x2F;&#x2F;       D---E</span><br><span class="line">        &#x2F;&#x2F;      &#x2F; \ &#x2F; \</span><br><span class="line">        &#x2F;&#x2F;     B---F---C</span><br><span class="line">        newTriangles +&#x3D; &#123;A, D, E&#125;</span><br><span class="line">        newTriangles +&#x3D; &#123;D, B, D&#125;</span><br><span class="line">        newTriangles +&#x3D; &#123;D, F, E&#125;</span><br><span class="line">        newTriangles +&#x3D; &#123;E, F, C&#125;</span><br><span class="line">        </span><br><span class="line">    return newTriangles</span><br></pre></td></tr></table></figure><p>细分的效果大致如下所示，可以看到点的分布相比之前的UV球体要均匀了许多。</p><table><thead><tr><th>2次细分</th><th>4次细分</th></tr></thead><tbody><tr><td>512个顶点，320个三角形</td><td>7820个顶点，5120个三角形</td></tr><tr><td><img src="/images/icosphere-2.png" alt="" /></td><td><img src="/images/icosphere-4.png" alt="" /></td></tr></tbody></table><p>然而，这样细分出来的球体也不是十全十美的，它有一个致命的问题——就是贴图UV。由于细分的球体本身并不能直接得到贴图坐标，我们需要借助之前球坐标系的方法，应用其逆过程，将顶点坐标转换为球坐标再以两个角度作为UV。公式如下：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">{</mo><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>u</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>0.5</mn><mo>+</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>π</mi></mrow></mfrac><mi>a</mi><mi>r</mi><mi>c</mi><mi>t</mi><mi>a</mi><mi>n</mi><mn>2</mn><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>v</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mn>0.5</mn><mo>−</mo><mfrac><mn>1</mn><mi>π</mi></mfrac><mi>a</mi><mi>r</mi><mi>c</mi><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex">\left\{\begin{aligned}u &amp;= 0.5 + \frac{1}{2\pi} arctan2(x, y) \\v &amp;= 0.5 - \frac{1}{\pi} arcsin(z) \\\end{aligned}\right.</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.61488em;vertical-align:-2.05744em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.55744em;"><span style="top:-4.55744em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord mathdefault">u</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.05744em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.55744em;"><span style="top:-4.55744em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.32144em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.05744em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>然而，当我们将贴图应用在球体上后，却会发现如下的效果：</p><p><img src="/images/icosphere-warping.png" alt="" /></p><p>可以看到有一条明显Z型扭曲带，带上的三角形纹理好像被压缩了一样。很容易发现问题的原因：当贴图UV的值超过1.0时，由于转过了一圈，根据上面的式子算出的UV会回到0。这样就导致了在靠近这个UV边界的三角形内，UV的值一下子从接近1的地方跳跃到了接近0的地方，导致了贴图被压缩的现象。</p><img src="/images/sphere_zipper_explained.jpg" style="zoom:67%;" /><p>正如上图所示，本该是蓝色的三角形被映射到了黄色的三角形，导致了贴图的严重拉伸。要修复这个问题，只需把错误的三角形纠正过来就行。注意到这些错误的三角形，其顶点环绕顺序与正确三角形是相反的。原本的蓝色三角形是瞬时针环绕，被错误映射后变为了逆时针环绕。通过这个特征我们就可以发现错误的三角形了：只需要判断一下三角形的环绕顺序，即三角形两边的叉积的z坐标符号即可（虽然UV只是二维的点，但我们可以将其看做是z坐标为0的三维点，这样就可以进行叉乘运算了）。要为每个修正坐标的顶点生成一个新的顶点以解决共享顶点的问题。</p><p>这样处理完后，之前的Z字接缝就没有了。不过，在靠近两极的地方，UV仍有明显的扭曲。</p><img src="/images/icosphere-top.png" style="zoom: 67%;" /><p>问题显然还是因为共享顶点导致的UV坐标拉伸的缘故，从下图中可以明显看出来中间的三角形被严重拉伸。</p><p><img src="/images/pole_triangles_mapped.jpg" alt="" /></p><p>显然，两极的顶点对于每个三角形均需要不同的贴图坐标。然而问题是，该怎样得到UV呢？肯定不能用之前的式子算了，因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>c</mi><mi>t</mi><mi>a</mi><mi>n</mi><mn>2</mn><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">arctan2(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span>本身在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x=y=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>处的值是没有良定义的。遗憾的是，这个问题没有一个完美的解决方案，因为在球顶的这块位置顶点重合，一整条边都对应到了一个点上，显然我们没法让其在贴图完美地对应到一个矩形区域里去。一种不太完美的解决方案是，将每个三角形贴图坐标的U取为下面两个顶点U的平均值。这样虽然球顶的顶点没有统一对应到一个UV上，但总的拉伸降到了最低。修改后的效果如下。</p><img src="/images/icosphere-topfix.png" style="zoom:67%;" /><p>可以看到扭曲没有了，两个相连三角形的贴图有比较明显的接缝。这个接缝如果要解决的话，只能对贴图本身做处理了：将UV展开后让贴图上几何位置相邻的地方变化连续。事实上，将一个平面（贴图）包裹在一个球体上本身而没有扭曲的办法是不存在的，如果你对比过世界地图和实际的地球仪就会发现，靠近南北极的国家在地图上的大小要比实际的大小差很多。实际上，之前在UV球体上用的方法叫做Cylindrical Projection，其本质上是先把贴图卷成了一个圆柱体，然后再将其贴到球体上去，这就导致了约是靠近南北极的位置，贴图的扭曲就越大。</p><h3 id="细分立方体cubesphere"><a class="markdownIt-Anchor" href="#细分立方体cubesphere"></a> 细分立方体（CubeSphere）</h3><p>当然，细分还可以用其他的基础几何体来进行，这里再介绍一种使用立方体来进行细分的方式，这也是Unity中采用的球体。立方体的基础图元在这里是四边形，四边形的细分与三角形有细微不同但总体上类似：在四边形的四条边上取中点，还要在四边形的中间取一个点，再将中心的点与4个中点连起来，这样一个四边形就分割为4个小四边形。在有了细分后的立方体后，我们再按照上面讲过的方法，将点“投影”到球体上就可以了。当然，我们也可以直接一步到位地得到细分后的立方体，之后进行投影，效果是一样的。</p><table><thead><tr><th>无细分</th><th>1次细分</th><th>2次细分</th><th>3次细分</th></tr></thead><tbody><tr><td><img src="/images/gl_sphere13a.png" alt="" /></td><td><img src="/images/gl_sphere13b.png" alt="" /></td><td><img src="/images/gl_sphere13c.png" alt="" /></td><td><img src="/images/gl_sphere13d.png" alt="" /></td></tr></tbody></table><p>如果按照之前的Cylindrical Projection的方式投影贴图，仍然需要像之前一样处理顶部与底部的错误UV。不过，细分立方球体还有更直接的贴图方式：由于其是由一个立方体变换来的，可以借用立方体的UV来进行处理。也就是说像Cubemap这样的贴图可以很方便地拿来使用。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li><a href="https://en.wikipedia.org/wiki/Implicit_surface">Wikipedia - Implicit surface</a></li><li><a href="http://www.songho.ca/opengl/gl_sphere.html">OpenGL Sphere</a></li><li><a href="https://stackoverflow.com/questions/7687148/drawing-sphere-in-opengl-without-using-glusphere">Drawing Sphere in OpenGL without using gluSphere()?</a></li><li><a href="https://www.alexisgiard.com/icosahedron-sphere/">Generating and UV mapping an icosahedron sphere</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码阅读笔记</title>
      <link href="/2020/01/14/Proj-Reading-Notes/"/>
      <url>/2020/01/14/Proj-Reading-Notes/</url>
      
        <content type="html"><![CDATA[<p>记录一些遇到过的大大小小的C++坑，或者是C++比较优秀的惯用技巧、设计模式~</p><p>我将平时阅读的一些项目代码的笔记总结于此。</p><p>俗话说，读代码比写代码要难数倍，尤其是读别人的代码。的确如此，不过，不管从什么角度统计，我们花在读代码上的时间都远多于写代码的时间，而如何将代码写的清晰易懂、便于维护，又是一个不简单的问题。在代码的“品味”上，怎样做出优雅的设计，是一件需要积累的工作，没有十足的经验恐怕是难以达成。虽说经验可以通过自己写代码来增加，但我一直认为，阅读好其他人的代码，品味其中的设计思路，吸收其中的设计优点，才会如虎添翼，迅速增加自己的“代码感”。</p><p>此外，阅读代码本身也是一门学问。如何高效地阅读数量众多，成千上万行起步的代码，并将其中的设计架构提取出来，也不是一件容易的事。</p><a id="more"></a><h3 id="glm"><a class="markdownIt-Anchor" href="#glm"></a> GLM</h3><p>GLM是一个Header-only的3D数学库，实现了C++上的GLSL类型与函数，里面的类型定义大量用到了模版。下面描述一下项目从上（用户接口）到下（底层实现）的结构。</p><ol><li><p>上层的用户可见API均放在了<code>GLM/</code>根目录下，头文件以<code>*.hpp</code>作为扩展名。用户可见的头文件可分为3种：</p><ul><li>一种是综合性导入的头文件，里面仅有其他头文件的导入，这种文件主要是为了方便用户导入相关API。比如GLM将项目分为了4个模块（核心功能、稳定扩展、推荐扩展、实验性扩展），对应的就有两个综合性导入头文件：一个用于导入核心API的<code>glm.hpp</code>，一个用于导入其余的扩展API的<code>ext.hpp</code>，方便用户导入。</li><li>另一些比较具体的类型导入头文件，这种头文件主要是解决同种类型的头文件较多的情况，比如<code>vec3.hpp</code>里面就导入了各种类型的vector3头文件，这些头文件里面主要定义了类型模版的别名，这样使用时就可以不需要填写很长的模版参数了（同时也定义了与GLSL规范相同的类型名称）。</li><li>还有一种是包含了声明的头文件（主要是函数声明），这些函数均为模版函数（由于参数类型本身带模版）。声明的头文件中并没有实现，在声明头文件的底部引入了<code>detail/</code>里面实际的实现。</li></ul><p>以上所有的用户可见API均在命名空间<code>glm</code>下。</p></li><li><p>核心功能的实现在<code>detail/</code>文件夹下。这个文件下的文件扩展名主要就2种：<code>*.hpp</code>为声明，<code>*.inl</code>为具体实现。一个例外是<code>glm.cpp</code>，该文件中显示实例化了各个类的模版，主要是为了能使该库以静态库或动态库的方式使用。以<code>_*.hpp</code>开头的这些文件是库内部使用一次或多次的头文件，主要实现了一些通用的功能或宏相关的检测处理等：</p><ul><li><code>_features.hpp</code>里主要放了有很多编译器功能检测宏，如果发现了编译器支持某些额外特性，就定义一个<code>GLM_CXX??_???</code>的宏，表示可以使用该特性。（不过我没有看到有哪个文件使用了这个文件？）</li><li><code>_fixes.hpp</code>里清除了某些编译环境可能预先定义的宏，防止其产生干扰，如<code>max</code>、<code>min</code>等。</li><li><code>_swizzle.hpp</code>、<code>_swizzle_func.hpp</code>定义了与swizzle相关的类与宏。</li><li><code>_vertorize.hpp</code>实现向量化，就是将同一个函数作用到一个向量上，可以是一元函数或二元函数。</li></ul><p>上面的前两个文件就是为了增加可移植性。</p><p>接下来一个比较重要的文件是<code>setup.hpp</code>，基本上每个文件都会直接或间接地引用到该文件。这个文件中定义了GLM的项目信息宏（版本号、名称字符串），会根据CMake中定义的一些编译选项宏进一步地定义一些宏/类型等，如是否开启编译信息输出、是否开启static_assert、是否使用constexpr、是否使用forceinline等等。此外，该文件内还含有编译器支持的C++特性的检测，如果编译时支持某较新C++的特性，就会定义一个<code>GLM_HAS_???</code>，后序就可以以此使用不同的代码，以增强可移植性。这些根据编译选项定义下来的宏要么在后序作为条件编译用在了<code>#ifdef</code>这样的地方，要么作为关键字展开以实现不同的效果（如<code>GLM_INLINE</code>可以展开为普通的<code>inline</code>或<code>__forceinline</code>或<code>__attribute__((__always_inline__))</code>），也可以根据平台定义统一的类型（如表示长度的<code>length_t</code>是<code>size_t</code>还是<code>int</code>）。</p></li><li><p>之前说了函数的声明在根目录下，而函数的定义在<code>detail/</code>文件夹下，且均以<code>func_*.inl</code>作为文件名。在每个<code>*.inl</code>文件中，可以之前的用户可见函数声明相对应的函数实现。这些实现如果涉及到的只是简单的模版参数，那么在此就直接实现了相关代码；如果涉及到较复杂的实现（例如实现与向量长度有关），那么这段实现中并不会做实际工作，只是首先进行模版参数检测static_assert，然后转发到一个struct的特定静态方法<code>call</code>去。相应的struct定义在命名空间<code>glm::detail</code>中，用户一般不可见。通过对向量长度的偏特化，就可以针对不同长度的向量实现特定的方法，而不支持的长度最终会落到一个空的struct中，导致编译错误。struct中的特定实现可能会用到API本身，这个时候就会从上级根目录中导入其头文件。有一些用到了STL库中已有的函数（比如<code>max</code>），其就在实现中直接通过<code>using std::max</code>进行导入。对于STL函数作用在向量的每个元素上时，用的就是之前说的<code>_vertorize.hpp</code>中的向量化，向量化本身的实现与向量长度有关，也是放在偏特化的struct中。</p></li><li><p>向量/矩阵相关的类声明在<code>detail/type_*.hpp</code>中，类定义在<code>detail/type_*.inl</code>中，类定义也有与函数定义类似的转发机制（主要为了处理SIMD相关），转发的目标均在<code>glm::detail</code>命名空间下，用户不可见。</p></li><li><p>SIMD的转发方式：由于SIMD要求对象是对齐的，如果检测到是对齐的类型，就可以采用SIMD。因此GLM在之前转发到静态方法<code>call</code>时还额外多提供了一个模版参数，表示是否对齐，如果为<code>true</code>就会转发到SIMD的实现。这个是否对齐的判断是用type traits实现的，利用<code>glm::detail::is_aligned</code>完成。在<code>qualifier.hpp</code>中定义了描述精度、对齐的qualifier，根据这些qualifier表示的含义就可以写出对应的判断对齐的type traits。为了实现对齐的要求，这里也定义了一个叫<code>storage</code>的struct，这个struct中会根据align的要求定义不同大小的结构体，之后在具体的类中，将这些结构体与数据成员定义在一个union中即可实现对齐。此外对齐了的<code>storage</code>结构体中可能直接利用SIMD类型进行表示，这样长度就肯定符号SIMD的要求。SIMD的实现函数部分在<code>detail/func_???_simd.inl</code>文件中，类部分就在<code>detail/type_???_simd.inl</code>中，如果检测到支持SIMD且开启的编译选项，SIMD实现文件就会被加入到普通实现文件的底部。这些实现里面可能会用到一些共用的作用于SIMD类型的函数，其定义在<code>simd/*.h</code>中。这里面的函数同时也面向想要使用SIMD编写算法的高级用户。<code>simd/platform.h</code>文件中进行了编译器与平台检测，得知是否开启SSE/AVX/NEON等，再以此导入对应的intrinsic头文件，并对原生的SIMD类型做了typedef，保证不同平台的SIMD类型一致。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Realtime GI Introduction</title>
      <link href="/2019/11/22/slide/Realtime-GI/"/>
      <url>/2019/11/22/slide/Realtime-GI/</url>
      
        <content type="html"><![CDATA[<h1 id="realtime-gi-in-games"><a class="markdownIt-Anchor" href="#realtime-gi-in-games"></a> Realtime GI In Games</h1><p>Notes:</p><p>内容主要来自EA Seed团队在17年Siggraph上关于GI的综述性talk</p><p>====</p><!-- .slide: data-background="#2874A6" --><h3 id="提纲"><a class="markdownIt-Anchor" href="#提纲"></a> 提纲</h3><ul><li>GI在游戏中的发展<ul><li>Precomputation</li><li>Volume based methods</li><li>Local Approximation</li></ul></li><li>当前方法的问题</li><li>未来游戏的GI</li></ul><!--~~附加：体素游戏的GI，Minecraft~~--><p>====</p><h3 id="whats-gi"><a class="markdownIt-Anchor" href="#whats-gi"></a> What’s GI</h3><p>==</p><p><img src="/images/x2-direct-villa.jpg" alt="Picture from NVIDIA" /></p><p>Direct illumination only</p><p>==</p><p><img src="/images/x2-global-villa.jpg" alt="Picture from NVIDIA" /></p><p>Direct + global illumination</p><p>Notes:</p><p>学术上认为global包括了direct，但游戏业界global一般仅只indirect</p><p>==</p><p>GI is more</p><p><img src="/images/gi_pic.png" alt="" /></p><p>==</p><p>GI描述了物体之间的光交互，但游戏领域主要关注的还是BRDF层面的GI。</p><p>GI如此吸引游戏开发者的原因是，它很大程度上解放了美术…</p><p>毕竟，手工调整是比不上模拟的</p><p>==</p><p><strong>近似化</strong>与<strong>简化</strong>是游戏开发最强力的工具</p><p>====</p><h3 id="gis-evolution-in-game"><a class="markdownIt-Anchor" href="#gis-evolution-in-game"></a> GI’s evolution in Game</h3><p>====</p><h3 id="precomputation"><a class="markdownIt-Anchor" href="#precomputation"></a> Precomputation</h3><p>==</p><p><strong>Surface Caching</strong></p><p><img src="/images/surface-caching.png" alt="" /></p><p>起源——Quake</p><p>模型的每个顶点存一个8-bit预先烘培好的光照值</p><p>Notes:</p><p>可以看做是最早期的Lightmap，最初只有单色亮度，后来加入了RGB亮度</p><p>这种Lightmap一般用辐射度方法预先计算，使用的时候与材质的albedo color相乘</p><p>AO可以bake进材质的diffuse color里面，但由于diffuse贴图一般是共享的，只能分开存放</p><p>每个物体的表面都需要编码进Lightmap UV里面，一般是自动完成加手动调整（防止重叠）</p><p>Lightmap很少做Mipmap，一个原因是本来就小，另一个原因是不能重叠要求有较大间隙</p><p>展开UV时要注意几何上连续的部分在UV上也要连续，不然会导致缝隙的artifact</p><p>==</p><p><strong>Radiosity Normal Mapping</strong></p><p><img src="/images/radiosity-normal-mapping.png" alt="" /></p><p>储存三个基方向的亮度值，以法线插值</p><p>能近似出Rough Specular的效果</p><p>缺点：插值的结果并不是物理正确的</p><p>Notes:</p><p>Lightmap最初只记录一个方向（法线）的光照信息，这让使用了法线贴图的模型难以使用</p><p>Valve在半条命2中提出了RNM，后来被很多游戏使用（便宜！只使用9个浮点数）</p><p>Far Cry里用里一个变种方法，只存了切线空间的主光照方向(2)，主光照颜色(3)，和一个系数表示directional的比例(1)，共6个浮点数</p><p>==</p><p><strong>Spherical Harmonics Lightmaps</strong></p><p><img src="/images/spherical-harmonics-lightmaps.png" alt="" /></p><p>Lightmap的纹素变为了SH形式储存的有方向性的光照信息</p><p>SH为球面上的一个连续函数（半球面的基要改为H-basis）</p><p>适合频率低的Diffuse，但Specular就不行了</p><p>Notes:</p><p>SH形式的Lightmap里面存的是Radiance，原Lightmap存的是Irradiance。</p><p>SH一般由离线光子映射计算出</p><p>三阶SH一共9个SH系数，可以实现很好的效果；开销略大（27个浮点数）</p><p>这是因为SH随着阶数变高，需要的系数个数会变得很多，多到内存里存不下</p><p>动态物体也可以通过Light Probe的方法访问到SH的信息，进而实现GI效果</p><p>==</p><p><strong>Spherical Gaussians Lightmaps</strong></p><p><img src="/images/spherical-gaussians-lightmaps.png" alt="" /></p><p>用不同的基函数替换SH，获得更多细节的Radiance</p><p>适合Diffuse和Specular，数据表示直观紧凑，可以随意<em>叠加</em></p><p>比如Last of Us里面就采取了Ambient+Dominant direction</p><p>Notes:</p><p>一个SG系数就可以储存一个lobe的光照</p><p>The Order:1886里面用5~9个SG系数实现了高质量的Specular GI</p><p>==</p><p><strong>Precomputed Radiance Transport</strong></p><p><img src="/images/precomputed-form-factors.png" alt="" /></p><p>预计算光源对某位置的贡献，以一个Transport函数表示</p><p>可以支持多动态光源的GI计算，如Time of day</p><p>缺点：场景变化就要重新计算可见性</p><p>Notes:</p><p>由于光的线性叠加性，不同光源的贡献可以分离计算再叠加</p><p>实际上不一定是光源，可以是任意发光表面，因为受光平面不需要知道原光源的信息</p><p>Transport函数可以接受不同形式的输入与输出</p><p>比如3阶SH到3阶SH，其开销较大，此时Transport函数相当于9x9矩阵</p><p>Far Cry3-4中就用了2阶SH作为输入，自定义的4方向basis作为输出</p><p>Assassin’s Creed 4中用一个basis表示阳光，但是提前计算出一天中不同时间的Transport</p><p>Enlighten的实时GI用到了该方法</p><p>==</p><p><strong>Light Probes</strong></p><p><img src="/images/probe-gi.png" alt="" /></p><p>将光照信息（一般是SH）储存在空间中（一般用3D texture储存，<strong>irradiance volumes</strong>）</p><p>动态物体获取临近几个光照信息，插值得到任意位置的光照</p><p>Notes:</p><p>光照信息可以来着静态的SH、SG、Ambient dice，或是动态的PRT</p><p>Unity中的Light Probe储存的是点云（手动放置），并在四面体内插值</p><p>适合动态物体，但也可用于静态物体</p><p>好处是动态物体与静态物体使用同一套光照信息，适合Deferred Shading</p><p>坏处是内存开销大，indirect specular的质量减弱（改用IBL或SSR）</p><p>====</p><h3 id="volume-based-methods"><a class="markdownIt-Anchor" href="#volume-based-methods"></a> Volume based Methods</h3><p>==</p><p><strong>Reflective Shadow Map</strong></p><p><img src="/images/rsm_maps.png" alt="" /></p><p>从光源角度渲染，记录光源可见表面的属性：</p><ol><li>表面颜色</li><li>法线</li><li>光通量（Flux）</li></ol><p>Notes:</p><p>类似Shadow Map</p><p>Flux是光源到达表面的光通量，比如点光源的光通量就与距离平方成反比；Spot light可以额外考虑falloff</p><p>==</p><p><img src="/images/indirect_lighting1.png" alt="" /></p><p>Shading时采样临近RSM纹素作为虚拟点光源</p><p>Notes:</p><p>Shadow Map一般较大，做indirect illumnation时一般只考虑临近的纹素，采用重要性采样</p><p>==</p><p><strong>Virtual Point Lights（Instant Radiosity）</strong></p><p><img src="/images/vpl-brief.png" alt="The Last of Us" /></p><p>一般用于狭隘室内的手电筒效果，调整的好可以看起来很真实</p><p>缺点是没有遮挡关系；不稳定，只能用于局部效果</p><p>Notes:</p><p>样本数量对性能影响较大</p><p>Uncharted 4里面每个像素只采样16个样本，但不同的帧轮流使用不同的样本集，最后在时间上过滤</p><p>==</p><p><strong>Heightfield GI</strong></p><p><img src="/images/heightfield-gi.png" alt="" /></p><p>渲染一个top-down的RSM，获得高度场的光照信息</p><p>适合高度场的室外开阔场景的环境光，不能用在室内</p><p>MotoGP、UE4 Kite Demo里使用过</p><p>==</p><p><strong>Light Propagation Volumes</strong></p><p><img src="/images/lpv-brief.png" alt="" /></p><p>将场景划分为3维网格，每个cell里面储存radiance的分布</p><p>优点：无需预处理，开销低，支持体积效果</p><!-- .element: style="font-size:80%;" --><p>缺点：网格未对齐会导致漏光，网格分辨率高时光线传播慢</p><!-- .element: style="font-size:80%;" --><p>Notes:</p><p>Radiance分布在最初的论文中以2阶SH储存</p><p>LPV的开销较低，主机硬件都能运行</p><p>总体来说适合Diffuse GI</p><p>==</p><p><img src="/images/lpv-progress.png" alt="" /></p><p>LPV分成3个步骤：</p><ol><li>渲染RSM</li><li>含有VPL的cell计算最初的SH</li><li>光照在网格内传播</li></ol><p>Notes:</p><p>最初只有与被光照射的表面直接接触的cell有光照信息</p><p>接下来，每个cell根据邻居cell的光照，计算出自己光照的更新</p><p>最后得到一个radiance field，这个radiance field包含了低频的光照信息，甚至可以做一些glossy BRDF</p><p>由于每次迭代光照只能传播一格，速度较慢；而低分辨率网格又容易导致漏光；后来提出了Cascaded LPV</p><p>最初传播没有考虑遮挡，后来使用了RSM与摄像机的深度信息，作为部分遮挡信息；完整的遮挡可以voxelize场景</p><p>==</p><p><strong>Sparse Voxel Octree GI</strong></p><p><img src="/images/vct-brief.png" alt="" /></p><p>场景储存为稀疏体素八叉树，且层次化（类似Mipmap）</p><p>优点：支持Diffuse和Specular，和较大尺度的AO</p><!-- .element: style="font-size:80%;" --><p>缺点：有部分漏光，高Specular有artifact</p><!-- .element: style="font-size:80%;" --><p>Notes:</p><p>当下最好的实时GI实现</p><p>后来有用更GPU friendly的Clipmap替代octree的实现，Clipmap类似Mipmap，只是低层信息只储存中心部分</p><p>其实，拿到场景Voxel数据后可以做很多，如AO，Soft Shadow</p><p>AO相比SSAO的好处是可以考虑到离屏遮挡，只是分辨率不高，只适合较大尺度</p><p>漏光是体积类方法的通病了；偏镜面的反射会展现出底层是voxel的本质，可以falloff到SSR之类的其他方法</p><p>==</p><p><img src="/images/svogi.png" alt="" /></p><p>SVOGI也可以分为3步：</p><ol><li>将RSM的直接光照信息注入到底层八叉树中</li><li>底层八叉树的光照向上层传播</li><li>Cone Tracing收集indirect radiance</li></ol><p>Notes:</p><p>第一步（Light pass）与LPV第一步类似</p><p>第二步（Filtering pass）：down-sampling</p><p>第三步（Camera pass）</p><p>==</p><p><strong>Voxel Cone Tracing</strong></p><p><img src="/images/voxel-cone-tracing.png" alt="" /></p><p>根据Cone当前部分大小，找到八叉树的合适层级做相交检测</p><!-- .element: style="font-size:75%;" --><p>Tracing Cone的方向与数量根据BRDF决定</p><!-- .element: style="font-size:75%;" --><p>Notes:</p><p>理想情况是发射很多ray做相交检测，但限于速度只能向平均方向做cone tracing</p><p>Cone的精确相交计算量也大，只能将cone分割成由小到大的球体（或立方体），每个球体（立方体）与八叉树做快速相交检测</p><p>距离cone的发射点越远，立方体的尺寸越大，采样偏顶层（较粗略）的体素八叉树</p><p>用类似三线性插值的方法获得选中的两层的一个中间值</p><p>Diffuse BRDF一般要Tracing多个Cone，以覆盖整个半球面；VCT尤其适合glossy reflection</p><p>====</p><h3 id="local-approximation"><a class="markdownIt-Anchor" href="#local-approximation"></a> Local Approximation</h3><p>==</p><p><strong>Ambient Occlusion</strong></p><p><img src="/images/ao-baking-gpu.png" alt="" /></p><p>AO作为GI的局部近似</p><p>根据光照信息频率的不同，有不同的方案</p><p>典型的如baked lightmap AO，SSAO，volumn，高度场、距离场AO等</p><p>Notes:</p><p>图片是Destiny采用的baked AO</p><p>近年来实时计算的AO被大量使用，如基于距离场的cone tracing，screen-spaced AO</p><p>起初Crytek提出的SSAO只是简单的在每个像素的一圈内采样点，根据多少像素深度小于采样点深度判断遮挡程度；HBAO对其做了较大改进，找出水平方向的未遮罩角度</p><p>==</p><p><strong>Screen Space GI</strong></p><p><img src="/images/ssgi.png" alt="" /></p><p>局部GI的另一种方案</p><p>目前比较成熟的是<strong>Horizon-Based Indirect Lighting</strong></p><p>Notes:</p><p>可以当做近距离局部GI的补充，与另一种全局GI结合使用</p><p>受到HBAO的启发，挖掘屏幕空间的位置信息</p><p>每渲染一个pass就相当于一次bounce，多帧后就可以达到近乎无限次数的bounce效果</p><p>Screen-space方法的缺点是作为光源的pixel被挡住或离开屏幕后，受间接光的部分会马上黑掉</p><p>有一些trick解决这个问题，如将被直接光照的部分同时渲染到另一个Render Target上，并且以更大的FOV渲染，first bounce从这个RT上采样，这样就减轻了视角切换带来的问题</p><p>==</p><p><strong>Specular GI?</strong></p><p><img src="/images/stochastic-ssr.png" alt="" /></p><p>Specular GI有一些独特的解决方案，如基于IBL的Parallax-Corrected Cubemaps，Screen-Space Reflections，Spherical Harmonics/Guassian近似</p><p>Notes:</p><p>SSR尤其适合FPS类游戏，但在其他视角（top-down view）就没什么效果</p><p>一些传统的方法，如平面反射也可以考虑进来</p><p>当前的RTX也是一直Specular GI的解决方案</p><p>大部分游戏不考虑specular到specular的GI</p><p>====</p><h3 id="challenge"><a class="markdownIt-Anchor" href="#challenge"></a> Challenge</h3><p>==</p><h4 id="视觉一致性失败"><a class="markdownIt-Anchor" href="#视觉一致性失败"></a> 视觉一致性失败</h4><ul><li>模型过于简化</li><li>PBR参数过于简化</li><li>低分辨率素材</li><li>错误处理了特殊光源（cookie）</li><li>手动参数调节过度</li><li>出现负值光</li></ul><p>Notes:</p><p>•Simplified albedo color</p><p>•Not handling metallic surfaces</p><p>•Not handling roughness properly</p><p>•Not storing enough post-computation info to reconstruct view-dependent results</p><p>•Vertex/surface/detail normal to texel/voxel/probe ratio</p><p>==</p><h4 id="开发流程失败"><a class="markdownIt-Anchor" href="#开发流程失败"></a> 开发流程失败</h4><ul><li>开发时的光照一直是“错”的</li><li>使迭代变得复杂</li><li>“全局”意味着移动一个物体，整个场景重新烘培</li><li>“预览”模式也很慢，灯光还不准确</li><li>导致关卡设计变得“静止”</li></ul><p>Notes:</p><p>•i.e.: Build made two revisions before lighting was “generated”, hard to judge art!</p><p>•i.e.: Lighting done late in the level authoring process, after sign-off</p><p>Example Scenario: Nightly build of GI for open world map (8+ hours)</p><p>1.Artist submits everything in time for automated process to start</p><p>2.Process runs all night</p><p>3.Artist arrives at work in the morning, syncs and opens editor, notices something is visually broken</p><p>4.Fixes it, submits, waits (next day, or several hours)</p><p>5.Rinse-and-repeat</p><p>==</p><h4 id="编辑流程失败"><a class="markdownIt-Anchor" href="#编辑流程失败"></a> 编辑流程失败</h4><ul><li>美术倾向“手工调整”GI失败的地方</li><li>修复“漏光”</li><li>用“负光”去除过度的GI</li><li>用简单几何体加速烘培</li><li>耗时耗力而且不稳定</li></ul><p>Notes:</p><p>Unity progressive lightmapper 就是加速编辑流程的工具</p><p>希望杜绝无意义的“GI调整”：Unwrapping lightmap UVs、Building simplified geometry for GI、Manually placing GI &amp; reflection volumes</p><p>==</p><h4 id="帧数帧数"><a class="markdownIt-Anchor" href="#帧数帧数"></a> 帧数，帧数</h4><ul><li>60Hz -&gt; 16.6ms</li><li>144Hz -&gt; 6.94ms</li><li>留足余量，实际可用比这还少（掉帧就不好玩了）</li><li>主机的GPU算力…（单位：TFLOPS）<ul><li>PS4: 1.8, PS4Pro: 4.2, XB1: 1.3, XB1X: 6</li><li>TitanX: 11, Vega: 13.1</li></ul></li></ul><p>==</p><h4 id="烘培过于耗电"><a class="markdownIt-Anchor" href="#烘培过于耗电"></a> 烘培过于耗电</h4><ul><li>Beefy Machines / Server Setups<ul><li>Halo 3: 256 servers, 456 Processors, 1GB memory [Chen08][Villegas08]</li><li>CoD: 48 GB RAM and 12 GB VRAM machines</li><li>Destiny: Farm with tens of servers to bake AO</li><li>SNDBS/Incredibuild: pool of GPUs running all night (650W+ PSUs)</li></ul></li></ul><p>==</p><h4 id="游戏特性使gi失效"><a class="markdownIt-Anchor" href="#游戏特性使gi失效"></a> 游戏特性使GI失效</h4><ul><li>磨损、破坏、变形效果</li><li>昼夜变换</li><li>天气</li><li>玩家生成物体</li><li>动态物体、动态光源、体积光</li></ul><p>Notes:</p><p>A hole in the wall can drastically break GI</p><p>Interpolation doesn’t always give best results</p><p>==</p><h4 id="开放世界"><a class="markdownIt-Anchor" href="#开放世界"></a> 开放世界</h4><p><img src="/images/open-world-scale.png" alt="" /></p><p>==</p><table><thead><tr><th><img src="/images/acu-gi-huge.png" alt="" /></th><th><img src="/images/acu-gi-result.png" alt="" /></th></tr></thead><tbody><tr><td>ACU 高达21GB的GI文件</td><td>效果的确很好</td></tr></tbody></table><p>==</p><p><img src="/images/open-world-gi.png" alt="" /></p><ul><li>昼夜变换、天气</li><li>室内、室外切换</li><li>需要Robust的制作流程</li></ul><p>Notes:</p><p>开放世界的GI很不简单</p><p>体量大、串流压力</p><p>====</p><p>GI for Games of The Future</p><p><img src="/images/future-game-gi.jpg" alt="" /></p><p>==</p><ul><li>GI可以渲染氛围，就像背景音乐</li><li>自然场景的GI，很难（森林，植被…）</li><li>体积效果（雾、烟、汽…）的GI</li><li>全粗糙度覆盖、全BSDF覆盖的GI</li><li>支持任意的光（面积光将成为主流）</li><li>AI降噪、重建，Deep Learning GI?</li><li>简单、直观、美术友好的用户界面</li><li>…</li></ul><p>Notes:</p><p>比如FPS中一个着火的场景，火光、烟雾的GI能极大提升沉浸感</p><p>体积效果GI不解决，爆炸就难以真实</p><p>窗户、广告牌…都是面积光（然而面积光的实时阴影现在都搞不定…）</p><p>以上这些问题需要学术界与游戏界共同解决…</p><p>最近随着硬件水平的提升，越来越多的厂商将Ray tracing体系内的思想和算法带进了实时渲染领域；未来一段时间可以看到越来越多的RT与光栅化算法在各种层面结合的例子</p><p>====</p><h4 id="comparison"><a class="markdownIt-Anchor" href="#comparison"></a> Comparison</h4><table><thead><tr><th><strong>实时方法</strong></th><th>静态物体（Diffuse）</th><th>动态物体（Diffuse）</th><th>静态物体（Specular）</th><th>动态物体（Specular）</th></tr></thead><tbody><tr><td>静态光照</td><td>Radiosity Normal Mapping</td><td>Light Probes</td><td>Spherical Gaussian Lightmap</td><td>Environment Map</td></tr><tr><td></td><td>Spherical Harmonic Lightmap</td><td>Ambient Occulsion</td><td>Directional Occulsion</td><td></td></tr><tr><td>动态光照</td><td>Precomputed Radiance Transport</td><td>Virtual Point Lights</td><td></td><td>SVOGI/Voxel Cone Tracing GI</td></tr><tr><td></td><td></td><td>Light Propogation Volumes</td><td></td><td>Planar/Screen-space Reflection</td></tr><tr><td></td><td></td><td>Screen-space GI（HBIL）</td><td></td><td></td></tr></tbody></table><!-- .element: style="font-size:50%;" --><p>====</p><h3 id="the-end"><a class="markdownIt-Anchor" href="#the-end"></a> The End</h3><p>Reference:</p><ul><li><a href="https://www.ea.com/seed/news/seed-siggraph2017-global-illumination">https://www.ea.com/seed/news/seed-siggraph2017-global-illumination</a></li><li><a href="https://ericpolman.com/2016/03/17/reflective-shadow-maps/">https://ericpolman.com/2016/03/17/reflective-shadow-maps/</a></li><li><a href="https://research.nvidia.com/sites/default/files/pubs/2011-09_Interactive-Indirect-Illumination/GIVoxels-pg2011-authors.pdf">https://research.nvidia.com/sites/default/files/pubs/2011-09_Interactive-Indirect-Illumination/GIVoxels-pg2011-authors.pdf</a></li><li><a href="https://github.com/Patapom/GodComplex/blob/master/Tests/TestHBIL/2018%20Mayaux%20-%20Horizon-Based%20Indirect%20Lighting%20(HBIL).pdf">https://github.com/Patapom/GodComplex/blob/master/Tests/TestHBIL/2018 Mayaux - Horizon-Based Indirect Lighting (HBIL).pdf</a></li><li>《Realtime rendering 4th》Chapter 11</li></ul><!-- .element: style="font-size:60%;" -->]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时渲染 </tag>
            
            <tag> GI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda函数与std::function</title>
      <link href="/2019/11/04/Cpp-Function/"/>
      <url>/2019/11/04/Cpp-Function/</url>
      
        <content type="html"><![CDATA[<p>Lambda函数可以说是C++ 11中加入的最重要的特性之一了。Lambda（也称作匿名函数），提供了一种在代码中很方便地定义函数的方法。这种写法能让我们写出非常简洁的语句，比如<code>[]&#123;&#125;()</code>也许就是C++中最简洁的表达式了。</p><a id="more"></a><h4 id="lambda语法回顾"><a class="markdownIt-Anchor" href="#lambda语法回顾"></a> Lambda语法回顾</h4><p>Lambda的语法也很简单，其形式大致为<code>[]()&#123;&#125;</code>，包含3个部分。</p><ul><li><code>[]</code>中的内容为捕获列表</li><li><code>()</code>中的内容为参数列表</li><li><code>&#123;&#125;</code>为函数体</li></ul><p>当参数列表为空时，<code>()</code>部分可以省略，也就是说，C++中最简单的Lambda函数是<code>[]&#123;&#125;</code>，这是一个无输入无返回值无语句的空函数。</p><p>一个纯粹的函数是不带有任何变化信息的，就仿佛数学意义上的函数——放回值仅由参数值决定，除此之外什么都不做。但很多时候我们需要函数能访问和修改一些外部的数据，或者说需要有相应的<strong>上下文</strong>。函数体与上下文的整体就称作<strong>闭包（closure）</strong>，它在Lambda中是通过捕获外部变量实现的。</p><p>捕获列表<code>[]</code>中放置所有在函数体中用到的外部变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [i, &amp;j](<span class="keyword">int</span> a, <span class="keyword">float</span> b)&#123; ++j; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2.0f</span>);</span><br></pre></td></tr></table></figure><p>比如上面这个例子，就捕获了<code>i</code>，<code>j</code>两个变量，其中<code>i</code>是值捕获，<code>j</code>是引用捕获。</p><p>当捕获的变量较多时，C++还提供了一种指定默认捕获的简便写法：</p><ul><li><code>[=]</code>指出默认为值捕获</li><li><code>[&amp;]</code>指出默认为引用捕获</li></ul><p>指定默认捕获之外，其他特定变量的捕获方式加在捕获列表之后即可。比如下面这个例子指定默认为值捕获，<code>j</code>为引用捕获：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [=, &amp;j](<span class="keyword">int</span> a, <span class="keyword">float</span> b)&#123; ++j; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br></pre></td></tr></table></figure><p>你可能会想，怎么只有两种捕获方式呢？C++的移动语义用到捕获里面呢？</p><p>C++ 11 中确实只有这两种方式，但是 C++ 14 的出现解决了这个问题：C++14 允许捕获对象由任意表达式初始化。这就说明可以用下面的方式实现移动捕获：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="keyword">auto</span> f = [value = <span class="built_in">std</span>::<span class="built_in">move</span>(ptr)] &#123; <span class="keyword">return</span> *value; &#125;;</span><br></pre></td></tr></table></figure><p>需要特别说明的一点是，值引用捕获的变量默认是<code>const</code>的，如果要在函数体内修改，需要给lambda加上<code>mutable</code>修饰符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [=](<span class="keyword">int</span> a) <span class="keyword">mutable</span> &#123; <span class="built_in">cout</span> &lt;&lt; i++ &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br></pre></td></tr></table></figure><p>值捕获对象的生命周期与lambda本体的生命周期相同，而引用捕获则需要注意调用lambda函数时捕获对象仍在生命周期内。通过捕获不同的对象，lambda函数实现了<strong>闭包</strong>的效果，比如下面的代码就构造了一个斐波那契数列<strong>生成器（generator）</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> make_fib = [] &#123;</span><br><span class="line">        <span class="keyword">auto</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> [=]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> ret = a; a = b; b += ret;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> fib = make_fib();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fib() &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure><p>上面的写法中，我们均没有指明lambda的返回类型是什么，这时C++会将返回类型当作<code>auto</code>，自动帮我们推导。如果要明确指出返回类型，可以像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []() -&gt; <span class="keyword">double</span> &#123; <span class="keyword">return</span> <span class="number">5</span>; &#125;;</span><br></pre></td></tr></table></figure><h4 id="在c中表示函数"><a class="markdownIt-Anchor" href="#在c中表示函数"></a> 在C++中表示函数</h4><p>函数动态调用，就是把函数存在“变量”里面，调用的时候根据变量值的不同调用相应的函数。要实现这个我们至少需要做两部分事：</p><ol><li>构造并储存函数到变量中</li><li>调用一个变量中存有的函数</li></ol><p>如果实现了这两点，我们便认为函数是<strong>一等公民</strong>：函数的地位与其他的基础类型一样，可以储存在变量中，可以作为参数传递，可以像其他变量一样随意构造。在函数式语言和许多的动态类型脚本语言（JS，Lua等）中，函数均是一等公民。C++中，函数并不是原生的一等公民（直到Lambda的出现改善了这一点），但 C++也提供了不少语言机制让我们实现函数作为一等公民的类似效果。</p><p>关于第一点，C++中要表示可以调用的函数（callable），主要有三种方式：</p><ol><li>函数指针</li><li>函数对象（functor，或function object）</li><li>Lambda</li></ol><p>函数指针是从C语言中基础而来的写法，它可以指向任意同签名的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="keyword">int</span>(*f)(<span class="keyword">int</span>,<span class="keyword">int</span>) = add;</span><br><span class="line"><span class="keyword">int</span> r = f(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>这里的<code>f</code>就是指向add函数的函数指针。由于<code>f</code>实际上是一个指针，而指针的值可以指向任何同类型签名的函数，指针也能很方便的作为参数传入任意函数。</p><p>函数对象是一个定义了operator()运算符重载的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Functor</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> f = Functor();</span><br><span class="line"><span class="keyword">int</span> r = f(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>函数对象只声明了一个<strong>可调用的函数</strong>，并不具备<strong>动态调用</strong>的能力——因为两个不同函数对象的类型不同，不能相互赋值。解决方案有两种，一种是通过模版在编译期决定调用对象；另一种是通过面向对象中的<strong>多态</strong>在运行期决定调用对象：在基类中声明函数签名，并在该基类的不同派生类中实现对应的方法。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FunctorBase</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Functor1</span> :</span> FunctorBase &#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Functor2</span> :</span> FunctorBase &#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a - b; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在C++中，多态一般是由**虚表(virtual table)**实现的，这样实现的动态调用，其实是借助了虚表。</p><p>Lambda在上面已经介绍过了，在C++中lambda相当于函数对象的语法糖：它能自动帮你捕获变量。也就是说，下面这个lambda函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [=, &amp;j](<span class="keyword">int</span> a, <span class="keyword">float</span> b)&#123; ++j; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br></pre></td></tr></table></figure><p>其实与这个函数对象的功能相同：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">F</span> &#123;</span></span><br><span class="line">    F(<span class="keyword">int</span> i, <span class="keyword">int</span> &amp;j) : i(i), j(j) &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">float</span> b)</span> </span>&#123; ++j; <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> &amp;j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = F()</span><br></pre></td></tr></table></figure><p>Lambda其实相当于<code>const</code>类型的函数对象，所以修改捕获值时要加mutable修饰符。这个函数对象的类型是实现定义的，编译器会生成一个相应的类型。因此在将lambda赋值给一个变量时，变量类型只能为<code>auto</code>，因为没法确定lambda的类型。</p><p>Lambda对象也有相应的大小。由这种等价而来的函数对象，可以很轻易地发现lambda对象的占用空间来自其捕获的对象。比如在64位系统下就有如下的结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">auto</span> f = []()&#123;&#125;;<span class="comment">// sizeof(f) == 1</span></span><br><span class="line"><span class="keyword">auto</span> g = [&amp;a]()&#123;&#125;;<span class="comment">// sizeof(g) == 8</span></span><br><span class="line"><span class="keyword">auto</span> h = [a]()&#123;&#125;;<span class="comment">// sizeof(h) == 10</span></span><br></pre></td></tr></table></figure><p>可以看到，空lambda的大小为1字节，与空对象的大小为1字节是对应的。如果有捕获的对象，捕获对象占多大空间，lambda就有多大。</p><p>由于lambda的类型是编译器定的，即使是两个函数签名相同的lambda变量也不能相互赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;f&quot;</span>; &#125;;</span><br><span class="line">f = []()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;g&quot;</span>; &#125;;<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure><p>不过在捕获列表为空时，我们可以将lambda赋值给相同函数签名的函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(*f)(<span class="keyword">int</span>,<span class="keyword">int</span>) = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> a + b; &#125;;</span><br></pre></td></tr></table></figure><p>既然同函数签名也不能互相赋值，说明Lambda本身不具备动态调用的能力。而由于类型不确定的原因，它也不能利用到面向对象中多态的解决方案，要把lambda函数作为参数传如其他地方中，只能通过模版在编译器解决。在编译期解决调用的好处就是编译器可以很好得将较小的函数体<strong>内联</strong>进调用函数的地方。比如下面第一种搜索的写法就比用函数指针的第二种写法要快的多，原因正是因为编译器进行了函数内联，从而更好的优化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种 - 模版内联</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">first_search</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> bigger = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123; <span class="keyword">return</span> a &gt; b; &#125;;</span><br><span class="line">  <span class="keyword">auto</span> rng = <span class="built_in">std</span>::equal_range (vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), val, bigger);</span><br><span class="line">  <span class="keyword">return</span> rng.first != rng.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种 - 函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bigger</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a, <span class="keyword">const</span> <span class="keyword">void</span> *b)</span> </span>&#123; <span class="keyword">return</span> *(<span class="keyword">int</span>*)b - *(<span class="keyword">int</span>*)a; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">second_search</span> <span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bsearch (&amp;val, vec.data(), vec.<span class="built_in">size</span>(), <span class="keyword">sizeof</span>(<span class="keyword">int</span>), bigger);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然编译期决定调用能产生高效的代码，但我们有时只能运行期才能决定调用哪个函数。那怎么样让lambda函数能够在运行期动态地决定调用对象是谁呢？这就需要说到C++11中与lambda同时引入的<strong>std::function</strong>了。</p><h4 id="函数容器stdfunction"><a class="markdownIt-Anchor" href="#函数容器stdfunction"></a> 函数容器——std::function</h4><p>上面，我们解决了储存函数的问题，现在要来看看动态调用的问题了。</p><p>首先，动态调用可以发生在两个阶段：<strong>编译期</strong>和<strong>运行期</strong>。</p><p>编译期的调用主要由<strong>模版</strong>实现，比如在<code>std::sort</code>中传入比较函数。</p><p>运行期的调用则会稍微麻烦一些，目前我们已知有两种方式：</p><ol><li>函数指针</li><li>面向对象的多态</li></ol><p>多态要求函数体实现在一个继承类中，这有时并不太好实现，比如就没有办法让<code>int</code>这样的基础类型继承（要搞也只能像Java中的Integer类做一个装包，但是没有必要）。函数指针虽然没有这个问题，但它本质是无状态的，不方便实现像闭包这样的东西。</p><p>有没有一种好的解决方案呢？有。C++11中加入的<code>std::function</code>正好解决了这个问题。它是一种通用的函数容器，不管是函数指针、函数对象、还是lambda函数，只要它们的函数签名对的上，都可以存在里面，而且可以很方便的复制、传递、调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Functor</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;functor&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f;</span><br><span class="line">f = func;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">f = Functor();</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line">f = []()&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;lambda&quot;</span> &lt;&lt; <span class="built_in">endl</span>; &#125;;</span><br><span class="line">f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::function</code>在被赋值到一个具体的函数前，是空的状态，如果这时调用<code>f()</code>，会得到<code>std::bad_function_call</code>异常。</p><p><code>std::function</code>的动态调用是用<strong>多态</strong>实现的（在后面会细说），说明<code>f</code>中至少含有一个虚表指针。此外，正如lambda函数要分配储存上下文的空间，<code>std::function</code>也需要给上下文分配空间。这个空间是随着捕获内容的大小而变化的，我们可能猜测该空间分配在堆上，正如<code>std::string</code>那样。如果我们去取上面这个<code>f</code>变量的大小，会发现<code>sizeof(std::function&lt;void()&gt;) == 32</code>，它实际的大小显然比只存一个虚表指针加上堆空间指针要多的多。事实上，在目前的三大主流编译器（gcc, clang, msvc）的实现中，均采用了一个如<code>std::string</code>中的<strong>小对象优化机制(SBO, Small Buffer Optimization)</strong>：较小的上下文储存在栈上。我们可以hook掉分配内存的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 替换掉全局的new与delete</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Allocating &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">malloc</span>(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* p)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="built_in">free</span>(p); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> a1[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">auto</span> lambda1 = [a1]()&#123;&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;lambda1 size: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(lambda1) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f1 = lambda1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a2[<span class="number">17</span>];</span><br><span class="line"><span class="keyword">auto</span> lambda2 = [a2]()&#123;&#125;; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;lambda2 size: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(lambda2) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f2 = lambda2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lambda1 size: 16</span><br><span class="line">lambda2 size: 17</span><br><span class="line">Allocating 17 bytes</span><br></pre></td></tr></table></figure><p>从运行结果可以看出，16字节一下的上下文保存在栈中，超过16字节的话则会保存在堆中。</p><h4 id="实现一个简陋的stdfunction"><a class="markdownIt-Anchor" href="#实现一个简陋的stdfunction"></a> 实现一个简陋的<code>std::function</code></h4><p>之前我提到了<code>std::function</code>用了多态来实现运行期的动态调用，但具体是怎么实现的呢？直接做一个不就知道了:D（这一部分主要参考了<a href="https://shaharmike.com/cpp/naive-std-function/">这篇文章</a>）</p><p>在<a href="https://en.cppreference.com/w/cpp/utility/functional/function">cppreference</a>上找到<code>std::function</code>的定义大致如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">function</span>;</span> <span class="comment">/* undefined */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Result</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">function</span>&lt;Result(Args...)&gt; &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个类定义是第一个的<strong>偏特化（partial specialization）</strong>，模版匹配时会将第一个模版尝试匹配在第二个模版上，这样就能将函数类型中的返回值与参数分离出来。如果我们只将其声明成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Result</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">function</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那使用时就只能写成这一种形式：<code>std::function&lt;int, int, float&gt;</code>，而不是我们比较习惯的这种格式：<code>std::function&lt;int(int, float)&gt;</code>。</p><p>之前我们说过，<code>std::function</code>的动态函数调用是通过多态实现的。要实现多态调用，首先要定义一个基类<code>ICallable</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ICallable</span> &#123;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~ICallable()                = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Result <span class="title">Invoke</span><span class="params">(Args... args)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基类主要定义了一个<code>Invoke</code>虚方法来实现函数调用。接下来是派生类<code>CallableT</code>，这里将实际存放的函数类型定义为一个模版参数，从而实现对多种函数表示的支持：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">CallableT</span> :</span> ICallable &#123;</span><br><span class="line">    CallableT(<span class="keyword">const</span> T &amp;t) : t(t) &#123;&#125;</span><br><span class="line">    ~CallableT() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function">Result <span class="title">Invoke</span><span class="params">(Args... args)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> t(args...); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T t;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>CallableT</code>类实际上用到了一个C++中的惯用技巧——<strong>类型擦除(Type Erasure)</strong>。类型擦除让我们能够将一个不管是什么类型的对象“包”进我们的类中，并让我们之后能调用它。每当<code>CallableT</code>被实例化，都伴随着创建了一个新的虚表(vtable)，辅以多态，我们就能动态地调用到各种不同形式的函数。STL中的<code>std::function</code>、<code>std::any</code>都用到了这个技巧。</p><p>有了这两个类的帮助，<code>function</code>类就很好实现了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span> BufferSize = <span class="number">32</span>&gt; class function; <span class="comment">/* undefined */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span>... Args, <span class="built_in">std</span>::<span class="keyword">size_t</span> BufferSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>&lt;Result(Args...), BufferSize&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    function() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; function &amp;<span class="keyword">operator</span>=(T &amp;&amp;t) &#123;</span><br><span class="line">        <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(CallableT&lt;T&gt;) &lt;= <span class="keyword">sizeof</span>(storage), <span class="string">&quot;function is too large for buffer&quot;</span>);</span><br><span class="line">        callable.reset(<span class="keyword">new</span> (storage) CallableT&lt;T&gt;(t));</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; function &amp;<span class="keyword">operator</span>=&lt;<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>&gt;(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span> &amp;&amp;t) &#123;</span><br><span class="line">        callable.reset(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Result <span class="title">operator</span><span class="params">()</span><span class="params">(Args... args)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        assert(callable);</span><br><span class="line">        <span class="keyword">return</span> callable-&gt;Invoke(args...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ICallable 代码 ...</span></span><br><span class="line">    <span class="comment">// CallableT 代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Deleter</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ICallable *callable)</span> </span>&#123; callable-&gt;~ICallable(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>                                storage[BufferSize];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ICallable, Deleter&gt; callable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我没有采用动态内存分配的方式，而是直接在栈上分配了<code>BufferSize</code>字节大小的<code>storage</code>（毕竟调用<code>new</code>的开销比直接在栈上分配要大的多），在此储存上下文。<code>BufferSize</code>的大小由模版值确定，默认为32。</p><p><code>operator=</code>函数的参数类型是一个模版参数，以支持赋值任意的函数形式。其中判断了赋值的函数上下文是否能够储存下，如果是，直接在<code>storage</code>中构造对象。这里还特化了赋值<code>nullptr</code>的情况。</p><p>而<code>operator()</code>函数则更加直接，里面调用了基类的虚函数<code>Invoke</code>，在这里调用在虚函数表中找到实际的函数。由于函数可能为空，需要用<code>assert</code>验证其为非空。</p><p>简单测试一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">functor</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;functor&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    function&lt;<span class="keyword">void</span>()&gt; f;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof function&lt;void()&gt;: &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(f);</span><br><span class="line">    f = func;</span><br><span class="line">    f();</span><br><span class="line">    f = functor();</span><br><span class="line">    f();</span><br><span class="line">    f = [] &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;lambda&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;;</span><br><span class="line">    f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof function&lt;void()&gt;: 40</span><br><span class="line">func</span><br><span class="line">functor</span><br><span class="line">lambda</span><br></pre></td></tr></table></figure><p>动态函数储存是没有问题了，但这个<code>function</code>对象占用了40个字节的大小…实际能存多大的上下文呢？简单测试一下，发现上下文最大能存24个字节的大小，而分配的<code>storage</code>大小是32字节，另外8字节显然被用作了虚表指针。也就是说，这个对象有16个字节是不能用于储存上下文的，能不能进一步优化一下呢？</p><p>稍微分析一下就能发现，上面的实现额外储存了一个基类指针，然而基类地址已知，这个指针并没有起到什么作用，唯一的作用就是表示对象是否为空。另一方面，可以用函数指针本身为空来表示对象为空。然而，虚表指针我们无法修改，也就不能将其置空。不过，可以用一种实例化的特殊<code>CallableT</code>来表示<code>function</code>为“空”的这种情况。</p><p>简单修改下<code>function</code>的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span>... Args, <span class="built_in">std</span>::<span class="keyword">size_t</span> BufferSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">function</span>&lt;Result(Args...), BufferSize&gt; &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    function() &#123; <span class="keyword">new</span> (storage) CallableT&lt;<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>&gt;(<span class="literal">nullptr</span>); &#125;</span><br><span class="line">    ~function() &#123; ((ICallable *)storage)-&gt;~ICallable(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; function(T &amp;&amp;t) &#123; <span class="keyword">operator</span>=(<span class="built_in">std</span>::forward&lt;T&gt;(t)); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; function &amp;<span class="keyword">operator</span>=(T &amp;&amp;t) &#123;</span><br><span class="line">        <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(CallableT&lt;T&gt;) &lt;= <span class="keyword">sizeof</span>(storage), <span class="string">&quot;function is too large for buffer&quot;</span>);</span><br><span class="line">        ((ICallable *)storage)-&gt;~ICallable();</span><br><span class="line">        <span class="keyword">new</span> (storage) CallableT&lt;T&gt;(t);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Result <span class="title">operator</span><span class="params">()</span><span class="params">(Args... args)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((ICallable *)storage)-&gt;Invoke(args...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ICallable 代码 ...</span></span><br><span class="line">    <span class="comment">// CallableT 代码 ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">class</span> <span class="title">CallableT</span>&lt;std::nullptr_t&gt; :</span> <span class="keyword">public</span> ICallable &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CallableT(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">nullptr_t</span> &amp;t) &#123;&#125;</span><br><span class="line">        ~CallableT() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">Result <span class="title">Invoke</span><span class="params">(Args... args)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">throw</span> <span class="built_in">std</span>::bad_function_call(); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> storage[BufferSize];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>PS：上面的代码在Clang和MSVC测试通过，但GCC报错。原因是C++标准要求特化必须在命名空间里做，而Clang和MSVC放宽了这个限制。如果要在GCC上编译，需要做一些workaround（如dummy template argument），这里鉴于篇幅省略…</p></blockquote><p>基本思路是用以<code>std::nullptr_t</code>实例化一个<code>CallableT</code>，用来表示<code>function</code>为空的情况。这种实现也可以去除<code>Invoke</code>调用时判断为空的分支。细节这里就不再说了，代码已经比较清楚了。</p><p>修改之后，这个<code>function</code>类已经能做到只用8字节作为虚表指针，剩下的空间用作储存上下文了，比之前节省了8字节的空间呢 😄</p><p>不过，如果用它去存一个没有上下文的函数，我们发现<code>BufferSize</code>至少是16字节，而不是预计的8字节。这里被神秘地拿去的8字节来自于<code>CallableT</code>中储存的<code>t</code>，如果函数的上下文为0字节，这里的<code>t</code>应该也是0字节。但是，C++中是不允许存在大小0字节的对象的（不然怎么取地址啊）。于是<code>t</code>的大小就被当作了1字节，再加上内存对齐的影响，最小的<code>BufferSize</code>就应该是16字节啦。</p><p>目前<code>function</code>看起来已经能用了，但我们还忽略了一个“小”问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">void</span>()&gt; f2;</span><br><span class="line">f2 = f;</span><br><span class="line">f2();</span><br></pre></td></tr></table></figure><p>上面的语句能成功通过编译，我们可能认为编译器为<code>function</code>对象自动创建了自己的复制赋值函数。但真的是这样吗？如果我们在<code>function</code>的<code>Invoke</code>中加上一句输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">operator</span><span class="params">()</span><span class="params">(Args... args)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Invoked&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ((ICallable *)storage)-&gt;Invoke(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并运行下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    static_function&lt;<span class="keyword">void</span>()&gt; f;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    f = [=]() <span class="keyword">mutable</span> &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ++i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;;</span><br><span class="line">    f();</span><br><span class="line"></span><br><span class="line">    static_function&lt;<span class="keyword">void</span>()&gt; f2;</span><br><span class="line">    f2 = f;</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Invoked</span><br><span class="line">1</span><br><span class="line">Invoked</span><br><span class="line">Invoked</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>可以看到调用<code>f2()</code>时触发了两次<code>Invoke</code>，显然不是我们想要的情况。可以看出，这是因为<code>f2</code>将<code>f</code>当成了一个普通的函数对象，并调用了我们编写的模版版本的赋值函数。每复制一次，都相当于将<code>f</code>的函数包了一层。</p><p>要解决这个问题，只要让编译器在这种情况下不要调用我们编写的模版赋值函数，或者说，让我们编写的模版版本的赋值函数只能用于赋值对象为函数类型的情况，这就需要给模版加上<strong>限制</strong>。C++中提供了一种实用的机制：<strong><a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a>(Substitution Failure Is Not An Error)</strong>，“替换失败不是错误”，它是意思就是，当一个模版匹配失败时并不直接报错，而是当它不存在。通过在模版参数列表中加入匹配条件，就可以对模版的适用范围加以限制，将一些重载函数的选项剔除。具体实现这里就不再细说了（要把SFINAE说清楚可能就要一整篇文章了），读者可以自己实现。</p><h4 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h4><ol><li><p><a href="https://shaharmike.com/cpp/naive-std-function/">https://shaharmike.com/cpp/naive-std-function/</a></p></li><li><p><a href="https://shaharmike.com/cpp/lambdas-and-functions/">https://shaharmike.com/cpp/lambdas-and-functions/</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学的一些资源记录</title>
      <link href="/2019/11/01/Graphics-Refs/"/>
      <url>/2019/11/01/Graphics-Refs/</url>
      
        <content type="html"><![CDATA[<p><s>我还是觉得需要边学边记录点什么，之前看了许多却没有较好地留下记录，而时间久了记忆也是容易遗忘的。笔记的内容均放在了这篇文章里了，以便以后查阅。</s></p><p>由于我发现图形学的东西不太适合分为一个个的独立知识点，要讲清楚一般都到一篇文章的篇幅，因此本文不再作为笔记，而是主要记录一些资源：优秀的教程、博客来源等等，以减少寻找优质资料所耗费的时间；也可以作为一个实用的资料指南针。</p><a id="more"></a><h2 id="general"><a class="markdownIt-Anchor" href="#general"></a> General</h2><ul><li><a href="https://www.scratchapixel.com/">[强烈推荐]Learn Computer Graphics From Scratch!(3D数学、渲染的优质教程)</a></li><li><a href="https://github.com/FancyVin/fun-with-graphics">fun-with-graphics(图形学相关的高校课程、书籍、教程、文章、博客、资源、开源项目)</a></li><li><a href="https://zhuanlan.zhihu.com/p/27158983">[知乎]【书单】图形学科研之路（持续更新）</a></li><li><a href="https://zhuanlan.zhihu.com/p/33898131">[知乎]游戏资源传送门</a></li><li><a href="https://zhuanlan.zhihu.com/p/84550677">[知乎]总结一些TA（技术美术）学习的网站</a></li></ul><h2 id="rendering"><a class="markdownIt-Anchor" href="#rendering"></a> Rendering</h2><h3 id="general-2"><a class="markdownIt-Anchor" href="#general-2"></a> General</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/34207965">《Real-Time Rendering 3rd》提炼总结</a></li></ul><h3 id="rendering-equationpbribl"><a class="markdownIt-Anchor" href="#rendering-equationpbribl"></a> Rendering Equation/PBR/IBL</h3><ul><li>《Realtime rendering 4th》Chapter 9</li><li>[Learn OpenGL上的两篇PBR教程和两篇IBL教程]([<a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/">https://learnopengl-cn.github.io/07 PBR/01 Theory/</a>](<a href="https://learnopengl-cn.github.io/07">https://learnopengl-cn.github.io/07</a> PBR/01 Theory/))</li><li><a href="https://github.com/QianMo/PBR-White-Paper">毛星云整理的&quot;基于物理的渲染（PBR）白皮书&quot;</a></li><li><a href="https://zhuanlan.zhihu.com/p/20091064">[知乎系列]基于物理着色</a></li><li><a href="https://zhuanlan.zhihu.com/p/33630079">[知乎]深入浅出基于物理的渲染一</a>  <a href="https://zhuanlan.zhihu.com/p/35002541">[知乎]深入浅出基于物理的渲染二</a>  <a href="https://zhuanlan.zhihu.com/p/34741174">[知乎]基于物理的环境光渲染一</a>  <a href="https://zhuanlan.zhihu.com/p/41150563">[知乎]基于物理的环境光渲染二</a></li><li><a href="https://zhuanlan.zhihu.com/p/21376124">[知乎]基于物理着色：BRDF</a></li><li><a href="https://zhuanlan.zhihu.com/p/21489591">[知乎]如何看懂这些&quot;该死的&quot;图形学公式</a></li><li><a href="https://zhuanlan.zhihu.com/p/33464301">[知乎]猴子都能看懂的PBR（才怪）</a></li><li><a href="https://zhuanlan.zhihu.com/p/25421091">[知乎]微表面模型－PBR渲染管线的材质</a>  <a href="https://zhuanlan.zhihu.com/p/25539396">[知乎]基于物理的渲染—更精确的微表面分布函数GGX</a></li><li><a href="https://zhuanlan.zhihu.com/p/37639418">[知乎]半小时了解PBR</a></li><li><a href="https://zhuanlan.zhihu.com/p/32209554">[知乎]More DETAILS! PBR的下一个发展在哪里？</a></li><li><a href="https://blog.selfshadow.com/publications/">SIGGRAPH 20xx Course: Physically Based Shading in Theory and Practice(非常丰富的PBR资源)</a></li><li><a href="https://www.cnblogs.com/jerrycg/p/4924761.html">“PBR Step by Step” 还不错的PBR公式推导</a></li></ul><h3 id="ray-tracingpath-tracingxx-tracing"><a class="markdownIt-Anchor" href="#ray-tracingpath-tracingxx-tracing"></a> Ray tracing/Path tracing/XX tracing</h3><ul><li><a href="https://www.pbrt.org/">PBRT</a></li><li><a href="http://aras-p.info/blog/2018/03/28/Daily-Pathtracer-Part-0-Intro/">Daily Pathtracer Part</a></li><li><a href="https://zhuanlan.zhihu.com/p/72673165">[知乎]光线追踪</a></li><li><a href="https://zhuanlan.zhihu.com/p/33614512">[知乎]【PathTracing】实时光线追踪和BSSRDF的那些事</a></li></ul><h3 id="ray-marchingparticipating-media"><a class="markdownIt-Anchor" href="#ray-marchingparticipating-media"></a> Ray marching/Participating media</h3><ul><li>(TBC)</li></ul><h3 id="global-illumination"><a class="markdownIt-Anchor" href="#global-illumination"></a> Global Illumination</h3><ul><li>《Realtime rendering 4th》Chapter 11</li><li><a href="https://www.ea.com/seed/news/seed-siggraph2017-global-illumination">EA-Seed-Siggraph17 “Past, Present and Future Challenges of Global Illumination in Games”</a></li><li><a href="https://zhuanlan.zhihu.com/p/49436452">[知乎系列]球谐光照与PRT学习笔记</a></li><li>(TBC)</li></ul><h3 id="unrealistic-rendering"><a class="markdownIt-Anchor" href="#unrealistic-rendering"></a> Unrealistic Rendering</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/25595069">[知乎]卡通渲染（上）</a>  <a href="https://zhuanlan.zhihu.com/p/25939794">[知乎]卡通渲染（下）</a></li></ul><h3 id="shadows"><a class="markdownIt-Anchor" href="#shadows"></a> Shadows</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/27339998">[知乎]简述47种Shader Map的渲染原理与制作方法</a></li></ul><h3 id="specific-effects"><a class="markdownIt-Anchor" href="#specific-effects"></a> Specific Effects</h3><ul><li>(TBC)</li></ul><h2 id="3d-mathmodelmesh"><a class="markdownIt-Anchor" href="#3d-mathmodelmesh"></a> 3D Math/Model/Mesh</h2><h3 id="transform"><a class="markdownIt-Anchor" href="#transform"></a> Transform</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/26217154">[知乎]全面认识Depth - 这里有关于Depth的一切</a></li></ul><h3 id="implicit-representation"><a class="markdownIt-Anchor" href="#implicit-representation"></a> Implicit Representation</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/26217154">[知乎]Signed Distance Field</a></li></ul><h2 id="procedure-generation"><a class="markdownIt-Anchor" href="#procedure-generation"></a> Procedure Generation</h2><h3 id="pcg-algorithm"><a class="markdownIt-Anchor" href="#pcg-algorithm"></a> PCG Algorithm</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/66416593">[知乎]基于《波函数坍缩算法》的无限城市程序化随机生成</a></li><li><a href="https://zhuanlan.zhihu.com/p/30724817">[知乎]【游必有方】一种 RogueLike 地图生成算法</a></li></ul><h2 id="gpugraphics-api"><a class="markdownIt-Anchor" href="#gpugraphics-api"></a> GPU/Graphics API</h2><h3 id="gpu-hardware"><a class="markdownIt-Anchor" href="#gpu-hardware"></a> GPU Hardware</h3><ul><li><a href="https://www.cnblogs.com/timlly/p/11471507.html">深入GPU硬件架构及运行机制</a></li><li>(TBC)</li></ul><h3 id="opengl"><a class="markdownIt-Anchor" href="#opengl"></a> OpenGL</h3><ul><li><a href="https://learnopengl-cn.github.io/">LaernOpenGL(最良心的OpenGL教程之一)</a></li></ul><h3 id="glslhlslshaderlabxxsl"><a class="markdownIt-Anchor" href="#glslhlslshaderlabxxsl"></a> GLSL/HLSL/Shaderlab/xxSL</h3><ul><li><a href="https://www.shadertoy.com/">Shadertoy</a></li><li><a href="https://github.com/patriciogonzalezvivo/thebookofshaders">The Book of Shaders</a></li><li><a href="https://zhuanlan.zhihu.com/p/33260382">[知乎]Shader中if和for的效率问题以及使用策略</a></li></ul><h2 id="misc"><a class="markdownIt-Anchor" href="#misc"></a> Misc</h2><h3 id="膜dalao"><a class="markdownIt-Anchor" href="#膜dalao"></a> 膜dalao</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/97700605">胡渊鸣——99行代码的《冰雪奇缘》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PBR、IBL与其简单实现</title>
      <link href="/2019/09/12/slide/PBR-IBL/"/>
      <url>/2019/09/12/slide/PBR-IBL/</url>
      
        <content type="html"><![CDATA[<!-- .slide: data-background="#49B1F5" --><h1 id="pbr与简单ibl"><a class="markdownIt-Anchor" href="#pbr与简单ibl"></a> PBR与简单IBL</h1><p>====</p><!-- .slide: data-background="#2874A6" --><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mo stretchy="false">(</mo><msub><mi>k</mi><mi>d</mi></msub><mfrac><mi>c</mi><mi>π</mi></mfrac><mo>+</mo><msub><mi>k</mi><mi>s</mi></msub><mfrac><mrow><mi>D</mi><mi>F</mi><mi>G</mi></mrow><mrow><mn>4</mn><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega}          (k_d\frac{c}{\pi} + k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})         L_i(p,\omega_i) (n \cdot \omega_i)  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><h5 id="-element-classfragment-"><a class="markdownIt-Anchor" href="#-element-classfragment-"></a> ???<!-- .element: class="fragment" --></h5><p>====</p><p>可见光 = 波长介于400nm ~ 700nm的电磁波</p><p>研究光的理论有<strong>波动光学</strong>和<strong>几何光学</strong>两种。</p><p>渲染的尺度远大于光的波长，也不涉及衍射、干涉、偏振现象，故使用<strong>几何光学</strong>。</p><p>==</p><p>光线沿直线传播（至少在欧式空间中是这样）</p><p>对于真空环境（在CG中，一般就是没有雾的环境），光只在介质交接面上发生<strong>散射</strong>。</p><p>====</p><!-- .slide: data-background="#F0F0F0" --><h4 id="两种基本散射现象"><a class="markdownIt-Anchor" href="#两种基本散射现象"></a> 两种基本散射现象</h4><p><img src="/images/pbr-scattering.png" alt="" /></p><p>==</p><table><thead><tr><th>反射</th><th>折射</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub><mo>=</mo><mn>2</mn><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>l</mi><mo stretchy="false">)</mo><mi>n</mi><mo>−</mo><mi>l</mi></mrow><annotation encoding="application/x-tex">r_i=2(n \cdot l)n-l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span></td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>s</mi><mi>i</mi><mi>n</mi><msub><mi>θ</mi><mi>i</mi></msub></mrow><mrow><mi>s</mi><mi>i</mi><mi>n</mi><msub><mi>θ</mi><mi>t</mi></msub></mrow></mfrac><mo>=</mo><mfrac><msub><mi>n</mi><mi>t</mi></msub><msub><mi>n</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">\frac{sin\theta_i}{sin\theta_t}=\frac{n_t}{n_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.3413079999999997em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8962079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.29634285714285713em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">n</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.02778em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1565919999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7114919999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.29634285714285713em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>r</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">r_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为反射向量，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>是入射方向向量</td><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>表示入射，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>表示折射，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>为向量与法线的夹角，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>为介质折射率</td></tr></tbody></table><p>反射与折射的比例由**菲涅尔定律（Fresenel equation）**决定。</p><p>====</p><h4 id="反射微平面"><a class="markdownIt-Anchor" href="#反射微平面"></a> 反射微平面</h4><!-- .slide: data-background="#F0F0F0" --><p><img src="/images/pbr-microsurface.png" alt="" /></p><p>==</p><p>现实中的物体不是理想光学平面，可以看做由很多微小的理想平面（称为<strong>微平面</strong>）构成。</p><p>如果微表面的朝向差别较大，反射的像显得粗糙；较小则显得光滑。</p><p>====</p><h4 id="折射"><a class="markdownIt-Anchor" href="#折射"></a> 折射</h4><!-- .slide: data-background="#F0F0F0" --><p><img src="/images/pbr-material-diff.png" alt="" /></p><p>左：金属   |   右：非金属</p><p>折射部分的光线，不同的介质有相差较大的表现。</p><p>==</p><p>在不透明物体与半透明物体中：</p><ul><li><p>金属会直降将折射的光线吸收，转化为其他能量（看不见了）。</p></li><li><p>非金属则使折射光线在其表面之下继续发生多次散射，大部分光重新射出表面。</p></li></ul><p>Notes:</p><p>透明物质由**双向投射分布函数（BTDF）**描述。</p><p>==</p><!-- .slide: data-background="#F0F0F0" --><p><img src="/images/pbr-sss-scale.png" alt="" /></p><p>==</p><p>重新射出表面的光线，其位置分布不同决定了宏观的视觉表现。</p><ul><li>位置在一个渲染像素内，可以认为是同一个点射出，宏观上为<strong>漫反射</strong>。</li><li>位置在一个渲染像素外，宏观上体现为<strong>次表面散射</strong>（半透明）。</li></ul><p>Notes:</p><p>这告诉了我们一个很重要的事实：次表面散射在很远的距离上可以看做是漫反射，而漫反射在很近的距离上可以看做是次表面散射。</p><p>====</p><h4 id="怎么描述反射现象"><a class="markdownIt-Anchor" href="#怎么描述反射现象"></a> 怎么描述反射现象？</h4><ul><li>用仪器测量不同材料的光学性质：<a href="http://www.merl.com/brdf/">MERL</a></li><li>经验模型：Phong、Blinn-Phong</li><li>1981年Cook-Torrance在《A Reflectance Model for Computer Graphics》中引入辐射度学和微表面理论，建立了如今广泛使用的物理模型。</li></ul><p>====</p><!-- .slide: data-background="#CD6155" --><p>这个物理模型也就是以<s>臭名昭著</s>广为人知的渲染方程来表述的：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><msub><mi>f</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) (n \cdot \omega_i ) d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>要明白这个方程，需要先对<strong>辐射度学</strong>有个基本的了解。</p><p>Notes:</p><p>这里的方程准确来说是<strong>反射率方程</strong>，为渲染的一个特化版本。</p><p>==</p><h4 id="辐射通量-phi"><a class="markdownIt-Anchor" href="#辐射通量-phi"></a> 辐射通量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi></mrow><annotation encoding="application/x-tex">\Phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Φ</span></span></span></span></h4><p>Radiant Flux，也称<strong>辐射功率</strong>，单位为瓦特（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span></span></span></span>），或焦耳/秒（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>J</mi><mi mathvariant="normal">/</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">J/s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="mord">/</span><span class="mord mathdefault">s</span></span></span></span>）</p><p>指单位时间内通过表面或空间区域的能量总量</p><p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Φ</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>Q</mi></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\Phi = \frac{dQ}{dt}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Φ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.277216em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322159999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">Q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>==</p><h4 id="辐照度-e"><a class="markdownIt-Anchor" href="#辐照度-e"></a> 辐照度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span></h4><p>Irradiance，单位为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mi mathvariant="normal">/</mi><msup><mi>m</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">W/m^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p><p>指单位时间内到达单位面积的辐射通量</p><p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi mathvariant="normal">Φ</mi></mrow><mrow><mi>d</mi><mi>A</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">E =\frac{d\Phi}{dA}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">A</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">Φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，式中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">dA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">A</span></span></span></span>表示一个极小的面积</p><p><img src="/images/pbr-irradiance.png" alt="" /></p><p>==</p><h4 id="立体角-omega"><a class="markdownIt-Anchor" href="#立体角-omega"></a> 立体角 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ω</mi></mrow><annotation encoding="application/x-tex">\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span></h4><p>Solid Angle，单位为<strong>球面度</strong>（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">sr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>），可以看做是三维的弧度。</p><p><img src="/images/pbr-solidangle.jpg" alt="" /></p><p>Notes:</p><p>整个球面的立体角为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mi>π</mi></mrow><annotation encoding="application/x-tex">4\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>。</p><p>==</p><h4 id="辐射强度-i"><a class="markdownIt-Anchor" href="#辐射强度-i"></a> 辐射强度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding="application/x-tex">I</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span></h4><p>Radiant Intensity，单位为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mi mathvariant="normal">/</mi><mi>s</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">W/sr</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>，为通过单位立体角的辐射通量</p><p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi mathvariant="normal">Φ</mi></mrow><mrow><mi>d</mi><mi>ω</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">E =\frac{d\Phi}{d\omega}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">Φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，式中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>ω</mi></mrow><annotation encoding="application/x-tex">d\omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span></span></span></span>表示一个极小的立体角</p><p>Notes:</p><blockquote><p>之所以引入辐射强度，是因为有时候要度量通过一个点的通量的密度，但因为点的面积是0，无法使用辐照度，所以引入辐射强度。辐射强度不会随距离变化而变化，不像点光源的辐照度会随距离增大而衰减，这是因为立体角不会随距离变化而变化。</p></blockquote><p>==</p><h4 id="辐射率-l"><a class="markdownIt-Anchor" href="#辐射率-l"></a> 辐射率 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span></h4><p>Radiance，单位为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>W</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><msup><mi>m</mi><mn>2</mn></msup><mo>⋅</mo><mi>s</mi><mi>r</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">W/(m^2 \cdot sr)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord">/</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span>，为每单位面积每单位立体角的辐射通量密度</p><p>定义<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi mathvariant="normal">Φ</mi></mrow><mrow><mi>d</mi><mi>ω</mi><mi>d</mi><msup><mi>A</mi><mo>⊥</mo></msup></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><mi mathvariant="normal">Φ</mi></mrow><mrow><mi>d</mi><mi>ω</mi><mi>d</mi><mi>A</mi><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">E =\frac{d\Phi}{d\omega dA^{\perp}}=\frac{d\Phi}{d\omega dA cos\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2375279999999997em;vertical-align:-0.3574199999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.64258em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span><span class="mord mathdefault mtight">d</span><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mrel mtight">⊥</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">Φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3574199999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">Φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，式中其中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msup><mi>A</mi><mo>⊥</mo></msup></mrow><annotation encoding="application/x-tex">dA^{\perp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mrel mtight">⊥</span></span></span></span></span></span></span></span></span></span></span></span>是微分面积<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">dA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">A</span></span></span></span>在垂直于光线方向上的投影</p><p><img src="/images/pbr-radiance.png" alt="" /></p><p>==</p><p>倾斜时实际投射变小</p><p><img src="/images/pbr-radient.png" alt="" /></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi mathvariant="normal">Φ</mi></mrow><mrow><mi>d</mi><mi>ω</mi><mi>d</mi><msup><mi>A</mi><mo>⊥</mo></msup></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><mi mathvariant="normal">Φ</mi></mrow><mrow><mi>d</mi><mi>ω</mi><mi>d</mi><mi>A</mi><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">E =\frac{d\Phi}{d\omega dA^{\perp}}=\frac{d\Phi}{d\omega dA cos\theta}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2375279999999997em;vertical-align:-0.3574199999999999em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.64258em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span><span class="mord mathdefault mtight">d</span><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7820285714285713em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mrel mtight">⊥</span></span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">Φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3574199999999999em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">ω</span><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mtight">Φ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">cos\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>就是光线向量与法线向量的点积。</p><p>====</p><!-- .slide: data-background="#F0F0F0" --><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><msub><mi>f</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega} f_r(p,\omega_i,\omega_o) L_i(p,\omega_i) (n \cdot \omega_i ) d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><img src="/images/ibl_hemisphere_sample.png" alt="" /></p><p>Notes:</p><p>积分域<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span></span></span></span>指一个半球。</p><p>方程的结果是辐射率，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">dA</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">A</span></span></span></span>趋于无限小后就是点<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>，立体角趋于无穷小后就是方向向量。</p><p>这个方程可以理解为在半球法线指向的半球上对很小的立体角<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>做积分，积分的内容是入射光与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">f_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n \cdot \omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的乘积。</p><p>==</p><ul><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为入射辐射率</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">n \cdot \omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>项是因入射光线与平面夹角出现的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">cos\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></li><li>唯一未知的仅剩<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_r(p,\omega_i,\omega_o)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></li></ul><p>====</p><!-- .slide: data-background="#F0F0F0" --><h3 id="brdf"><a class="markdownIt-Anchor" href="#brdf"></a> BRDF</h3><p>双向反射分布函数，表示出射光和入射光的比例关系，单位为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><msup><mi>r</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">sr^{-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>→</mo><msub><mi>f</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>θ</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ϕ</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>θ</mi><mi>o</mi></msub><mo separator="true">,</mo><msub><mi>ϕ</mi><mi>o</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f_r(p,\omega_i,\omega_o) \rightarrow f_r(p,\theta_i,\phi_i,\theta_o,\phi_o)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><img src="/images/brdf.png" alt="" /></p><p>Notes:</p><p>这里，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">\omega_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>分别表示入射与出射方向，如果用球坐标可以表示为第二种形式</p><p>==</p><p>Cook-Torrance 提供的BRDF有漫反射和镜面反射两个部分</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>r</mi></msub><mo>=</mo><msub><mi>k</mi><mi>d</mi></msub><msub><mi>f</mi><mrow><mi>l</mi><mi>a</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>t</mi></mrow></msub><mo>+</mo><msub><mi>k</mi><mi>s</mi></msub><msub><mi>f</mi><mrow><mi>c</mi><mi>o</mi><mi>o</mi><mi>k</mi><mo>−</mo><mi>t</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_r = k_d f_{lambert} +  k_s f_{cook-torrance}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>d</mi></msub></mrow><annotation encoding="application/x-tex">k_d</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">k_s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为相应系数，在能量守恒的要求下，有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>k</mi><mi>d</mi></msub><mo>+</mo><msub><mi>k</mi><mi>s</mi></msub><mo>≤</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">k_d + k_s \le 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>==</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>l</mi><mi>a</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>t</mi></mrow></msub><mo>=</mo><mfrac><mi>c</mi><mi>π</mi></mfrac></mrow><annotation encoding="application/x-tex">f_{lambert} = \frac{c}{\pi}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">b</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.7935600000000003em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>Lambertian漫反射部分，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span></span></span></span>为表面颜色，除<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>是为了标准化（<a href="https://www.cnblogs.com/jerrycg/p/4941359.html">推导</a>）</p><p><img src="/images/brdf-diffuse.png" alt="" /></p><p>Notes:</p><p>目前存在着许多不同类型的模型来实现BRDF的漫反射部分，大多看上去都相当真实，但是相应的运算开销也非常的昂贵。不过按照Epic公司给出的结论，Lambertian漫反射模型已经足够应付大多数实时渲染的用途了。</p><p>==</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mrow><mi>c</mi><mi>o</mi><mi>o</mi><mi>k</mi><mo>−</mo><mi>t</mi><mi>o</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mi>F</mi><mo stretchy="false">(</mo><mi>v</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo><mi>G</mi><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><mrow><mn>4</mn><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">f_{cook-torrance} = \frac{D(h) F(v,h) G(l,v,h)}{4(\omega_o \cdot n)(\omega_i \cdot n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.902771em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>镜面方式部分，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span>为半角向量：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>v</mi></mrow><mrow><mi mathvariant="normal">∥</mi><mi>l</mi><mo>+</mo><mi>v</mi><mi mathvariant="normal">∥</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">h = \frac{l + v}{\|l + v\|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.400108em;vertical-align:-0.52em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∥</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mtight">∥</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.52em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>分子的三个函数分别为法线分布函数(Normal <strong>D</strong>istribution Function)，菲涅尔方程(<strong>F</strong>resnel Rquation)和几何函数(<strong>G</strong>eometry Function)，分母为归一化项</p><p>==</p><ul><li><strong>法线分布函数</strong>：估算在受到表面粗糙度的影响下，取向方向与中间向量一致的微平面的数量。估算微平面的主要函数。</li><li><strong>几何函数</strong>：描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。</li><li><strong>菲涅尔方程</strong>：描述不同的表面角下表面所反射的光线所占的比率。</li></ul><p>Notes:</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mi>F</mi><mi>G</mi></mrow><annotation encoding="application/x-tex">DFG</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span></span></span></span>项其实是近似出来的，用3个函数分别表示了某一种特性。</p><p>==</p><!-- .slide: data-background="#F0F0F0" --><h5 id="将整个brdf放入渲染方程"><a class="markdownIt-Anchor" href="#将整个brdf放入渲染方程"></a> 将整个brdf放入渲染方程</h5><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mo stretchy="false">(</mo><msub><mi>k</mi><mi>d</mi></msub><mfrac><mi>c</mi><mi>π</mi></mfrac><mo>+</mo><msub><mi>k</mi><mi>s</mi></msub><mfrac><mrow><mi>D</mi><mi>F</mi><mi>G</mi></mrow><mrow><mn>4</mn><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega}          (k_d\frac{c}{\pi} + k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})         L_i(p,\omega_i) (n \cdot \omega_i)  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>Notes:</p><p>得到这个式子后我们终于可以开始介绍IBL了。</p><p>==</p><p>对于不同的光源类型，采用不同的计算方法：</p><ul><li>直接光源（点光源、方向光）</li><li>IBL</li><li>面光源</li></ul><p>====</p><!-- .slide: data-background="#49B1F5" --><h3 id="ibl"><a class="markdownIt-Anchor" href="#ibl"></a> IBL</h3><p>基于图像的光照（Image Based Lighting），是指光源不是精确定义的光源（如点光源、方向光），而是由环境贴图上的颜色决定。</p><p>环境贴图一般是实景拍摄的HDR图片</p><p>Notes:</p><p>环境贴图有立方体贴图和球形贴图（等距柱状投影图），一般实时渲染选择性能较高的立方体贴图。</p><p>==</p><p><img src="/images/ibl_hdr_radiance.png" alt="" /></p><p>==</p><p>HDRI图像一般是以**等距柱状投影图(Equirectangular Map)**储存的，看起来非常扭曲。</p><p>实时渲染一般使用<strong>立方体贴图（CubeMap）</strong>，因为其采样性能较高。</p><p>因此需要先做一个转换。</p><p>Notes:</p><p>水平视角附近分辨率较高，而底部和顶部方向分辨率较低,在大多数情况下，这是一个不错的折衷方案，因为对于几乎所有渲染器来说，大部分有意义的光照和环境信息都在水平视角附近方向。</p><p>==</p><p>转换方法：渲染一个立方体，将等距柱状图投影到立方体的每个面，并将立方体的六个面的图像构造成立方体贴图。</p><p>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;</span><br><span class="line">in vec3 localPos;</span><br><span class="line"></span><br><span class="line">uniform sampler2D equirectangularMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> vec2 invAtan = vec2(<span class="number">0.1591</span>, <span class="number">0.3183</span>);</span><br><span class="line"><span class="function">vec2 <span class="title">SampleSphericalMap</span><span class="params">(vec3 v)</span> </span>&#123;</span><br><span class="line">    vec2 uv = vec2(<span class="built_in">atan</span>(v.z, v.x), <span class="built_in">asin</span>(v.y));</span><br><span class="line">    uv *= invAtan;</span><br><span class="line">    uv += <span class="number">0.5</span>;</span><br><span class="line">    <span class="keyword">return</span> uv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">    vec2 uv = SampleSphericalMap(normalize(localPos)); <span class="comment">// make sure to normalize localPos</span></span><br><span class="line">    vec3 color = texture(equirectangularMap, uv).rgb;</span><br><span class="line">    </span><br><span class="line">    FragColor = vec4(color, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>====</p><p>通过立方体贴图，每一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>方向上的光源亮度可以从环境贴图上采样得到</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>ω</mi><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>C</mi><mi>U</mi><mi>B</mi><mi>E</mi><mo stretchy="false">(</mo><mi>c</mi><mi>u</mi><mi>b</mi><mi>e</mi><mi>m</mi><mi>a</mi><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>p</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(p,\omega) = texCUBE(cubemap, \omega_p)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p>这里的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>指物体位置，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">\omega_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>是用物体位置<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>矫正后的立方体贴图采样向量。</p><p>Notes:</p><p>为什么不直接用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：严格来说，渲染方程中的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>为物体上的某一点。然而我们并不可能为每一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>点创建立方体贴图。</p><p>不过可以放弃一些质量以换取合理性能：在场景中创建多个<strong>环境探针</strong>，找出离<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>最近的环境贴图，并用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>点位置与环境贴图位置得到矫正后的采样向量<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">\omega_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</p><p>==</p><p>还记得这个方程吗？</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mo stretchy="false">(</mo><msub><mi>k</mi><mi>d</mi></msub><mfrac><mi>c</mi><mi>π</mi></mfrac><mo>+</mo><msub><mi>k</mi><mi>s</mi></msub><mfrac><mrow><mi>D</mi><mi>F</mi><mi>G</mi></mrow><mrow><mn>4</mn><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega}          (k_d\frac{c}{\pi} + k_s\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)})         L_i(p,\omega_i) (n \cdot \omega_i)  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">s</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>==</p><p>我们将这个方程的<strong>漫反射项</strong>与<strong>镜面反射项</strong>分开并去掉系数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">漫</mi><mi mathvariant="normal">反</mi><mi mathvariant="normal">射</mi><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mo stretchy="false">(</mo><mfrac><mi>c</mi><mi>π</mi></mfrac><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">漫反射 L_o(p,\omega_o) = \int\limits_{\Omega} (\frac{c}{\pi}) L_i(p,\omega_i) n \cdot \omega_i  d\omega_i </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">漫</span><span class="mord cjk_fallback">反</span><span class="mord cjk_fallback">射</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">镜</mi><mi mathvariant="normal">面</mi><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mo stretchy="false">(</mo><mfrac><mrow><mi>D</mi><mi>F</mi><mi>G</mi></mrow><mrow><mn>4</mn><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac><mo stretchy="false">)</mo><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">镜面 L_o(p,\omega_o) = \int\limits_{\Omega} (\frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}) L_i(p,\omega_i) (n \cdot \omega_i)  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">镜</span><span class="mord cjk_fallback">面</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>====</p><h4 id="漫反射项"><a class="markdownIt-Anchor" href="#漫反射项"></a> 漫反射项</h4><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>c</mi><mi>π</mi></mfrac><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) =  \frac{c}{\pi} \int\limits_{\Omega} L_i(p,\omega_i) (n \cdot \omega_i)  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>由于其brdf只涉及常数项，将常数项提出后，右式的积分中只涉及到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>在环境贴图的中心，剩下的变量仅剩<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>了，我们可以通过<strong>预计算</strong>解决这一部分的计算。</p><p>Notes:</p><p>这里的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>实际上成为了对计算后的贴图采样的参数。</p><p>==</p><p>这样，右边的积分就可以塞进一个立方体贴图中</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>C</mi><mi>U</mi><mi>B</mi><mi>E</mi><mo stretchy="false">(</mo><mi>l</mi><mi>a</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>t</mi><mi>C</mi><mi>u</mi><mi>b</mi><mi>e</mi><mi>m</mi><mi>a</mi><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mrow><mi>o</mi><mi>p</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(p,\omega_o) = texCUBE(lambertCubemap, \omega_{op})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">u</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mrow><mi>o</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\omega_{op}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>为以<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span></span></span></span>点位置与立方体贴图位置得到的出射向量</p><p>====</p><!-- .slide: data-background="#F0F0F0" --><p><img src="/images/ibl_irradiance.png" alt="" /></p><p>预计算得到的辐照贴图</p><p>==</p><p>接下来就是如何得到预计算的这个贴图了</p><p>需要对环境贴图做<strong>卷积</strong>运算</p><p>Notes:</p><p>实际上，计算结果就是环境贴图与<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\mathbf n \cdot \omega_i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbf">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的卷积。</p><p>==</p><!-- .slide: data-background="#F0F0F0" --><p>对半球积分时，我们很难直接处理立体角<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，故可以用球坐标<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>θ</mi><mo separator="true">,</mo><mi>ϕ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\theta,\phi)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ϕ</span><span class="mclose">)</span></span></span></span>替代</p><p><img src="/images/ibl_spherical_integrate.png" alt="" /></p><p>立体角与球坐标的关系为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub><mo>=</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>d</mi><mi>θ</mi><mi>d</mi><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">d\omega_i = \sin(\theta) d\theta d\phi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mord mathdefault">d</span><span class="mord mathdefault">ϕ</span></span></span></span>，多出来的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">sin(\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>是因为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>很小时其立体角也相应小些</p><p>==</p><p>得到球坐标下的积分公式</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ϕ</mi><mi>o</mi></msub><mo separator="true">,</mo><msub><mi>θ</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>c</mi><mi>π</mi></mfrac><msubsup><mo>∫</mo><mrow><mi>ϕ</mi><mo>=</mo><mn>0</mn></mrow><mrow><mn>2</mn><mi>π</mi></mrow></msubsup><msubsup><mo>∫</mo><mrow><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>π</mi></mrow></msubsup><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ϕ</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>θ</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>d</mi><mi>ϕ</mi><mi>d</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">L_o(p,\phi_o, \theta_o) = \frac{c}{\pi} \int_{\phi = 0}^{2\pi} \int_{\theta = 0}^{\frac{1}{2}\pi} L_i(p,\phi_i, \theta_i) \cos(\theta) \sin(\theta)  d\phi d\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.7519780000000003em;vertical-align:-1.048058em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5640079999999998em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ϕ</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.8129em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.048058em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7039200000000003em;"><span style="top:-2.08805em;margin-left:-0.44445em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-4.112900000000001em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8443142857142858em;"><span style="top:-2.656em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.344em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">ϕ</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span></p><p>==</p><!-- .slide: data-background="#F0F0F0" --><p>数值积分：对立方体贴图的每一个纹素在纹素所代表的方向的半球<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Ω</span></span></span></span>内生成固定数量的采样向量，并对采样结果取平均值</p><p>数量固定的采样向量将<strong>均匀地</strong>分布在半球内部</p><p><img src="/images/ibl_hemisphere_sample.png" alt="" /></p><p>Notes:</p><p>当然也可以用蒙特卡洛之类的方法积分</p><p>==</p><p>积分转化为如下<strong>黎曼和</strong>的形式</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ϕ</mi><mi>o</mi></msub><mo separator="true">,</mo><msub><mi>θ</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mi>c</mi><mi>π</mi></mfrac><mfrac><mn>1</mn><mrow><mi>n</mi><mn>1</mn><mo>⋅</mo><mi>n</mi><mn>2</mn></mrow></mfrac><munderover><mo>∑</mo><mrow><mi>ϕ</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mn>1</mn></mrow></munderover><munderover><mo>∑</mo><mrow><mi>θ</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mn>2</mn></mrow></munderover><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ϕ</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>θ</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mi>d</mi><mi>ϕ</mi><mi>d</mi><mi>θ</mi></mrow><annotation encoding="application/x-tex">L_o(p,\phi_o,\theta_o) = \frac{c}{\pi} \frac{1}{n1 \cdot n2} \sum_{\phi = 0}^{n1} \sum_{\theta = 0}^{n2} L_i(p,\phi_i, \theta_i) \cos(\theta) \sin(\theta)  d\phi d\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.239334em;vertical-align:-1.438221em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.10756em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.801113em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">ϕ</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.438221em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.801113em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">ϕ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord mathdefault">ϕ</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span></span></p><p>==</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">vec3 irradiance = vec3(<span class="number">0.0</span>);  </span><br><span class="line"></span><br><span class="line">vec3 up    = vec3(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">vec3 right = cross(up, normal);</span><br><span class="line">vec3 up    = cross(normal, right);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> sampleDelta = <span class="number">0.025</span>; </span><br><span class="line"><span class="keyword">float</span> nrSamples = <span class="number">0.0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">float</span> phi = <span class="number">0.0</span>; phi &lt; <span class="number">2.0</span> * PI; phi += sampleDelta) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">float</span> theta = <span class="number">0.0</span>; theta &lt; <span class="number">0.5</span> * PI; theta += sampleDelta) &#123;</span><br><span class="line">        <span class="comment">// spherical to cartesian (in tangent space)</span></span><br><span class="line">        vec3 tangentSample = vec3(<span class="built_in">sin</span>(theta) * <span class="built_in">cos</span>(phi),  <span class="built_in">sin</span>(theta) * <span class="built_in">sin</span>(phi), <span class="built_in">cos</span>(theta));</span><br><span class="line">        <span class="comment">// tangent space to world</span></span><br><span class="line">        vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; </span><br><span class="line"></span><br><span class="line">        irradiance += texture(environmentMap, sampleVec).rgb * <span class="built_in">cos</span>(theta) * <span class="built_in">sin</span>(theta);</span><br><span class="line">        nrSamples++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">irradiance = PI * irradiance * (<span class="number">1.0</span> / <span class="keyword">float</span>(nrSamples));</span><br></pre></td></tr></table></figure><!-- .element: style="width:100%;" --><p>Notes:</p><p>因为卷积后图像本就很模糊，其分辨率不需要太高</p><p>====</p><h4 id="漫反射ibl实现的总体流程"><a class="markdownIt-Anchor" href="#漫反射ibl实现的总体流程"></a> 漫反射IBL实现的总体流程</h4><ol><li>导入一张HDR环境贴图作为当前的环境立方体贴图</li><li>对环境贴图求卷积，得到新的卷积环境贴图（看起来模糊的环境贴图）</li><li>在PBR Shader中将新卷积贴图作为输入，以法线<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>为采样坐标，获得某一点的漫反射辐照度<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span></li><li>PBR公式根据物体表面属性贴图，计算出最终辐射率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span></li></ol><p>==</p><!-- .slide: data-background="#F0F0F0" --><p>最终效果</p><p><img src="/images/lambert_rendering_equation.jpg" alt="" /></p><p>====</p><h4 id="镜面反射项"><a class="markdownIt-Anchor" href="#镜面反射项"></a> 镜面反射项</h4><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mfrac><mrow><mi>D</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo><mi>F</mi><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo><mi>G</mi><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo separator="true">,</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><mrow><mn>4</mn><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>o</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo>⋅</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mfrac><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega} \frac{D(h) F(\omega_o,h) G(\omega_i,\omega_o,h)}{4(\omega_o \cdot n)(\omega_i \cdot n)} L_i(p,\omega_i) (n \cdot \omega_i)  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.032456em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mo>=</mo><mfrac><mrow><mi>l</mi><mo>+</mo><mi>v</mi></mrow><mrow><mi mathvariant="normal">∥</mi><mi>l</mi><mo>+</mo><mi>v</mi><mi mathvariant="normal">∥</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">h = \frac{l + v}{\|l + v\|}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.30744em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">∥</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord">∥</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>其brdf不仅涉及到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，还包含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">\omega_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，也就意味着不能用CubeMap储存</p><p>Notes:</p><p>之前的漫反射项只涉及2个自由度，可以存在2D贴图中；而现在镜面项涉及4个自由度，难以直接保存。</p><p>==</p><p>Epic Games在其Siggraph2012的<a href="https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf">论文</a>中指出可以将积分以<strong>Split Sum</strong>拆解为两个独立的部分</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>o</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub><mo>∗</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><msub><mi>f</mi><mi>r</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_o(p,\omega_o) = \int\limits_{\Omega} L_i(p,\omega_i) d\omega_i * \int\limits_{\Omega} f_r(p, \omega_i, \omega_o) n \cdot \omega_i d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.9665809999999997em;vertical-align:-1.605456em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.361125em;"><span style="top:-1.8545440000000004em;margin-left:-0.44445em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.3611250000000004em;"><span class="pstrut" style="height:3.3600000000000003em;"></span><span><span class="mop op-symbol large-op" style="margin-right:0.44445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.605456em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>这种近似在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>恒定时是没有误差的，对于大部分环境来说其误差不大</p><p>==</p><p>前一部分积分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><msub><mi>L</mi><mi>i</mi></msub><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\int\limits_{\Omega} L_i(p,\omega_i) d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.855451em;vertical-align:-1.049891em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8055600000000002em;"><span style="top:-2.050109em;margin-left:-0.19445em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.00056em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op" style="margin-right:0.19445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.049891em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的结果称为<strong>预过滤环境贴图（Pre-Filtered Environment Map）</strong></p><p>将不同<strong>粗糙度（Roughness）<strong>下的卷积图以</strong>Mipmap</strong>的形式储存，并插值读取</p><p>==</p><!-- .slide: data-background="#F0F0F0" --><p><img src="/images/ibl_prefilter_map.png" alt="" /></p><p>==</p><p>由于描述粗糙度的**法线分布函数（NDF）**中涉及观察方向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">\omega_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>而前面说到我们不可能在贴图中记录下<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">\omega_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>这个额外的维度</p><p>Epic Games做了一个进一步的假设：视线均来自法线方向</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub><mo>=</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\omega_o = n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></span></p><p>==</p><!-- .slide: data-background="#F0F0F0" --><p>这样，积分就不涉及<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>ω</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">\omega_o</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>但这个假设也使得我们丢失了倾斜角较大时狭长的反射</p><p><img src="/images/ibl_grazing_angles.png" alt="" /></p><p>Notes:</p><p>这一部分近似是IBL实现中偏差最大的近似，但总的来说算是一个合理的取舍</p><p>==</p><p>后一部分积分<span class="katex"><span class="katex-mathml"><math><semantics><mrow><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mi>f</mi><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><msub><mi>ω</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub><mo>=</mo><munder><mo>∫</mo><mi mathvariant="normal">Ω</mi></munder><mi>f</mi><mo stretchy="false">(</mo><msub><mi>ω</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>ω</mi><mi>o</mi></msub><mo stretchy="false">)</mo><mi>c</mi><mi>o</mi><mi>s</mi><msub><mi>θ</mi><mi>i</mi></msub><mi>d</mi><msub><mi>ω</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\int\limits_{\Omega} f(\omega_i,\omega_o) (n \cdot \omega_i)  d\omega_i = \int\limits_{\Omega} f(\omega_i,\omega_o) cos\theta_i  d\omega_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.855451em;vertical-align:-1.049891em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8055600000000002em;"><span style="top:-2.050109em;margin-left:-0.19445em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.00056em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op" style="margin-right:0.19445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.049891em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.855451em;vertical-align:-1.049891em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8055600000000002em;"><span style="top:-2.050109em;margin-left:-0.19445em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span><span style="top:-3.00056em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op" style="margin-right:0.19445em;">∫</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.049891em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p><p>这一部分积分的结果相当于假设了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">L_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>恒为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><p>Epic Games发现代入相应公式后整个公式可以化简到只有2个输入（Roughness和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><msub><mi>θ</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">cos\theta_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）与2个输出，而这一部分也是同样用预计算解决</p><p>==</p><!-- .slide: data-background="#F0F0F0" --><p>得到如下的<strong>查找图（LUT，Look-up Texture）</strong></p><p><img src="/images/ibl-lut.png" alt="" /></p><p>Notes:</p><p>这个贴图采用的是<em>R16G16</em>格式，需要更多精度</p><p>如何计算由于时间原因，不讲</p><p>==</p><p>最后，将两部分积分合在一起，得到镜面部分结果</p><p>====</p><!-- .slide: data-background="#F0F0F0" --><p>将近似的模型与物理准确的结果对比</p><p><img src="/images/ibl-result-compare.png" alt="" /></p><p>从上到下：Split Sum近似；包含<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">n = v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>的近似；事实参考</p><p>====</p><h3 id="the-end"><a class="markdownIt-Anchor" href="#the-end"></a> The End</h3><p>Reference:</p><ul><li><a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance">https://learnopengl.com/PBR/IBL/Diffuse-irradiance</a></li><li><a href="https://blog.selfshadow.com/publications/s2012-shading-course/hoffman/s2012_pbs_physics_math_notebook.pdf">https://blog.selfshadow.com/publications/s2012-shading-course/hoffman/s2012_pbs_physics_math_notebook.pdf</a></li><li><a href="https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf">https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf</a></li><li><a href="http://www.codinglabs.net/article_physically_based_rendering.aspx">http://www.codinglabs.net/article_physically_based_rendering.aspx</a></li><li><a href="https://zhuanlan.zhihu.com/p/33464301">https://zhuanlan.zhihu.com/p/33464301</a></li><li><a href="https://zhuanlan.zhihu.com/p/21376124">https://zhuanlan.zhihu.com/p/21376124</a></li><li><a href="https://www.cnblogs.com/jerrycg/p/4924761.html">https://www.cnblogs.com/jerrycg/p/4924761.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实时渲染 </tag>
            
            <tag> PBR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来玩游戏啦！</title>
      <link href="/2019/06/21/COSE/"/>
      <url>/2019/06/21/COSE/</url>
      
        <content type="html"><![CDATA[<p>最近游戏开发导论的课设项目，已经圆满结束啦（<s>其实是没时间以及放弃继续了</s></p><p>这里我导出了一个可以在浏览器中直接玩的版本，欢迎体验，以及提bug~</p><p>操作说明：</p><ul><li>WASD 移动</li><li>鼠标 控制射击方向</li><li>鼠标 <strong>左键</strong>射击</li><li>鼠标 <strong>滚轮</strong>切换武器。</li><li>游戏中 <code>Esc 键</code> 退出。</li></ul><a id="more"></a><p><a href="/resource/COSE/index.html"><strong>点击这里试玩</strong></a></p><p>建议把窗口缩放调到<code>50%</code>以获得更好的分辨率~</p><p><em>（主菜单退出按钮有问题，请忽略…）</em></p><h5 id="版本说明"><a class="markdownIt-Anchor" href="#版本说明"></a> 版本说明</h5><p>v2:</p><ul><li>修复了分辨率的问题。</li></ul><p>v3:</p><ul><li>修改了玩家移动方式，现在移动更自然）</li><li>增强了打击感</li></ul><h5 id="开发团队"><a class="markdownIt-Anchor" href="#开发团队"></a> 开发团队</h5><ul><li>段皓彬</li><li>王霖</li><li>曾磊</li></ul><h5 id="资源信息"><a class="markdownIt-Anchor" href="#资源信息"></a> 资源信息</h5><p>大部分资源来源于网络。</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>像素艺术入门课程</title>
      <link href="/2019/03/04/Pixel%20Art%20Course/"/>
      <url>/2019/03/04/Pixel%20Art%20Course/</url>
      
        <content type="html"><![CDATA[<p>翻译自<a href="http://www.lesforges.org/">Les Forges</a>上<em>Fil Razorback</em>写的像素画课程系列，原教程（法语）可以在<a href="http://www.lesforges.org/article/cours-pixel-art-preface?scroll_to=article">这里</a>找到，在<a href="https://opengameart.org/">OpenGameArt</a>上此系列文章的<a href="https://opengameart.org/content/les-forges-pixel-art-course">英文翻译</a>，本文为该系列教程的中文翻译。</p><p>本文遵循Creative Common条例</p><p>长文预警…</p><a id="more"></a><h2 id="0-前言"><a class="markdownIt-Anchor" href="#0-前言"></a> 0. 前言</h2><p><em>在胡扯之前来一点严肃的内容</em></p><p>尽管像素艺术在今日的视频游戏行业中已经大大地失去了它的重要性，但它仍是独立创作者和小制作十分青睐的媒介。它易于辨别的形态有着打动各种各样玩家的能力，同时又给予了设计师使用各种技巧的机会。</p><p><img src="/images/owlboy.png" alt="Owlboy (D-Pad Studio) - 像素画的一个例子" /></p><h3 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h3><p>像素艺术有很多种定义，在这里我们只会用一种：完全手工制作的、由创作者掌控每个像素的颜色和位置的图像。显然，在像素画中不能随意地用各种画刷、模糊工具、自动渐变、亦或是各种“现代”软件提供的工具，他们均会产生“拖拉”的颜色。我们只能用一些简单的工具，比如铅笔或“画点”。</p><p>尽管如此，这并不是说像素画或非像素画哪方更优美，只是像素画相比于传统美术作品是完全不同，更贴近于“复古风格”的游戏（如任天堂Super NES或Game Boy系列）。你也可以将这里讲的技巧和非像素画融合在一起，创造一种“混合风格”。</p><h3 id="这篇教程的内容"><a class="markdownIt-Anchor" href="#这篇教程的内容"></a> 这篇教程的内容</h3><p>所以，在这篇文章中你会学到像素画的许多技术，但这并不能让你成为一个艺术家…简单的原因就是——我也不是。我不会教你人体构造学，艺术作品的构成要素，连透视法都只会涉及一点点。在这个教程中，你可以了解到很多像素艺术方面的信息，到了本教程的最后，你应该能够为你的游戏制作相关的任务和景物，只有你有足够的耐心并且持之以恒地按照给定的建议练习。</p><p>此外，我想指出这篇教程中的只有一小部分的图像是被放大了的，对于那些没被放大的图片，我建议你花点时间复制/粘贴，将它们保存下来，这样你便可以更细致地学习。像素画是关于像素的，仅靠远远观看是无法学到它的。</p><p>最后，我要感谢所有参与写作本课程的艺术师们：感谢Pierre Guyot的线稿和各种琐碎的工作，Xenodrogen高超的颜色技术，Lünn关于透视的知识，还有Panda, Poupi, Ahruon, Dyo, Kryon慷慨给予的用于展示的图片。</p><p>现在，让我们准备开始吧！</p><h3 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录</h3><ul><li>第一节：使用正确的工具</li><li>第二节：直线与曲线</li><li>第三节：透视法</li><li>第四节：光与影</li><li>第五节：调色盘</li><li>第六节：抗锯齿！</li><li>第七节：贴图和抖动</li><li>第八节：瓦块的世界</li></ul><h2 id="第一节-使用正确的工具"><a class="markdownIt-Anchor" href="#第一节-使用正确的工具"></a> 第一节 使用正确的工具</h2><p><em>坏消息：你在本节一个像素都不会画！（不过这不能成为跳过本节的缘由，是吧？）</em></p><p>如果要说一个我不能忍受的谚语，那就会是：</p><blockquote><p>没有不合格的工具，只有不合格的工人。</p></blockquote><p><img src="/images/charamaker-apercu.png" alt="Charamaker 1999 - 一个专注于像素画的软件" /></p><p>确实，我认为这句话离真理不能更远了（可能除了“但凡不能杀死你的,最终都会使你更强大”这句），而像素艺术九就是一个很好的证据。本节旨在介绍各种各样用于制作像素画的软件，并帮助你选择正确的软件。</p><h3 id="古老的东西"><a class="markdownIt-Anchor" href="#古老的东西"></a> 古老的东西</h3><p>当你要选择像素画的软件时，你最经常想到的可能是：</p><blockquote><p>为什么要选软件？我觉得Windows自带的<strong>画图</strong>就已经足够了！</p></blockquote><p>错误来了：我之前说了不合格的工具，这就是一个例子。<strong>画图</strong>有且仅有一个好处：你不需要安装，它已经在你的Windows上了；但它的缺点却有一堆，这里有一个没写完的列表：</p><ul><li>你不能同时打开多个文件</li><li>没有调色盘管理</li><li>没有图层和透明度</li><li>没有矩形选择工具（现在好像有了）</li><li>几乎不存在键盘快捷键</li><li>辣鸡的人性化设计</li></ul><p>简而言之，你还是忘了<strong>画图</strong>吧。我们来看点真正的软件。</p><h3 id="终于"><a class="markdownIt-Anchor" href="#终于"></a> 终于…</h3><p>我们常常想的是：</p><blockquote><p>好吧，<strong>画图</strong>对我来说功能太简陋了，我要用<strong>PhotoShop</strong>（或者<strong>PaintShopPro</strong>或<strong>The Gimp</strong>，都是一样的）这种操作更加丰富的软件。</p></blockquote><p>这可能是一个好事，也可能是一个坏事：如果你已经对这几个程序中的一个很熟悉，你可以用它们来做像素画（需要关闭所有带有自动抗锯齿的选项）。如果你还对它们没那么熟悉，尝试学习那些复杂但我们很少用到的功能是一件得不偿失的事。</p><p>一句话，如果你早已习惯它们，自然就可以用，否则最好选择更加适合像素画的软件。</p><h3 id="最佳软件"><a class="markdownIt-Anchor" href="#最佳软件"></a> 最佳软件</h3><p>用于制作像素画的软件比你可能想的要多得多，但我这里只会选几个最佳的出来。他们功能基本一致（调色板管理，预览重复瓦片，透明度，图层，等等等等），其中的区别只在易用度和…价格。</p><h4 id="charamaker-1999"><a class="markdownIt-Anchor" href="#charamaker-1999"></a> Charamaker 1999</h4><p><strong>Charamaker 1999</strong> 对你这种入门画家来说有着巨大的优势：其官方的软件源在很久之前就停止了，所以你可以轻易的在网上随便一个地方下到它。</p><p><img src="/images/charamaker.png" alt="Charamaker 1999的界面" /></p><h4 id="graphicsgale"><a class="markdownIt-Anchor" href="#graphicsgale"></a> Graphicsgale</h4><p>对我自己来说，我发现<strong>Graphicsgale</strong>的界面可读性非常好，并且操作方便。然而，它是收费软件（约92￥），这个价钱并不算高。另外，其试用版<strong>几乎</strong>包括了制作游戏图像所必要的功能。试用版唯一缺少的功能是对<code>.gif</code>文件的支持，但这一般不是问题，因为<code>.png</code>文件已经足够了。试用版并没有限制试用时间，因此不失为一个长期可用的选项。</p><blockquote><p>译注：Graphicsgale在2017年已经成为免费软件，你可以在<a href="https://graphicsgale.com/">这里</a>下载到。</p></blockquote><p><img src="/images/graphicsgale.png" alt="Graphicsgale的界面" /></p><h4 id="promotion"><a class="markdownIt-Anchor" href="#promotion"></a> Promotion</h4><p>被专业像素艺术家使用的最多的是<strong>Pro-motion</strong>，它相比<strong>Graphicsgale</strong>更加人性化。然而，它很贵！获取完整版大概需要…380￥（目前它在Steam上售价112）。</p><p><img src="/images/pro-motion.png" alt="Promotion的界面" /></p><p>你可以在 <a href="http://www.cosmigo.com/promotion/">官方网站</a> 下载到试用版。</p><h4 id="pixen"><a class="markdownIt-Anchor" href="#pixen"></a> Pixen</h4><p>让我们别忘了MaxOS用户…<strong>Pixen</strong>是一个和前几款软件类似的开源软件，有着免费的优点，虽然其开发进程很混乱。我没有Mac，所以不能给你详细的介绍，如果你对它感兴趣，可以在<a href="https://github.com/Pixen/Pixen">Github</a>上找到它。</p><blockquote><p>译注：这篇文章是很多年前写的，这么多年过去，Pixen已经不再是开源软件了…你可能需要寻找一些替代品… 而对于Linux用户，可以看看 <em>JDraw</em> 和 <em>GrafX2</em>。</p></blockquote><hr /><p>我建议你将这些软件的试用版都找来用用，看看哪个最适合你，毕竟这主要是口味的不同。要注意的是，一旦你习惯了某个软件，再去更换是比较困难的。</p><h2 id="第二节-直线与曲线"><a class="markdownIt-Anchor" href="#第二节-直线与曲线"></a> 第二节 直线与曲线</h2><p>如果你还不是一个小有成就的艺术家，对你来说开始绘画的最好方式就是拿起一只铅笔，画上线条，直到满意，然后涂上颜色。这对于像素画来说也是一样的：第一步是描绘出图像的轮廓——这一步称作“线稿”。</p><p>线稿是创造像素画的重要一步。你画的图像的某一小块像素可能占到整幅画的很大一部分（非像素画则不然，对那种尺度来说几个像素不足为道），所以几个像素的错误就有可能会使你的人物严重变形。再强调一下，线条准确性十分<strong>重要</strong>。</p><p><img src="/images/smw2-contours.png" alt="超级马里奥世界 2 - Yoshi's Island (任天堂)" /></p><h3 id="1直线"><a class="markdownIt-Anchor" href="#1直线"></a> 1.直线</h3><p>线稿是由直线和曲线组成的，我们来先谈论直线。如果你上过数学课，你就知道直线可以由它的斜率来描述。斜率是 “y方向的变化” 除以 “x方向的变化”。在这篇教程中，我会用 Y:X 来表示斜率。因此，一条完美的从左下角到右上角的对角线的斜率为 1:1。这里有一张描述斜率关系的图。</p><p><img src="/images/droites-parfaites.png" alt="完美的直线" /></p><p>在像素艺术中，使用简单比例的线（0:1, 1:2, 1:1, 2:1, 1:0）被认为是“完美的直线”。它们让你的图片看起来不错，因为人眼可以轻而易举地跟着它们。除了这些之外，你还可以画出在这之间的线，比如只要把1像素长的片段和2像素长的片段交替放置便可以模拟出1.5:1斜率的线（下图）。然而这样画出的线的美感显然不如之前的好。这就是为什么要少用像中间的这种线条。不过不要担心，它们还是有用的，你在之后的章节也会学到如何嵌入它们到你的画中。</p><p><img src="/images/droites.png" alt="1.5：1斜率的直线" /></p><h3 id="2曲线"><a class="markdownIt-Anchor" href="#2曲线"></a> 2.曲线</h3><p>只用直线画不了什么有意思的东西，所以让我们来讲讲更加复杂的曲线。曲线不像直线你们简单，好的曲线和不好的曲线差别很大。</p><p>要画出一条平滑的曲线必须遵循一个原则：每个片段的长度必须渐进的变化，并且你要避免不合理的直角。好吧，这其实是两条规则，但第二条其实已经包含在了第一条中。来看一个例子。</p><p><img src="/images/courbes.png" alt="好的曲线和失败的曲线" /></p><ul><li>图中绿色的曲线完全遵循了这条规则。从左到右，每个片段的长度为<strong>5 4 3 2 2 1 1 1 2 3 3 3 2 1 1 2 2 1 2 1 2 1 1</strong>。可以看到，相邻片段长度的变化的绝对值都小于等于1（所以肯定不会出现 <strong>5 3</strong> 或 <strong>2 4</strong> 的情况）。也许有时会变化的多一点，但肯定不会是很突然。</li><li>红色的曲线完全背离的这条规则（注意右边出现的直角）。</li></ul><p>一种好的绘制曲线的技巧是先徒手画出线条，然后再回去修改它，直到符合我们的规则为止，这样的话就保证了曲线看起来不会很糟。</p><hr /><p>我用两幅例子来作为本节的结尾。第一幅画是一条龙，它的曲线完全符合之前所述的规则；第二幅画是一把剑，它有一些明显更尖的线条（比如剑的末梢），这告诉我们即使不平滑的线有时也能派上用场。</p><p><img src="/images/lineart-dragon.png" alt="龙的线稿" /></p><p><img src="/images/lineart-epee.png" alt="剑的线稿" /></p><p>我强烈建议你在继续阅读前练习下线条画，你需要它来完成后续的章节。如果你遇到了问题，不管怎样可以尝试一下临摹。</p><h2 id="第三章-透视"><a class="markdownIt-Anchor" href="#第三章-透视"></a> 第三章 透视</h2><p>2D游戏的透视问题一直频繁出现，这也是许多业余游戏出现不协调的地方。本节主要涉及典型RPG游戏的透视问题，所以如果你需要找关于横版或是第一人称的信息，你可能要去别处找找。有一点需要记住的是，透视是关于“将三维空间的物体以我们平时看到的样子展现在平面上的艺术（在这里，平面就是你的屏幕）”。</p><p><img src="/images/perspectives-apercu.png" alt="塞尔达传说 ~ The Minish Cape (Capcom)" /></p><p>在开始之前，我想先感谢Lunn，没有他这节就无法完成。本节内容其实是我和他对话内容的编辑版本。</p><h3 id="1透视有几种"><a class="markdownIt-Anchor" href="#1透视有几种"></a> 1.透视——有几种?</h3><p>透视不止一种，如果你看过艺术类的书籍或课程，你就知道有1点，2点，3点透视。不过这不是我们要讲的内容，所以你可以先不管它们。=）</p><p>在2D游戏中，最简单的透视被称作“<em><strong>轴测透视</strong></em>”。这个奇怪的名字指的是什么呢？在轴测透视中，物体的三个坐标（X，Y和Z）沿着直线方向<strong>恒定</strong>地增加。这意味着两条在现实中平行的线在轴测透视中也是平行的，而且物体的大小和观察者与其的距离无关。一图胜千言：</p><p><img src="/images/grid.jpg" alt="一个轴测透视的例子" /></p><p>轴测透视有无数种角度，因为你可以随便选择三条轴的角度。我们只关注3种最常用的轴测透视：</p><p><img src="/images/perspectives-1.png" alt="RPG游戏中常见的3种轴测透视" /></p><p>左边的这个叫做<strong>对等轴测投影</strong>：它一般要求Y轴旋转30°，但30°并不适合像素画（前一章解释了为什么），所以我们取而代之的是用1：2的直线来表示（角度这时为26.5651°）。这个视角很适合战术类RPG游戏，因为它能提供可观的深度和广度；但由于它瓦片的形状，它不适合大多数传统的关卡编辑器（比如RPG Maker）。</p><p>（未完待续…）</p>]]></content>
      
      
      <categories>
          
          <category> 游戏美术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 像素游戏 </tag>
            
            <tag> 像素 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于线性采样的高效高斯模糊实现（译）</title>
      <link href="/2018/04/15/Efficient-Gaussian-blur-with-linear-sampling/"/>
      <url>/2018/04/15/Efficient-Gaussian-blur-with-linear-sampling/</url>
      
        <content type="html"><![CDATA[<p>高斯模糊是一种柔和模糊的图像效果。模糊后的图像可以被更复杂的算法用来产生形如炫光（bloom）、景深、热浪或者磨砂玻璃的效果。在本文中，我将会讲解如何利用高斯滤波器的种种优良特性来提高实现的效率，和利用贴图查找中双线性插值的特点，来大大提高高斯模糊效率的小技巧。虽然本文讲述的重点是高斯模糊滤波器，但其中大部分原理都可以运用在实时渲染中的其他卷积滤波器上。</p><a id="more"></a><p>**高斯模糊（Gaussian blur）**是图形学中一种常用的技术。不管我们讨论的是离线渲染器还是游戏引擎，许多渲染技术都需要它来产生可信的照片级效果。既然可编程图形管线早已出现，在片段着色器里采用高斯模糊或其他模糊滤波器俨然已经成为每一个游戏引擎必备的技术。</p><p>基础的卷积滤波算法极其消耗性能，然而许多显著降低计算量的优雅技巧，能使高斯模糊即便在老掉牙的硬件上也能流畅运行。这篇文章将会像教程一样，讲解大部分可行的优化技巧。其中一些技巧你可能已经听过，但线性采样（linear sampling）还是能给你一些惊喜。</p><p>让我们先从基础部分开始。</p><h2 id="术语"><a class="markdownIt-Anchor" href="#术语"></a> 术语</h2><p>为了提前消除你可能产生的疑惑，我会从介绍一些本文中出现术语和概念讲起。</p><p><strong>卷积滤波器（Convolution filter）</strong>– 融合一组像素的颜色值的算法</p><p><strong>NxN-tap滤波器（NxN-tap filter）</strong>– 使用NxN个像素的过滤器</p><p><strong>N-tap滤波器（N-tap filter）</strong>– 使用1xN个像素的过滤器。注意一个N-tap滤波器并不意味着它必须要采样N个纹素，它也可以被实现为采样少于N个纹素。</p><p><strong>滤波器核（Filter kernel）</strong>– 一组用来采样的相对坐标、权重集合</p><p><strong>离散采样（Discrete sampling）</strong>– 恰好只读取一个纹素的采样方法（也就是 <code>GL_NEAREST</code> 采样）</p><p><strong>线性采样（Linear sampling）</strong>– 读取2x2个纹素并双线性插值的采样方法（也就是 <code>GL_LINEAR</code> 采样）</p><h2 id="高斯滤波器"><a class="markdownIt-Anchor" href="#高斯滤波器"></a> 高斯滤波器</h2><p>图像空间的高斯滤波器是一个 NxN的卷积滤波器，它的采样权重基于高斯函数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>π</mi><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">G(x,y)=\frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.3013099999999997em;"><span style="top:-3.4534200000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.2112714285714286em;"><span style="top:-2.5061857142857145em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9384399999999999em;"><span style="top:-2.93844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.4623857142857144em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.04844em;"><span style="top:-3.04844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span><span class="mbin mtight">+</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.04844em;"><span style="top:-3.04844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49381428571428565em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p>滤波器覆盖的像素将乘以一个有高斯函数得来的权重，来达成模糊的效果。高斯滤波器的空间表示（通常被称为“钟型曲线”），展示了每一个覆盖到的像素如果对最终的像素造成影响。</p><p><img src="/images/gaussian_graph.png" alt="二维高斯函数的图形表示" /></p><p>看到这个你也许会说：“啊哈，所以我们只需要做NxN次贴图读取然后把它们加权求和就OK了”。虽然是这样，它却没看起来那么高效。比如我们有一张大小为1024x1024的图片，然后用片段着色器实现基于这种方法的33x33高斯模糊滤波器，需要多达1024 * 1024 * 33 * 33 ≈ 11.4 亿次贴图读取才能在整张图片上应用这个模糊滤镜。</p><p>为了得到一个更高效的算法，我们需要分析一下高斯函数的一些良好性质：</p><ul><li><p>二维高斯函数可以拆分为两个一维高斯函数计算</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mfrac><mn>1</mn><msqrt><mrow><mn>2</mn><mi>π</mi><msup><mi>σ</mi><mn>2</mn></msup></mrow></msqrt></mfrac><msup><mi>e</mi><mrow><mo>−</mo><mfrac><msup><mi>x</mi><mn>2</mn></msup><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac></mrow></msup></mrow><annotation encoding="application/x-tex">G(x) = \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{x^2}{2\sigma^2}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.25144em;vertical-align:-0.93em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.154946em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9550540000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord">2</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.915054em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.08494599999999997em;"><span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.93em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.24644em;"><span style="top:-3.4534200000000004em;margin-right:0.05em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight"><span class="mopen nulldelimiter sizing reset-size3 size6"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1328857142857145em;"><span style="top:-2.5061857142857145em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9384399999999999em;"><span style="top:-2.93844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.2255000000000003em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line mtight" style="border-bottom-width:0.049em;"></span></span><span style="top:-3.384em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.04844em;"><span style="top:-3.04844em;margin-right:0.1em;"><span class="pstrut" style="height:2.64444em;"></span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.49381428571428565em;"><span></span></span></span></span></span><span class="mclose nulldelimiter sizing reset-size3 size6"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p></li><li><p>一个有着<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msqrt><mn>2</mn></msqrt><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sqrt2\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.13278em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.90722em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;">2</span></span><span style="top:-2.86722em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.13278em;"><span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>分布的高斯函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mrow><msqrt><mn>2</mn></msqrt><mi>σ</mi></mrow></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G_{\sqrt2\sigma}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1332em;vertical-align:-0.38319999999999993em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.4058085em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord sqrt mtight"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.912845em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mtight" style="padding-left:0.833em;">2</span></span><span style="top:-2.872845em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail mtight" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80H400000v40H845z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12715500000000002em;"><span></span></span></span></span></span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.38319999999999993em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>等价于两个有着<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span>的高斯函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>G</mi><mi>σ</mi></msub><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G_{\sigma}(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>应用两次（注：原文此处表述有误，该性质的证明见<a href="https://math.stackexchange.com/questions/3159846/what-is-the-resulting-sigma-after-applying-successive-gaussian-blur">此处</a>）</p></li></ul><p>这两个性质给了我们很大的优化空间。</p><p>基于第一个性质，我们可以将二维高斯函数分离为两个一维高斯函数。这意味着片段着色器的实现中，可以把高斯滤波器分为水平方向和垂直方向的滤波器，比如先应用水平方向的滤波器再应用垂直方向的滤波器，仍然可以得到与直接应用二维滤波器相同的结果。所以，我们最后只需要两个1xN滤波器和一次额外的渲染pass。回到我们的例子，在1024x1024大小的图片上应用两次1x33滤波器，我们需要1024 * 1024 * 33 * 2 ≈ 6900万次贴图读取。这个读取量就远远小于之前的方法了。</p><p>第二个性质可以用来绕过在一个pass中只能读取有限次贴图的硬件限制。</p><h2 id="高斯卷积核的权重"><a class="markdownIt-Anchor" href="#高斯卷积核的权重"></a> 高斯卷积核的权重</h2><p>至少在理论上，我们已经看到了怎么高效地实现一个高斯模糊滤波器，但我们还没讨论为了得到最终的结果，滤波器怎么计算每一个像素所占的权重。最显而易见的方式是为不同坐标分布计算高斯函数的值来确定卷积核权重。虽然这是很通用的方法，但我们有一种更方便的计算权重的方法——二项式系数。为什么我们能怎么做？因为高斯函数其实是正态分布函数，而正态分布的离散形式就是采用二项式系数做加权的二项式分布。</p><blockquote><p><img src="/images/binomial_coeff2.png" alt="帕斯卡三角形" /></p><p>帕斯卡三角形（杨辉三角）展示了二项式系数，它可以用来计算卷积核权重（每个元素是上一排的两个相邻元素的和）</p></blockquote><p>为了实现我们的9x1水平滤波器和1x9垂直滤波器，我们将用上图帕斯卡三角形的最后一行来计算权重。你可能会问，为什么不用index为8的行（它刚好有9个数字）？这是个可证明的问题，但回答起来却很简单。这是因为在典型的32位颜色缓冲上最边上的系数对最终结果没有任何的影响。我们希望，在提供最佳质量的同时，使贴图读取次数最小化。显然，当我们需要高精度的结果，且有更高精度的颜色缓冲供我们使用时，用index为8的带小数的那行更好一些。但先回到我们原本的想法，使用最后一行…</p><p>有了必要的系数后，计算线性插值需要的权重就很简单了。我们只需将每个系数除以系数的总和（在这里是4096），当然，为了纠正消去最外层四个系数的影响，我们应该将总格减到4070，否则图片在运用几次滤波器后就会变暗许多。</p><p>现在，有了需要的权重，如何实现我们的片段着色器就显而易见了。我们来看看垂直滤波着色器的GLSL代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D image;</span><br><span class="line"></span><br><span class="line">out vec4 FragmentColor;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> offset[<span class="number">5</span>] = <span class="keyword">float</span>[]( <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span> );</span><br><span class="line">uniform <span class="keyword">float</span> weight[<span class="number">5</span>] = <span class="keyword">float</span>[]( <span class="number">0.2270270270</span>, <span class="number">0.1945945946</span>, <span class="number">0.1216216216</span>,</span><br><span class="line">                                   <span class="number">0.0540540541</span>, <span class="number">0.0162162162</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragmentColor = texture2D( image, vec2(gl_FragCoord)/<span class="number">1024.0</span> ) * weight[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">        FragmentColor +=</span><br><span class="line">            texture2D( image, ( vec2(gl_FragCoord)+vec2(<span class="number">0.0</span>, offset[i]) )/<span class="number">1024.0</span> )</span><br><span class="line">                * weight[i];</span><br><span class="line">        FragmentColor +=</span><br><span class="line">            texture2D( image, ( vec2(gl_FragCoord)-vec2(<span class="number">0.0</span>, offset[i]) )/<span class="number">1024.0</span> )</span><br><span class="line">                * weight[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然水平滤波器只是将偏移值从应用在Y坐标上改变为应用在X坐标上。注意，在除以1024以得到屏幕空间的坐标时，我们硬编码了图片的大小。在实际应用中，我们可能会用一个uniform替代它，或直接使用不需要归一化纹理坐标的纹理矩形。</p><p>如果你不得不多次应用滤波器来得到更强烈的效果，唯一要注意的事情是在两个帧缓冲间切换，将着色器应用在前一步保存结果的帧缓冲上。</p><blockquote><p><img src="/images/gaussian1.png" alt="" /></p><p>1x9和9x1的滤波器应用在大小为1024x1024的图片上：原始图片（左边）、应用1次（中间）、应用9次（右边）。</p></blockquote><h2 id="线性采样"><a class="markdownIt-Anchor" href="#线性采样"></a> 线性采样</h2><p>到此为止，我们已经知道怎么实现一个分离两次渲染的高斯滤波器。我们也看到了，在1024x1024 的图片上可以使用这个滤波器九次来得到33x33大小的滤波器的效果，仅仅只需5千6百万次贴图读取。尽管这已经很高效了，它并没能完全利用到GPU的优势，因为这种算法也能毫无修改，完美地运行在CPU上。</p><p>现在，我们已经可以利用GPU提供的固定功能硬件管线来进一步减少贴图读取的次数。为了达到优化的目的，让我们先回顾一下这篇文章开头所作的一个假设。</p><p>到此为止，我们假设了我们必须要做一次贴图读取来获得一个像素的信息，意味着9个像素需要9次贴图读取。尽管这对于在CPU上的实现来说是成立的，但在GPU上却不总是这样。这是因为在GPU上我们能随意地使用双线性插值（bilinear sampling）而没有什么额外的负担。这意味着如果我们不在纹素中心读取贴图，我们就可以得到多个像素的信息。既然我们已经利用了高斯函数的可分离性，实际上是在1D下工作，双线性插值会给我们提供2个像素的信息。每个纹素贡献对颜色的贡献量则由我们使用的坐标决定。</p><p>通过正确地调整贴图读取的坐标偏移我们可以仅通过一次贴图读取得到两个像素或纹素的准确信息。这意味着为了实现一个9x1或1x9的高斯滤波器我们只需要5次贴图读取。总的来说，Nx1或1xN的滤波器我们需要[N/2]次贴图读取。</p><p>这对我们之前为离散样本高斯滤波器使用的权重值有什么意义呢？这意味着每种情况下我们使用单次的贴图读取获得了两个纹素的信息，我们需要用其乘以两个纹素对应的权重和所计算出的新权重。既然我们知道了权重是什么，我们现在只需要计算正确的纹理坐标偏移了。</p><p>我们可以简单地用两个纹素中心点的中间坐标作为纹理坐标。虽然这是一个好的近似，我们并不会使用它——因为我们能计算出更好的坐标，得到与离散采样一模一样的效果。</p><p>对于两个纹素的合并，我们需要调整坐标使<strong>其与纹素#1中心的距离等于纹素#2的权重除以两个权重之和</strong>。同样的，坐标与纹素#2中心的距离应该等于纹素#1的权重除以两个权重之和。</p><p>然后我们就有了计算线性采样高斯滤波的权重和位移公式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>L</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>D</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>D</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><msub><mi>t</mi><mi>L</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><msub><mi>t</mi><mi>D</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>⋅</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>D</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>o</mi><mi>f</mi><mi>f</mi><mi>s</mi><mi>e</mi><msub><mi>t</mi><mi>D</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>⋅</mo><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>D</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><mrow><mi>w</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><msub><mi>t</mi><mi>L</mi></msub><mo stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">weight_L(t_1,t_2)=weight_D(t_1)+weight_D(t_2)\\offset_L(t_1,t_2)=\frac{offset_D(t_1) \cdot weight_D(t_1) + offset_D(t_2) \cdot weight_D(t_2)}{weight_L(t_1,t_2)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>为了使用这个信息，我们只需替换uniform常量并减少纵向滤波器shader中迭代的次数，得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">uniform sampler2D image;</span><br><span class="line"></span><br><span class="line">out vec4 FragmentColor;</span><br><span class="line"></span><br><span class="line">uniform <span class="keyword">float</span> offset[<span class="number">3</span>] = <span class="keyword">float</span>[]( <span class="number">0.0</span>, <span class="number">1.3846153846</span>, <span class="number">3.2307692308</span> );</span><br><span class="line">uniform <span class="keyword">float</span> weight[<span class="number">3</span>] = <span class="keyword">float</span>[]( <span class="number">0.2270270270</span>, <span class="number">0.3162162162</span>, <span class="number">0.0702702703</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragmentColor = texture2D( image, vec2(gl_FragCoord)/<span class="number">1024.0</span> ) * weight[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">        FragmentColor +=</span><br><span class="line">            texture2D( image, ( vec2(gl_FragCoord)+vec2(<span class="number">0.0</span>, offset[i]) )/<span class="number">1024.0</span> )</span><br><span class="line">                * weight[i];</span><br><span class="line">        FragmentColor +=</span><br><span class="line">            texture2D( image, ( vec2(gl_FragCoord)-vec2(<span class="number">0.0</span>, offset[i]) )/<span class="number">1024.0</span> )</span><br><span class="line">                * weight[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个简化后的算法是数学正确的，如果不考虑硬件实现的算线性插值可能带来的舍入误差，我们的线性采样shader将得到和离散采样一样的结果。</p><blockquote><p><img src="/images/side2side.png" alt="" /></p><p>使用9次9x1高斯模糊，分别采用离散采样（左）和线性采样（右）。注意到我们的两种实现甚至在多次pass后仍然没有视觉上的区别。</p></blockquote><p>尽管线性采样的实现非常简单，它仍在高斯模糊滤波器上有显著的视觉效果。考虑到我们设法只用了5次的贴图读取而非9次就实现了一个9x1的滤波器，再回到我们的例子，用33x1大小滤波器模糊一张1024x1024的图片只需 1024 * 1024 * 5 * 3 * 2 ≈ 3100万次纹理读取，而不是离散采样需要的5600万次读取。这是一个合理的区别，为例体现有多大的提升，我做了一些实验来测量两种实现的区别。结果如下：</p><blockquote><p><img src="/images/comparison2.png" alt="" /></p><p>使用9x1高斯模糊，分别采用离散采样和线性采样的性能区别。（在Radeon HD5770上测试）纵轴是每秒帧率（越高越好），横轴是模糊的次数（越高越模糊）。</p></blockquote><p>我们可以看到，线性采样实现的高斯模糊的性能比离散采样实现的高了60%，不管对图片模糊了多少次。这与线性采样省下的贴图读取次数大致呈正比。</p><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><p>我们已经了解到实现一个高效的高斯模糊滤波器是十分简单的，尤其是使用线性采样的时候，得到了一个速度极快的实时算法，而它可以作为更高级的渲染技术的基础。</p><p>尽管这篇文章只讨论了高斯模糊，让其中的原理可以应用在绝大多数卷积核类型。除此之外，大多数理论要求我们模糊一张大小缩减的图片，比如光晕效果（bloom）就经常有这个要求。对于大小缩减的图片的情况来说，唯一的区别就是我们的中心像素也是一个“双重像素”。这意味着我们必须用帕斯卡三角形中有着偶数个系数的行，因为我们也想要线性采样中间的纹素。</p><p>我们也简要地介绍了不同实现的计算复杂度，并说明了怎么在GPU上高效地实现滤波器。</p><p>演示不同采样性能差别的示例程序可以在这里下载：</p><blockquote><h3 id="binary-release"><a class="markdownIt-Anchor" href="#binary-release"></a> Binary release</h3><p><strong>Platform:</strong> Windows<br /><strong>Dependency:</strong> OpenGL 3.3 capable graphics driver<br /><strong>Download link:</strong> <a href="http://www.rastergrid.com/blog/wp-content/uploads/2010/09/gaussian_win32.zip">gaussian_win32.zip (2.96MB)</a></p><p><strong>Source code</strong></p><p><strong>Language:</strong> C++<br /><strong>Platform:</strong> cross-platform<br /><strong>Dependency:</strong> GLEW, SFML, GLM<br /><strong>Download link:</strong> <a href="http://www.rastergrid.com/blog/wp-content/uploads/2010/09/gaussian_src.zip">gaussian_src.zip (5.37KB)</a></p></blockquote><hr /><blockquote><p>原作者：Daniel Rákos</p><p>创作时间： September 7, 2010</p><p>发布地址： <a href="http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">http://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> bloom </tag>
            
            <tag> 后期处理 </tag>
            
            <tag> GLSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编写光栅渲染器的参考资料</title>
      <link href="/2017/11/15/SoftRendererRefer/"/>
      <url>/2017/11/15/SoftRendererRefer/</url>
      
        <content type="html"><![CDATA[<p>最近在写一个简单的软件光栅渲染器.<br />光栅化是实时渲染领域的核心，围绕这方面的主题内容也很多。虽然以前了解过一些图形学知识，但这仍是我第一次比较彻底地了解光栅化的各种算法。<br />在学习的过程中搜索到了一些比较好的资料（主要是中文的），这里做一个总结。</p><a id="more"></a><h3 id="综合起步"><a class="markdownIt-Anchor" href="#综合起步"></a> 综合/起步</h3><ul><li><a href="https://www.zhihu.com/question/24786878">如何开始用 C++ 写一个光栅化渲染器？</a></li><li><a href="https://www.zhihu.com/question/33712299">想用C++实现一个软件渲染器，类似DX和OpenGL，除了《3D游戏编程大师技巧》，或者什么网站推荐？</a></li><li><a href="http://blog.csdn.net/zhanghuanzj/article/category/6278922">从零开始写光栅化渲染器</a></li><li><a href="http://blog.csdn.net/cppyin/article/category/780767">从零实现3D图像引擎</a></li><li><a href="http://blog.csdn.net/teajs/article/details/49989681">软件渲染器入门</a></li><li><a href="https://www.scratchapixel.com/lessons/3d-basic-rendering/rasterization-practical-implementation/overview-rasterization-algorithm">Rasterization: a Practical Implementation</a></li></ul><h3 id="渲染管线"><a class="markdownIt-Anchor" href="#渲染管线"></a> 渲染管线</h3><ul><li><a href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview">Rendering Pipeline Overview</a></li><li><a href="http://www.cnblogs.com/hjlweilong/p/5995462.html">详解OpenGL中的各种变换（投影变换，模型变换，视图变换）（一）——模型变换和视图变换</a>; <a href="http://www.cnblogs.com/hjlweilong/p/5995466.html">详解OpenGL中的各种变换（投影变换，模型变换，视图变换）（完）——法线变换</a></li><li><a href="https://en.wikipedia.org/wiki/Framebuffer">Framebuffer - Wiki</a></li></ul><h3 id="光栅化"><a class="markdownIt-Anchor" href="#光栅化"></a> 光栅化</h3><ul><li><a href="http://blog.csdn.net/sixdaycoder/article/details/72723330">光栅化之Bresenham绘线算法</a></li><li><a href="http://blog.csdn.net/cbbbc/article/details/51524032">Windows游戏编程大师技巧之三角形填充</a></li><li><a href="https://www.zhihu.com/question/34100482">三角形填充算法的主要实现细节和注意点是什么？</a></li><li><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/cc627092(v=vs.85).aspx">Rasterization Rules</a></li><li><a href="https://blog.csdn.net/seizeF/article/details/92760068">透视正确插值Perspective Correct Interpolation</a></li></ul><h3 id="光照模型"><a class="markdownIt-Anchor" href="#光照模型"></a> 光照模型</h3><ul><li><a href="http://blog.csdn.net/silangquan/article/details/45629299">Shading中的插值技术</a></li><li><a href="http://blog.csdn.net/zxx43/article/details/46755247">光栅化插值方法</a></li><li><a href="https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model">Blinn–Phong shading model - Wiki</a></li><li><a href="http://blog.csdn.net/silangquan/article/details/45629149">局部光照模型及其BRDF</a></li><li><a href="https://www.cnblogs.com/QG-whz/p/5189831.html">[CG编程] 基本光照模型的实现与拓展以及常见光照模型解析</a></li></ul><h3 id="参考项目"><a class="markdownIt-Anchor" href="#参考项目"></a> 参考项目</h3><ul><li><a href="https://github.com/skywind3000/mini3d">mini3d</a> (推荐 - 很适合初学参考)</li><li><a href="https://github.com/wuye9036/SalviaRenderer">SalviaRenderer</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> 光栅化渲染器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
